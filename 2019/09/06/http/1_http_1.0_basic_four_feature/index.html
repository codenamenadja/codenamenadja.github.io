<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>http/1.0의 신택스: 기본이 되는 네가지 요소 | Junehan&#39;s workbook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="index  HTTP 역사 및 대표 기관명칭 HTTP 0.9 HTTP 1.0 전환 Content-Type의 값 MIME타입 메서드와 스테이터스 코드 URL BODY   HTTP의_역사와_담당기관  1990년: HTTP/0.9, CREN에서 근무하던 팀 버너스리가 최초 웹서버 CERN HTTPd 개발 1996년: HTTP/1.0 1997년: HTTP/1.1">
<meta name="keywords" content="http">
<meta property="og:type" content="article">
<meta property="og:title" content="http&#x2F;1.0의 신택스: 기본이 되는 네가지 요소">
<meta property="og:url" content="https://codenamenadja.github.io/2019/09/06/http/1_http_1.0_basic_four_feature/index.html">
<meta property="og:site_name" content="Junehan&#39;s workbook">
<meta property="og:description" content="index  HTTP 역사 및 대표 기관명칭 HTTP 0.9 HTTP 1.0 전환 Content-Type의 값 MIME타입 메서드와 스테이터스 코드 URL BODY   HTTP의_역사와_담당기관  1990년: HTTP/0.9, CREN에서 근무하던 팀 버너스리가 최초 웹서버 CERN HTTPd 개발 1996년: HTTP/1.0 1997년: HTTP/1.1">
<meta property="og:locale" content="ko">
<meta property="og:updated_time" content="2021-01-25T08:36:06.071Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="http&#x2F;1.0의 신택스: 기본이 되는 네가지 요소">
<meta name="twitter:description" content="index  HTTP 역사 및 대표 기관명칭 HTTP 0.9 HTTP 1.0 전환 Content-Type의 값 MIME타입 메서드와 스테이터스 코드 URL BODY   HTTP의_역사와_담당기관  1990년: HTTP/0.9, CREN에서 근무하던 팀 버너스리가 최초 웹서버 CERN HTTPd 개발 1996년: HTTP/1.0 1997년: HTTP/1.1">
  
    <link rel="alternate" href="/atom.xml" title="Junehan&#39;s workbook" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junehan&#39;s workbook</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">work flow and descriptions</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="검색"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://codenamenadja.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-http/1_http_1.0_basic_four_feature" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/06/http/1_http_1.0_basic_four_feature/" class="article-date">
  <time datetime="2019-09-06T11:03:56.000Z" itemprop="datePublished">2019-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      http/1.0의 신택스: 기본이 되는 네가지 요소
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> index</h2>
<ol>
<li><a href="#http%EC%97%AD%EC%82%AC%EC%99%80_%EB%8B%B4%EB%8B%B9%EA%B8%B0%EA%B4%80"><strong>HTTP 역사 및 대표 기관명칭</strong></a></li>
<li><a href="#http_0.9"><strong>HTTP 0.9</strong></a></li>
<li><a href="http_1.0"><strong>HTTP 1.0 전환</strong></a></li>
<li><a href="#mime%ED%83%80%EC%9E%85"><strong>Content-Type의 값 MIME타입</strong></a></li>
<li><a href="%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80_status_code"><strong>메서드와 스테이터스 코드</strong></a></li>
<li><a href="#url"><strong>URL</strong></a></li>
<li><a href="#body"><strong>BODY</strong></a></li>
</ol>
<h2 id="http의_역사와_담당기관"><a class="markdownIt-Anchor" href="#http의_역사와_담당기관"></a> HTTP의_역사와_담당기관</h2>
<ul>
<li>1990년: HTTP/0.9, CREN에서 근무하던 팀 버너스리가 최초 웹서버 CERN HTTPd 개발</li>
<li>1996년: HTTP/1.0</li>
<li>1997년: HTTP/1.1</li>
<li>2005년: HTTP/2</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">이름</th>
<th style="text-align:center">정식 명칭</th>
<th style="text-align:center">역할/의미</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IETF</td>
<td style="text-align:center">Internet Engineering Task Force</td>
<td style="text-align:center">인터넷의 상호 접속성을 향상시키는 것을 목적으로 만들어진 임의 단체 (통신프로토콜 관리자)</td>
</tr>
<tr>
<td style="text-align:center">RFC</td>
<td style="text-align:center">Request For Comments</td>
<td style="text-align:center">IETF가 만든 규약문서         (상호 접속성 유지를 위한 사양서 모음)</td>
</tr>
<tr>
<td style="text-align:center">IANA</td>
<td style="text-align:center">Internet Assigend Numbers Authority</td>
<td style="text-align:center">포트번호와 컨텐츠타입등 웹에 관한 데이터베이스를 관리하는 단체</td>
</tr>
<tr>
<td style="text-align:center">W3C</td>
<td style="text-align:center">World Wide Web Consortium</td>
<td style="text-align:center">웹 관련 표준화를 하는 비영리 단체    (브라우저에 특화된 기능 책정)</td>
</tr>
<tr>
<td style="text-align:center">WHATWG</td>
<td style="text-align:center">Web Hypertext Application Technology Working Group</td>
<td style="text-align:center">웹 관련 규격을 논의하는 단체, W3C와 겸하는 멤버가 많다.</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="http_09"><a class="markdownIt-Anchor" href="#http_09"></a> HTTP_0.9</h2>
<ul>
<li>go 에코서버</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(writer http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    dump, err := httputil.DumpRequest(req, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    func dumprequst(req *http.request, body bool)([]byte, error)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(writer, fmt.Sprint(err), http.StatusInternalServerError)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(dump))</span><br><span class="line">    fmt.Fprintf(writer, <span class="string">"&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// 초기실행부</span></span><br><span class="line">    <span class="keyword">var</span> httpServer http.Server</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">    <span class="comment">// "/"에 접속이 있을 때, handler함수를 호출</span></span><br><span class="line">    log.Println(<span class="string">"start http listening :18888"</span>)</span><br><span class="line">    httpServer.Addr = <span class="string">":18888"</span></span><br><span class="line">    <span class="comment">// 18888포트로 설정</span></span><br><span class="line">    log.Println(httpServer.ListenAndServe())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>request 전달</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client</span></span><br><span class="line">$ curl --http1.0 http://localhost:18888/greeting</span><br><span class="line"><span class="comment"># response</span></span><br><span class="line">&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># server: request</span></span><br><span class="line">GET / HTTP/1.0</span><br><span class="line">Host: 127.0.0.1:18888</span><br><span class="line">Connection: close</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: curl/7.58.0</span><br></pre></td></tr></table></figure>
<p>0.9버전은 1.0과 호환되지 않기 때문에, 0.9요청을 전달하는 것은 현재는 불가능하다.<br>
0.9버전 당시에 content/type은 text/html밖에 존재하지 않음</p>
<ul>
<li>검색 기능</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client</span></span><br><span class="line">$ curl --http1.0 --get --data-urlencode <span class="string">"search word"</span> http://</span><br><span class="line">localhost:18888/greeting</span><br><span class="line"></span><br><span class="line"><span class="comment"># server</span></span><br><span class="line">GET /?search%20word HTTP/1.0</span><br><span class="line">Host: 127.0.0.1:18888</span><br><span class="line">Connection: close</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: curl/7.58.0</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="http_09에서_10으로"><a class="markdownIt-Anchor" href="#http_09에서_10으로"></a> http_0.9에서_1.0으로</h2>
<ul>
<li>HTTP/0.9의 프로토콜로는 할 수 없는 일
<ul>
<li>하나의 문서를 전송하는 기능만 존재(<code>&lt;html&gt; -&gt; &lt;/html&gt;</code>)</li>
<li>컨텐츠 타입은 모두 text/html로 가정. 다운로드할 컨텐츠를 서버가 바꿀 수 없었다.</li>
<li>클라이언트에서 검색이외 요청을 보낼 수 없었다.</li>
<li>새로운 문장을 전송하거나 갱신 또는 삭제 불가?(소켓유지?)</li>
<li>요청이 올바른지 혹은 서버가 올바르게 처리했는지 전달할 수 없음.</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">curl --get -v --http1.0 http://127.0.0.1:18888/</span><br><span class="line"></span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* TCP_NODELAY <span class="built_in">set</span></span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 18888 (<span class="comment">#0)</span></span><br><span class="line"><span class="comment"># &gt;로 시작하는 행이 클라이언트에서 서버로 갈 내용</span></span><br><span class="line">&gt; GET / HTTP/1.0</span><br><span class="line">&gt; Host: 127.0.0.1:18888</span><br><span class="line">&gt; User-Agent: curl/7.58.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line"><span class="comment"># 여기까지</span></span><br><span class="line">* HTTP 1.0, assume close after body</span><br><span class="line"><span class="comment"># &lt;로 시작하는 행은 서버 응답</span></span><br><span class="line">&lt; HTTP/1.0 200 OK</span><br><span class="line">&lt; Date: Fri, 06 Sep 2019 11:53:03 GMT</span><br><span class="line">&lt; Content-Length: 31</span><br><span class="line">&lt; Content-Type: text/html; charset=utf-8</span><br><span class="line">&lt; </span><br><span class="line">* Closing connection 0</span><br><span class="line">&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>1.0으로 버전업 변경점
<ul>
<li>요청 시 메서드가 추가</li>
<li>요청 시 HTTP버정이 추가(HTTP/1.0)</li>
<li>헤더가 추가(Host, User-Agent, Accept)</li>
<li>응답 시 HTTP버전과 스테이터스 코드가 포함</li>
<li>요청과 같은 형식의 헤더가 포함됨</li>
</ul>
</li>
</ul>
<p>ARPAnet에서 부터 시작된 전자메일(RFC822)이 HTTP보다 더욱 발달 했었기 때문에, 많은 참조, 승계가 일어남.</p>
<ol>
<li>
<p>Req header From Client</p>
<ul>
<li>User-Agent: 클라이언트가 자신의 어플리케이션 이름을 전달 하는 키값.</li>
<li>Referer: 서버에서 참고할 수 있는 추가 정보, 요청을 보내는 시점의 URL등을 포함. 보안때문에, 사양이 당초 보다 크게 변경됨.</li>
<li>Authorization: 특별한 클라이언트에만 통신을 허가할 떄 인증 정보를 서버에게 전달</li>
</ul>
</li>
<li>
<p>Res header From Server</p>
<ul>
<li>Content-Type: 파일 종류. MIME타입 이라는 식별자를 기술.(전자메일을 위해 만들어짐)</li>
<li>Content-Length: 바디 크기. 압축이 이루어지는 경우 압축 후의 크기</li>
<li>Content-Encoding: 압축이 이루어진 경우 압축 형식</li>
<li>Date: 문서 날짜</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 윈도우 7의 익스플로러 10 버전으로 User-Agent설정</span></span><br><span class="line">curl -v --http1.0 -A <span class="string">"Mozilla/5.0(compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)"</span> http://127.0.0.1:18888/</span><br><span class="line"></span><br><span class="line"><span class="comment"># server output</span></span><br><span class="line"></span><br><span class="line">GET / HTTP/1.0</span><br><span class="line">Host: 127.0.0.1:18888</span><br><span class="line">Connection: close</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: Mozilla/5.0(compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># client output</span></span><br><span class="line"></span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* TCP_NODELAY <span class="built_in">set</span></span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 18888 (<span class="comment">#0)</span></span><br><span class="line">&gt; GET / HTTP/1.0</span><br><span class="line">&gt; Host: 127.0.0.1:18888</span><br><span class="line">&gt; User-Agent: Mozilla/5.0(compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line">* HTTP 1.0, assume close after body</span><br><span class="line">&lt; HTTP/1.0 200 OK</span><br><span class="line">&lt; Date: Fri, 13 Sep 2019 07:41:43 GMT</span><br><span class="line">&lt; Content-Length: 31</span><br><span class="line">&lt; Content-Type: text/html; charset=utf-8 <span class="comment"># MIME타입 문자열</span></span><br><span class="line">&lt; </span><br><span class="line">* Closing connection 0</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="mime타입"><a class="markdownIt-Anchor" href="#mime타입"></a> MIME타입</h2>
<h3 id="mime타입_개요-rfc-1341"><a class="markdownIt-Anchor" href="#mime타입_개요-rfc-1341"></a> MIME타입_개요 (RFC 1341)</h3>
<p>RFC1341에 처음 등장하여, 전자메일을 위해 만들어졌으며, 파일의 종류를 구별하는 문자열이다.<br>
인터넷이 보급된 시기는 MS-DOS, 윈도우3.x, 맥 OS7등이 사용되던 시기.</p>
<p>OS별 파일의 구별</p>
<ul>
<li>윈도우: 파일 확장자를 통해 구별</li>
<li>맥: Resource fork라 불리는 메타정보로 파일 종류를 판단</li>
</ul>
<p>지금도 위 사항은 기본적으로 유지되고 있음.</p>
<h3 id="content-type의-등장-rfc-1049"><a class="markdownIt-Anchor" href="#content-type의-등장-rfc-1049"></a> Content-Type의 등장 (RFC 1049)</h3>
<p>이 시기(1988년)에는 Content-Type인 MIME_TYPE(아직 MIME타입이 아니라 값)에는</p>
<ol>
<li>POSTSCRIPT</li>
<li>TEX</li>
</ol>
<p>와 같은 것들이 있었다.</p>
<p><strong>대항목/상세</strong>, 같은 식의 표기방식을 채택한 1992년 RFC 1341에서(HTML 미등장)</p>
<ol>
<li>‘text/plain’</li>
<li>‘image/jpeg’</li>
<li>‘multipart/form-data’</li>
</ol>
<p>같은 포멧을 위한 표기 방법이 등장하게 되면서 MIME타입이라 공식화 하게된다.</p>
<ol>
<li>서버에서 클라이언트로 데이터를 전송할 때, 컨텐트 타입을 헤더에 MIME타입값으로 정의하여 send하면,</li>
<li>브라우저 혹은 무엇이든 요청을 보낸 클라이언트 어플리케이션은 그것을 수용할 수 있는지 없는지 판단하고</li>
<li>서버와 소통을 통해 최종 결정하여 body를 받는다. 이 과정을 Negotiation이라 한다.</li>
</ol>
<p>RFC 1590에서 새로운 종류의 MIME타입을 IANA에 등록신청하는 절차를 구성하였다.<br>
RFC 3023에서, JSON, XML등의 MIME타입이 공식화 되었다.<br>
이로써, XML을 기반으로 한 SVG이미지를 application/xml이 아니라,<br>
Image/svg+xml로 표기 할 수 있게 되었다.</p>
<h3 id="content-type과_보안"><a class="markdownIt-Anchor" href="#content-type과_보안"></a> Content-Type과_보안</h3>
<p>특정 타입으로 BODY를 해석해 달라는 요청을 Content-Type대신 확장자를 사용하려고 해도, 클라이언트에 따라 전송되지 않을 수 있다.</p>
<p>2000년 초기까지는 CGI를 이용한 접속 카운터(숫자가 들어간 이미지를 생성하는 Pearl등의 스크립트 언어 프로그램)로 대체.<br>
이 카운터는 .cgi라는 확장자로 HTML에서 아래와 같은 식으로 CGI를 호출하여 사용하였다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"cgi-bin/counter.cgi"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>이 경우, cgi프로그램이 <code>Content-Type:image/gif</code>같은 헤더를 생성하여 처리.</p>
<p>그러나 익스플로러는 인터넷 옵션에 따라, MIME타입이 아니라 내용을 보고 파일 형식을 추측하기도 한다.<br>
이런 동작을 <em>content sniffing</em>이라 한다.<br>
서버에서 잘못된 처리로 타입과 언매치한 바디를 주었을 때, 해결해 줄 수 있는 장점이 있으나,<br>
브라우저가 추측하는 정보가 잘못되어, 예상 외의 분석, 실행을 하는 경우에 보안의 문제가 일어난다.<br>
예를 들어 자바스크립트가 아닌데, 자바스크립트로 해석하면, 엄격한 규칙에 따라 그 응답을 브라우저에서 실행하지 않는 경우등이 있다.</p>
<p>서버에서 다음과 같은 헤더를 통하여, 브라우저의 추측을 금지하도록 지시하는 방식을 주로 사용하고 있다.</p>
<p><code>X-Content-Type-Options: nosniff</code></p>
<hr>
<h2 id="메서드와_status_code"><a class="markdownIt-Anchor" href="#메서드와_status_code"></a> 메서드와_STATUS_CODE</h2>
<h3 id="http의_또다른_메타_뉴스그룹"><a class="markdownIt-Anchor" href="#http의_또다른_메타_뉴스그룹"></a> HTTP의_또다른_메타_뉴스그룹</h3>
<p>인터넷 이전의 주요 미디어로서, 지금은 사용되지 않는 뉴스그룹은 분산 아키텍쳐로 구성되어 있다.<br>
사용자는 서버에 구독하는 최신기사를 요청하고 기사가 있으면 가져온다.<br>
웹처럼 모든 사용자가 한 곳의 서버에 접속하러 가는 것이 아니라, 복수의 서버가 master/slave구조로 연결.</p>
<p>슬레이브의 서버가 마스터로 접속하고 정보를 가져와 로컬에 저장.<br>
스토리지 용량제한으로 오래된 기사는 삭제한다.<br>
마스터서버를 참조하는 복수의 슬레이브 서버, 그리고 슬레이브에 접근하는 클라이언트 간 통신에 사용된 것이,</p>
<p><code>NNTP(Network News Transfer Protocol)</code>이다. <code>(RFC 977)</code></p>
<p>HTTP0.9보다 5년 빠른 1986년에 정식화 되었으며, 메세지 포멧은 그보다 3년 전인 <code>RFC 850</code>에서 등장하였다.<br>
이 포멧도 전자메일을 영향을 받아 정식화되었고, 마찬가지로 헤다와 본문이 있고, 사이에 빈줄이 들어가는 구성이다.<br>
HTTP는 뉴스그룹 프로토콜로 부터 <code>METHOD</code>, <code>STATUS CODE</code>를 이어받는다.</p>
<h3 id="method"><a class="markdownIt-Anchor" href="#method"></a> METHOD</h3>
<p>지정된 주소에 있는 리소스에 대한 조작을 지시한다.</p>
<ul>
<li>뉴스그룹 메서드
<ol>
<li>LIST: 그룹 목록 취득</li>
<li>HEAD: 헤더 취득</li>
<li>BODY: 기사 취득</li>
<li>POST: 투고</li>
</ol>
</li>
</ul>
<p>HTTP의 경우는 파일 시스템과 같은 설계철학으로 만들어졌다.<br>
기본으로 <code>GET</code>, <code>HEAD</code>, <code>POST</code>는 가장 많이 쓰이는 메서드이며,<br>
<code>PUT</code>, <code>DELETE</code>는 사용빈도에 따라 필수가 아니라 구현에 따라 Optional한 기능이 되었다.</p>
<ol>
<li>GET: 헤더와 컨텐츠 요청</li>
<li>HEAD: 헤더만 요청</li>
<li>POST: 새로운 문서 투고</li>
<li>PUT: 이미 존재하는 URL의 문서를 갱신</li>
<li>DELETE: 지정된 URL의 문서를 삭제, 성공시 해당 URL은 무효</li>
</ol>
<p><code>curl --http1.0 --request POST http://127.0.0.1:18888/</code></p>
<h3 id="status_code"><a class="markdownIt-Anchor" href="#status_code"></a> STATUS_CODE</h3>
<p>뉴스그룹 프로토콜에서 가져온 기능으로, 5가지 카테고리로 나눌 수 있다.</p>
<ul>
<li>1XX번대: 처리가 계속됨을 나타낸다.</li>
<li>2XX번대: 성공했을 때의 응답. 200 OK 정상종료</li>
<li>3XX번대: 서버에서 클라이언트로의 명령. 오류가 아니라 정상처리의 범주이며, <code>리디렉트</code>, <code>캐시 이용</code>등을 지시한다.</li>
<li>4XX번대: 클라이언트가 보낸 요청에 오류가 있다.</li>
<li>5XX번대: 서버 내부에서 오류가 발생했다.</li>
</ul>
<h3 id="리디렉트"><a class="markdownIt-Anchor" href="#리디렉트"></a> 리디렉트</h3>
<p>Redirect를 통해 다른 페이지를 GET하라는 권고로, 해당 요청에서는 시나리오가 없으니, 다시 요청을 날리라는 표현.</p>
<table>
<thead>
<tr>
<th style="text-align:center">코드번호</th>
<th style="text-align:center">메서드 변경</th>
<th style="text-align:center">영구적/일시적</th>
<th style="text-align:center">캐시</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">301 Moved Permanently</td>
<td style="text-align:center">O</td>
<td style="text-align:center">영구적</td>
<td style="text-align:center">한다</td>
<td style="text-align:center">도메인 전송, 웹사이트 이전, HTTPS</td>
</tr>
<tr>
<td style="text-align:center">302 Found</td>
<td style="text-align:center">O</td>
<td style="text-align:center">일시적</td>
<td style="text-align:center">지시에 따름(<code>Cache-Control</code>, <code>Expires</code>헤더를 통해)</td>
<td style="text-align:center">일시적 관리, 모바일 기반 전송</td>
</tr>
<tr>
<td style="text-align:center">303 See Other</td>
<td style="text-align:center">허가</td>
<td style="text-align:center">영구적</td>
<td style="text-align:center">하지않음</td>
<td style="text-align:center">로그인 후 페이지 전환</td>
</tr>
<tr>
<td style="text-align:center">307 Temporary Redirect</td>
<td style="text-align:center"></td>
<td style="text-align:center">일시적</td>
<td style="text-align:center">지시에 따름</td>
<td style="text-align:center"><code>RFC 7231</code>에서 추가</td>
</tr>
<tr>
<td style="text-align:center">308 Moved Permanetly</td>
<td style="text-align:center"></td>
<td style="text-align:center">영구적</td>
<td style="text-align:center">한다</td>
<td style="text-align:center"><code>RFC 7538</code>에서 추가</td>
</tr>
</tbody>
</table>
<ul>
<li>영구적: 영구적인 접근 차단.(무효한 자원, HTTP -&gt; HTTPS)</li>
<li>일시적: 이동하려던 페이지에 언젠가는 이동 가능(존재하는 자원)</li>
<li>303의 경우: 로그인 같은 경우는 보통 POST메서드로 이루어지는데,<br>
자원에 대한 요청이 아니기 때문에, 반환할 컨텐츠가 없으며, 동시에 별도로 처리할 페이지가 있는 경우이다.<br>
따라서 해당 리디렉션은 일시적으로 접근 못하는 것이 아니라 정상적인 시나리오 내에서,<br>
영구적으로 가야하는 곳을 다시 지정하는 시나리오.</li>
<li>301의 경우: 요청된 페이지가 다른 장소로 이동했을떄, 기존도메인에서 301을 처리해주면,<br>
<strong>구글검색엔진은 해당 페이지에 대한 평가를 리디렉션으로 상속</strong>시킨다.</li>
</ul>
<p>Redirection의 경우 대부분 헤더에 <code>Location</code>키값이 존재히는데,<br>
<code>curl --location --max-redirs 5 GET http://127.0.0.0.1:18888/get_to_redirect/</code><br>
Response-헤더에 location이 존재할 경우, 해당 값으로 GET 최대 5회까지 리디렉션을 보내고, 기존 Request-헤더를 유지한다.</p>
<blockquote>
<p>구글은 리디렉트의 사이드 이펙트를 염려하며, 권장 3회 이하, 최대 5회 이하라는 가이드 라인을 제시하였다.</p>
</blockquote>
<p><code>RFC 2616</code>에서는 302의 코드설명상,</p>
<blockquote>
<p>메서드변경을 허가가 필요하도록 하였고, 현재 유저에이전트는 대부분 GET으로 변경한다.</p>
</blockquote>
<p><code>RFC 7231</code>애서는,</p>
<blockquote>
<p>302를 301처럼 메서드 변경을 허용하고, 변경허가가 필요한 307, 308을 추가한다.</p>
</blockquote>
<hr>
<h2 id="url"><a class="markdownIt-Anchor" href="#url"></a> URL</h2>
<p><code>RFC 1738</code>에서 등장하였으며, 상대적 URL은 <code>RFC 1808</code>에서 등장.<br>
이들은 모두 HTTP/1.0보다 빠른 시기의 문서로,<br>
HTTP/0.9중에 HTTP/1.0를 계획하에 먼저 규격화 되었다.</p>
<h3 id="url의_구조"><a class="markdownIt-Anchor" href="#url의_구조"></a> URL의_구조</h3>
<p>일반적인 경우</p>
<p><code>스키마://호스트명/경로</code>의 형태로 구성이 되지만, URL사양에 포함되는 모든 요소가 들어간 경우는<br>
<code>스키마://사용자:패스워드@호스트명:포트/경로#프래그먼트?쿼리</code>로 구성된다.</p>
<ol>
<li><code>스키마</code>: 스키마해석은, 브라우저의 책임이며, https. mailto, ftp등이 올 수 있다.<br>
로컬 파일을 브라우저로 열면 <code>file:</code>로 표시된다.</li>
<li><code>사용자:패스워드</code>: Basic인증 방식이며, 로그에 URL이 남게되어 유출되기 때문에, 웹 시스템에서는 사용하지 않는다.</li>
<li><code>호스트명</code>: DNS서버에, 엔드포인트로는 실제 IP라우팅 주소값을 특정하여 목적지를 찾아간다.</li>
<li><code>포트</code>: 스키마에 따라서 기본 well-known-port로 처리되며, 한 서버에 여러포트를 사용하는 경우 복수 서비스를 운영할 수 있다,</li>
<li><code>프래그먼트</code>: HTML문서 내의 링크 앵커를 지정</li>
<li><code>쿼리</code>: 해당 웹페이지에 대해서 특정 파라미터를 부여하고 싶은 경우 사용</li>
</ol>
<h3 id="url과_국제화"><a class="markdownIt-Anchor" href="#url과_국제화"></a> URL과_국제화</h3>
<p>기존엔 URL의 도메인 이름으로 영숫자와 하이픈만 사용 가능.<br>
2003년 <code>RFC 3492</code>에서 IDN(International Domain Name)을 표현하는 인코딩 규칙 <strong>PUNY CODE</strong>가 정해져,<br>
퓨니코드가 구현된 브라우저에서는 다국어를 도메인 네임으로 사용할 수 있다.<br>
정해진 규칙에 따라, 영숫자이외의 문자를 반각영숫자로 치환해 요청을 보낸다.</p>
<p><code>한글도메인.kr</code> -&gt; <code>xn--bj0bj3i97fq8o5lq.kr</code>이 된다.</p>
<p>퓨니코드는 반드시 <code>xn--</code>로 시작되는 문자열을 생성한다.</p>
<hr>
<h2 id="body"><a class="markdownIt-Anchor" href="#body"></a> BODY</h2>
<p>HTTP1.0이후부터 요청, 응답 모두 헤더를 포함하게 되면서, 헤더와 바디를 분리할 필요가 있어졌다.<br>
전자메일과 같이 헤더의 끝에 빈줄<code>\n</code>을 넣으면 그 이후는 모두 바디가 된다.</p>
<p>그러나 바디의 전송할 때, 데이터를 저장하는 포멧이 2종류가 존재하여서, 용도에 맞게 구분법이 다르다.</p>
<ol>
<li><code>Content-Encoding</code>의 압축알고리즘을 통한 압축전송과 HTMLFORM, XMLHttpRequest를 사용한 Request측 바디 전송</li>
<li>청크 형식의 바디 송신</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">헤더1: 값</span><br><span class="line">헤더2: 값</span><br><span class="line">Content-Length: 바디의 바이트 수</span><br><span class="line"></span><br><span class="line">--이 줄부터 지정된 바이트 수 만큼 바디--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Head요청시, 헤더만을 요구하는 요청이지만, Content-Length와 E-Tag등을 바르게 전송해야한다.</p>
</blockquote>
<ul>
<li>Curl커맨드의 바디 획득 옵션</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">옵션</th>
<th style="text-align:right">용도</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-d, --data, --data-ascii</td>
<td style="text-align:right">변환 완료된 텍스트데이터</td>
</tr>
<tr>
<td style="text-align:center">–data-urlencode</td>
<td style="text-align:right">텍스트 데이터 ascii변환</td>
</tr>
<tr>
<td style="text-align:center">–data-binary</td>
<td style="text-align:right">바이너리 데이터</td>
</tr>
<tr>
<td style="text-align:center">-T Filename, -d @Filename</td>
<td style="text-align:right">보내고 싶은 데이터를 파일에서 읽어온다.</td>
</tr>
</tbody>
</table>
<p>송신시 바디를 서버에 보내려면 -d옵션을 사용한다.<br>
그럴 경우 기본적으로 <code>Content-Type:application/x-www-form-urlencoded</code>가 된다.</p>
<ul>
<li>JSON을 전송하고 싶은 경우</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -d <span class="string">"&#123;\"hello\":\"world\"&#125;"</span> -H <span class="string">"Content-Type: application/json"</span> http://127.0.0.1:18888/</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON파일에서 읽어서 전송</span></span><br><span class="line">curl -d @test.json -H <span class="string">"Content-Type: application/json"</span> http://127.0.0.1:18888/</span><br></pre></td></tr></table></figure>
<p><code>application/x-www-from-urlencoded</code>같은 형식은 http0.9에서 파생되어,<br>
http1.0보다 먼저 표준화된 HTML 2.0의 사양이다.<br>
이는 <code>RFC 1866</code>에서 표준화 되었으며, RFC로 정의된 html은 이게 처음이자 마지막.<br>
<code>RFC 2854</code>의 결정으로 HTML사양 결정은 <code>W3C</code>로 넘어간다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/09/06/http/1_http_1.0_basic_four_feature/" data-id="ckkdb52f700031pqkzoricj7m" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/09/project/travel_note/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">최신</strong>
      <div class="article-nav-title">
        
          travel_note 서비스 고찰
        
      </div>
    </a>
  
  
    <a href="/2019/09/05/python/post/async_coroutine_5/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">이전</strong>
      <div class="article-nav-title">비동기 코루틴 번역-5-End</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/custom-module/">custom module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fabric/">fabric</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/functional-programming/">functional programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-deploy/">hexo-deploy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pipenv/">pipenv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgresql/">postgresql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-module/">python module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-post/">python post</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/testing/">testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travel-note/">travel_note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tutorial/">tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그 클라우드</h3>
    <div class="widget tagcloud">
      <a href="/tags/c/" style="font-size: 11.43px;">c</a> <a href="/tags/custom-module/" style="font-size: 12.86px;">custom module</a> <a href="/tags/django/" style="font-size: 14.29px;">django</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/fabric/" style="font-size: 10px;">fabric</a> <a href="/tags/functional-programming/" style="font-size: 11.43px;">functional programming</a> <a href="/tags/hexo-deploy/" style="font-size: 10px;">hexo-deploy</a> <a href="/tags/http/" style="font-size: 11.43px;">http</a> <a href="/tags/linux/" style="font-size: 15.71px;">linux</a> <a href="/tags/network/" style="font-size: 11.43px;">network</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/pipenv/" style="font-size: 10px;">pipenv</a> <a href="/tags/postgresql/" style="font-size: 10px;">postgresql</a> <a href="/tags/project/" style="font-size: 10px;">project</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/python-module/" style="font-size: 17.14px;">python module</a> <a href="/tags/python-post/" style="font-size: 18.57px;">python post</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/testing/" style="font-size: 10px;">testing</a> <a href="/tags/travel-note/" style="font-size: 10px;">travel_note</a> <a href="/tags/tutorial/" style="font-size: 10px;">tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">아카이브</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">1월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">9월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">8월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">7월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">6월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">5월 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">최근 포스트</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/26/fastcamp/my_post/">test_post</a>
          </li>
        
          <li>
            <a href="/2019/09/17/http/2_http_sementics/">http_1.0_sementics</a>
          </li>
        
          <li>
            <a href="/2019/09/09/project/travel_note/">travel_note 서비스 고찰</a>
          </li>
        
          <li>
            <a href="/2019/09/06/http/1_http_1.0_basic_four_feature/">http/1.0의 신택스: 기본이 되는 네가지 요소</a>
          </li>
        
          <li>
            <a href="/2019/09/05/python/post/async_coroutine_5/">비동기 코루틴 번역-5-End</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 junehan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>