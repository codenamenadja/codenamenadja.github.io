<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>비동기 코루틴 번역-5-End | Junehan&#39;s workbook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="코루틴_정비하기 우리는 어떻게 크롤러가 동작하는지 설명하는 것으로 부터 시작했다. 이제 asyncio 코루틴을 사용해서 구현할 차례이다.  우리 크롤러는 첫 페이지를 fetch한다. 그것의 링크들을 파싱하고, 그것들을 queue에 더할 것이다. 웹사이트를 돌고나면 pages를 동시적으로 fetching할 것이다.  하지만 클라이언트와 서버의 제한된 loa">
<meta name="keywords" content="python,python post">
<meta property="og:type" content="article">
<meta property="og:title" content="비동기 코루틴 번역-5-End">
<meta property="og:url" content="https://codenamenadja.github.io/2019/09/05/python/post/async_coroutine_5/index.html">
<meta property="og:site_name" content="Junehan&#39;s workbook">
<meta property="og:description" content="코루틴_정비하기 우리는 어떻게 크롤러가 동작하는지 설명하는 것으로 부터 시작했다. 이제 asyncio 코루틴을 사용해서 구현할 차례이다.  우리 크롤러는 첫 페이지를 fetch한다. 그것의 링크들을 파싱하고, 그것들을 queue에 더할 것이다. 웹사이트를 돌고나면 pages를 동시적으로 fetching할 것이다.  하지만 클라이언트와 서버의 제한된 loa">
<meta property="og:locale" content="ko">
<meta property="og:updated_time" content="2021-01-25T08:36:06.083Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="비동기 코루틴 번역-5-End">
<meta name="twitter:description" content="코루틴_정비하기 우리는 어떻게 크롤러가 동작하는지 설명하는 것으로 부터 시작했다. 이제 asyncio 코루틴을 사용해서 구현할 차례이다.  우리 크롤러는 첫 페이지를 fetch한다. 그것의 링크들을 파싱하고, 그것들을 queue에 더할 것이다. 웹사이트를 돌고나면 pages를 동시적으로 fetching할 것이다.  하지만 클라이언트와 서버의 제한된 loa">
  
    <link rel="alternate" href="/atom.xml" title="Junehan&#39;s workbook" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junehan&#39;s workbook</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">work flow and descriptions</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="검색"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://codenamenadja.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-python/post/async_coroutine_5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/05/python/post/async_coroutine_5/" class="article-date">
  <time datetime="2019-09-05T09:17:02.000Z" itemprop="datePublished">2019-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      비동기 코루틴 번역-5-End
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="코루틴_정비하기"><a class="markdownIt-Anchor" href="#코루틴_정비하기"></a> 코루틴_정비하기</h2>
<p>우리는 어떻게 크롤러가 동작하는지 설명하는 것으로 부터 시작했다.<br>
이제 asyncio 코루틴을 사용해서 구현할 차례이다.</p>
<ol>
<li>우리 크롤러는 첫 페이지를 fetch한다.</li>
<li>그것의 링크들을 파싱하고,</li>
<li>그것들을 queue에 더할 것이다.</li>
<li>웹사이트를 돌고나면</li>
<li>pages를 동시적으로 fetching할 것이다.
<ul>
<li>하지만 클라이언트와 서버의 제한된 load때문에, 우리를 최대 워커 수를 필요로 한다.</li>
</ul>
</li>
<li>언제든 워커가 페이지를 fetching하는 것이 종료되면, 그 워커는 급히 다음 링크를 queue에서 꺼내야한다.</li>
<li>그리고 더 돌아갈 작업이 없다면, 일부 워커는 멈춰야한다.</li>
<li>하지만 워커가 수많은 링크를 지닌 페이지를 히트한다면,</li>
<li>큐는 급격히 커지고, 멈췄던 워커들은 다시 동작해야한다.</li>
<li>따라서 우리의 프로그램은 모든 일이 끝났을 때만 종료된다.</li>
</ol>
<p>워커가 쓰레드라고 가정해보자, 우리가 크롤러의 알고리즘을 어떻게 표현해야 할까?<br>
우리는 파이썬 표준 라이브러리에서 <strong>Synchronized queue</strong>를 사용할 수 있다. (공유자원 개념?)<br>
아이템이 queue에 들어갈 때마다, queue는 그의 tasks의 count를 증가시킨다.<br>
워커 쓰레드들은 task_done을 개별 아이템이 끝날 때마다 호출한다.<br>
그러면 메인쓰레드가 Queue에 들어간 각아이템이 task_done콜에 의해 매칭될 때까지 Queue.join에서 블록하고, 종료할 것이다.</p>
<p>코루틴은 asyncio queue를 이용한 동일한 패턴을 사용한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> asyncio <span class="keyword">import</span> JoinableQueue <span class="keyword">as</span> Queue</span><br><span class="line"><span class="keyword">except</span> ImportError: <span class="comment"># 파이썬 3.5 버전 이상</span></span><br><span class="line">    <span class="keyword">from</span> asyncio <span class="keyword">import</span> Queue</span><br></pre></td></tr></table></figure>
<p>우리는 워커들의 공유상태를 crwaler class에 모을 것이고, 메인 로직을 그것의 crwal메서드에 작성할 것이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Queue, get_event_loop</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line">loop = get_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crwaler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root_url, max_redirect)</span>:</span></span><br><span class="line">        self.max_tasks = <span class="number">10</span></span><br><span class="line">        self.max_redirect = max_redirect</span><br><span class="line">        self.q = Queue()</span><br><span class="line">        self.seen_urls = set()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># aiohttp의 클라이언트 세션이 connection을 풀링하고,</span></span><br><span class="line">        <span class="comment"># HTTP Keep-alives for us.</span></span><br><span class="line">        self.session = ClientSession(loop=loop)</span><br><span class="line">        self.q.put((root_url, self.max_redirect))</span><br></pre></td></tr></table></figure>
<p>현재 q에서 끝나지 않은 작업은 하나이다. 우리의 메인 스크립트로 돌아가서,<br>
event루프와 crwal메서드를 실행한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl</span><span class="params">(self)</span>:</span></span><br><span class="line">    workers = [Task(self.work()) <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.max_tasks)]</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> self.q.join()</span><br><span class="line">    <span class="keyword">from</span> w <span class="keyword">in</span> workers:</span><br><span class="line">        w.cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    crawler = Crwaler(<span class="string">"http://xkcd.com"</span>, max_redirect=<span class="number">10</span>)</span><br><span class="line">    loop.run_until_complete(crawler.crawl())</span><br></pre></td></tr></table></figure>
<p>만약 워커가 쓰레드 였다면, 우리는 그들이 동시에 실행되는 것을 원하지 않을 것이다.<br>
그들이 특별히 필요로 해지기 전까지 그들이 생성되는 비용을 피하기 위해서,<br>
쓰레드 풀은 대게 필요한 때에만 커질 것이다.</p>
<p>하지만 코루틴은 저렴하다. 그래서 우리는 그들을 간단히 최대 허용 수만큼 시작할 수 있다.</p>
<p>우리가 어떻게 크롤러를 종료시킬 것인지를 아는 것은 중요하다.<br>
join기능이 해결될 때, worker tasks들은, 살아있지만 종료된 상태 일 것이다.:<br>
그들은 더 많은 URL들을 기다리고 있지만 오지 않은 것이다.</p>
<p>따라서 메인 코루틴은 그들을 종료시키기 전에, 취소 시킬것이다.<br>
그렇지 않으면, 파이썬 인터프리터가 종료되고,<br>
모든 PyObject의 <code>destructors</code>를 호출할 때, 살아있는 tasks들은 외칠것이다.</p>
<p><code>ERROR:asyncio:Task was destroyed but it is pending!</code></p>
<p>그러면 어떻게 <code>cancel</code>은 동작하는가?:<br>
제너레이터들은 당신이 모르는 기능을 가지고 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gen = gen_fn()</span><br><span class="line">gen.send(<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">gen.throw(Exception(<span class="string">"error"</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">Exception: error</span></span><br></pre></td></tr></table></figure>
<p>제너레이터들은 <code>throw</code>를 통해서 재진입 되지만, 예외를 발생하고 있다.<br>
만약 제너레이터의 콜스택의 코드에서 그것을 감지하지 못한다면,<br>
exception은 불어나서, 맨 위로 올라올 것이다.<br>
그래서 task의 코루틴을 취소하기 위해서</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>from asycio import Task</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>worker = Task(self.work())</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>worker.cancel()</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># method of Task class</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cancel</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.coro.throw(CacelledError)</span><br></pre></td></tr></table></figure>
<p>어떤 <code>yield from</code>진술들에서 제너레이터가 정지하면, 이것은 재진입하고 예외를 던진다.<br>
우리는 취소를 task의 <code>step</code>메서드를 통해서 핸들링 할 것이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method of Task class</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(self, future)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        next_future = self.coro.send(future.result)</span><br><span class="line">    <span class="keyword">except</span> CancelledError:</span><br><span class="line">        self.cancelled = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    next_future.add_done_callback(self.step)</span><br></pre></td></tr></table></figure>
<p>이제 task는 그것이 최소 되었는지 알 수 있다. 그래서 이것이 소멸될 때, 소리지르지 않을 것이다.<br>
<code>crawl</code>이 한번 워커를 중지 시키면, 그것은 종료한다.<br>
이벤트루프는 그것을 보면 코루틴이 종료되었다고 코루틴이 프로그램이 종료되기를 기다린다고 본다.</p>
<p><code>loop.run_until_complete(crawler.crawl())</code></p>
<p><code>crwal</code>메서드는 모든 메인 코루틴이 해야하는 것을 해낸다.<br>
이것이 queue에서 URL을 가져오고, 그들을 fetch하고, 새로운 링크를 파싱하는 워커 코루틴이다.</p>
<p>각 워커들은 <code>work</code>코루틴을 개별적으로 실행한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crwaler</span>:</span></span><br><span class="line"><span class="meta">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            url, max_redirect = <span class="keyword">yield</span> <span class="keyword">from</span> self.q.get()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># download page and add new links to self.q</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> self.fetch(url, max_redirect)</span><br><span class="line">            self.q.task_done()</span><br></pre></td></tr></table></figure>
<p>파이썬은 이 코드가 <code>yield from</code>진술을 포함하는 것을 보고, 제너레이터 함수로 컴파일 한다.<br>
따라서 <code>crawl</code>안에, 메인 코루틴이 <code>self.work</code>를 10번 호출할 때,<br>
이것은 실제로 이 함수를 호출 하지 않는다.</p>
<p>그것은 오직 이 코드블록을 바라보는 10개의 제너레이터 객체를 생성할 것이다.</p>
<p>이것은 개별 Task안에 래핑되고, Task는 개별적인 future 제너레이터가 yield하는 것을 받는다.<br>
그리고 <strong>future가 resolve될 때,</strong> 제너레이터를 <code>send</code>에 개별적인 future의 result를 매개변수로 콜하면서 진행할 것이다.<br>
왜냐하면 제너레이터는 개별적인 스텍프레임을 가지고 있고,<br>
개별적으로 동작하고, 개별적인 지역변수와 인스트럭션 포인터를 가졌기 때문이다.</p>
<p>워커는 queue를 통해서 그의 친구들과 정렬된다. 그것은 아래처럼 새로운 URL을 기다릴 것이다.</p>
<p><code>url, max_redirect = yield from self.q.get()</code></p>
<p>queue의 get메서드는 그 자체로 코루틴이다.: 그것은 누군가 queue에 item을 넣을때 까지 정지하고,<br>
이후 돌아와서 들어온 아이템을 리턴한다.</p>
<p>우연히 아곳은 워커가 crwal의 끝부분에서 메인 코루틴이 그것을 중지할때 멈추는 부분이다.<br>
코루틴의 관점에서 보았을 때, 이 루프의 마지막 실행은 <code>yield from</code> 이 <code>CancelledError</code>을 raise할때 일어난다.</p>
<p>워커가 페이지에서 링크들을 파싱하고, 새로운 링크를 큐에 집어 넣을 때, <code>task_done</code>을 통해 counter를 줄인다.<br>
결국 워커는 워커가 모든 URL들이 fetched된 페이지를 fetch하면, 큐에는 더이상 할 일이 남아있지 않다.<br>
그러므로 이 워커가 <code>task_done</code>을 호출하는 것은 카운터를 0으로 줄인다.<br>
그러면 queue의 <code>join</code>메서드를 기다리고 있는 <code>crawl</code>은 다시 재개되고, 마무리한다.</p>
<p><code>aiohttp</code> 패키지는 기본적으로 redirects를 따르고, 우리에게 최종 response를 가져다 준다.<br>
우리가 구분할 수 있건없건, redirects를 크롤러 내에서 핸들링 하고,<br>
결국 이것은 모든 한 목적지로 가는 redirect path들을 coalesce할 수 있다.:</p>
<ul>
<li>COALESCE: SQL함수로, NULL이 아닌 첫 값을 반환하는 기능<br>
만약 해당 URL을 이미 보았다면, 이것은 <code>self.seen_urls</code>에 있을 것이고,<br>
우리는 이미 이 path에 대해새 다른 엔트리 포인트에서 시도해본적 있는 것이다.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">first entry point</th>
<th style="text-align:center">redirects</th>
<th style="text-align:center">destination</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/foo</td>
<td style="text-align:center">/baz</td>
<td style="text-align:center">/quux</td>
</tr>
<tr>
<td style="text-align:center">/bar</td>
<td style="text-align:center">/baz</td>
<td style="text-align:center">/quux</td>
</tr>
</tbody>
</table>
<ol>
<li>/foo에 접근한 워커가 baz를 리디렉트하고, quux로 진행하였다면, baz를 <code>seen_urls</code>로 이동시킨다.</li>
<li>/bar에 접근한 워커가, baz로 리디렉트 한다는 것을 알면, Fetcher은 baz를 이미 <code>seen_urls</code>에 있는 것으로 감안하여 enqueue하지 않는다.</li>
<li>만약 응답이 리디렉션이 아니라 페이지문서였다면, <code>fetch</code>는 이것의 링크를 파싱하고, 새로울 것을 enqueue한다.</li>
</ol>
<blockquote>
<p>STATUS CODE 301 Moved Permanently</p>
<p>301의 HTTP응답은 location헤더가 포함되는 것이 일반적인데,<br>
location헤더에 해당 엔드포인트의 새로운 주소가 포함되어 나온다.<br>
클라이언트는 location헤더의 엔트포인트의 새로운 주소에 해당 요청을 다시 보내게 된다.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Location: http://www.example.org/index.asp</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span></span><br><span class="line"><span class="meta">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(self, url, max_redirect)</span>:</span></span><br><span class="line">        response = <span class="keyword">yield</span> <span class="keyword">from</span> self.session.get(</span><br><span class="line">            url, allow_redirects = <span class="literal">False</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> is_redirect(response):</span><br><span class="line">                <span class="keyword">if</span> max_redirect &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># response가 최초 리디렉션 301 MOVED PERMANENTLY 일때,</span></span><br><span class="line">                    next_url = response.headers[<span class="string">"location"</span>]</span><br><span class="line">                    <span class="comment"># header에 일반적으로 포함되는 location헤더.</span></span><br><span class="line">                    <span class="keyword">if</span> next_url <span class="keyword">in</span> self.seen_urls:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    self.q.put_nowait((next_url, max_redirect - <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                links = <span class="keyword">yield</span> <span class="keyword">from</span> self.parse_links(response)</span><br><span class="line">                <span class="keyword">for</span> link <span class="keyword">in</span> links.difference(self.seen_urls):</span><br><span class="line">                    self.q.put_nowait((link, self.max_redirect))</span><br><span class="line">                self.seen_urls.update(links)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> response.release()</span><br></pre></td></tr></table></figure>
<p>만약 이게 멀티스레딩 코드 였다면, race컨디션이 넘쳐났을 것이다.<br>
예를 들어, 워커가 fetch한 링크가 seen_urls에 있는지 확인하려 한다면,<br>
그리고 그 워커가 그것을 queue에 넣고 seen_urls로 더하지 않는다면.</p>
<p>만약 이것이 다른 두 operation에 사이에서 interrupt되었다면, 다른 워커들은,<br>
같은 링크를 다른페이지에서 파싱할 것이고, 또한 그것이 <code>seen_urls</code>에 존재하지 않는다고 볼 것이다.<br>
그리고 그것을 Queue에 더할 것이다.<br>
그러면 동일한 링크가 Queue에 두번 있는 것이고, 중복된 일과 잘못된 통계를 수집할 것이다.</p>
<p>그러나 코루틴은 오직 <code>yield from</code> 인터럽션에만 취약하다.<br>
이것이 코루틴 코드를 races에 멀티스레딩 코드보다 덜 발생하도록 만드는 주요 차이점이다.:<br>
멀티스레딩 코드는 lock을 취득하는 것을 통해서 명시적으로 공유자원에 접근해야한다. 그렇지 않으면 방해 받을 수 있다.<br>
파이썬 코루틴은 기본적으로 방해 받지 않으며, 명시적으로 <code>yield</code> 할때만, 컨트롤을 양보한다.</p>
<p>우리는 우리가 Callback기반 프로그램에서 그랬던 것처럼 fetcher클래스가 필요하지 않다.<br>
그 클래스는 콜백이 결여된 것이었다.:<br>
그들의 지역변수가 call들 사이에서 유지되지 않았기 때문에, 그들은 I\O를 기다리는 동안 상태를 저장할 장소가 필요하다.</p>
<p>그러나 <code>fetch</code>코루틴은 그것의 상태를 일반적인 서브루틴처럼 저장할 수 있기 때문에, class는 더이상 필요하지 않다.</p>
<p><code>fetch</code>가 <code>work</code>콜러에게 response를 돌려주는 마무리를 할 때,<br>
<code>work</code>메서드는 <code>task_done</code>을 queue에서 호출하여, 다음 URL을 queue에서 가져온다.</p>
<p><code>fetch</code>가 새로운 링크를 큐에 넣을 때, 완료되지 않은 tasks의 count를 증가시키고, <code>q.join</code>을 기다리고 있는 메인 코루틴을 정지된 상태로 유지 시킨다.<br>
그러나, 거기에 unseen링크가 없고, 그것이 queue에서 마지막 URL이었을 때,<br>
<code>work</code>는 <code>task_done</code>을 호출하고, 완료되지 않은 tasks의 count는 0으로 떨어진다.<br>
이벤트는 <code>join</code>을 재개시키고, 메인 코루틴은 종료된다.</p>
<p>워커들과 메인 코루틴은 정렬하는 Queue코드는 아래와 같다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._join_future = Future()</span><br><span class="line">        self._unfinished_tasks = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put_nowait</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self._unfinished_tasks = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">task_done</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._unfinished_tasks -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> !(self._unfinished_tasks):</span><br><span class="line">            self._join_future.set_result(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._unfinished_tasks:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> self._join_future</span><br></pre></td></tr></table></figure>
<p>메인 코루틴, crawl은 <code>join</code>에서 <code>yield from</code>된다.<br>
따라서 마지막 워커가 unfinished_tasks를 0으로 처리하면, 예약한 시그널이 발생해서 crawl로 재진입하고, 종료한다.</p>
<p><code>loop.run_until_complete(self.crawler.crawl())</code></p>
<p>어떻게 프로그램이 종료 되는가? <code>crawl</code>이 제너레이터 함수 이기 때문에, 이것을 호출하는 것은 제너레이터를 리턴한다.<br>
제너레이터를 진행시키기 위해서, asyncio는 이것을 task안에 래핑한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopError</span><span class="params">(BaseException)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop_callback</span><span class="params">(future)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> StopError</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(self, coro)</span>:</span></span><br><span class="line">        task = Task(coro)</span><br><span class="line">        task.add_done_callback(stop_callback)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run_forever()</span><br><span class="line">        <span class="keyword">except</span> StopError:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>Task가 종료될 떄, 그것을 StopError을 raise하고, 루프는 그것을 시그널로 간주한다.</p>
<p>그러면 이것은 무엇인가? Task는 <code>add_done_callback</code>과 <code>result</code>라 불리는 메서드가 있다?<br>
당신은 task가 future를 닮았다고 생각할 수 있다. 당신의 직감을 옳다.<br>
우리는 당신에게 숨긴 Task class에 대한 세부 디테일을 가져와야 한다. task는 future이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">(Future)</span>:</span></span><br><span class="line">    <span class="string">"""A coroutine wrapped in a Future."""</span></span><br></pre></td></tr></table></figure>
<p>일반적으로 future은 누군가가 set_result를 할때 해제된다.<br>
그러나 task는 그것의 코루틴이 멈출 때, 자신을 해제시킨다.<br>
generator가 값을 리턴할 때, 그것을 특별한 <code>StopIteration</code>예외를 발생시켰던 것을 기억하라.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">(Future)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, coro)</span>:</span></span><br><span class="line">        self.coro = coro</span><br><span class="line">        f = Future()</span><br><span class="line">        f.set_result(<span class="literal">None</span>)</span><br><span class="line">        self.step(f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(self, future)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            next_future = self.coro.send(future.result)</span><br><span class="line">        <span class="keyword">except</span> CancelledError:</span><br><span class="line">            self.cancelled =<span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line">            self.set_result(exc.value)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        next_future.add_done_callback(self.step)</span><br></pre></td></tr></table></figure>
<p>따라서 이벤트 루프가 <code>task.add_done_callback(stop_callback)</code>을 호출할 때,<br>
콜백은 <code>StopError</code>를 루프내에서 발생시킨다.<br>
루프는 멈추고 콜 스택은, <code>run_util_complete</code>로 복귀(Unwound to)한다.<br>
우리 프로그램은 종료 되었다.</p>
<h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2>
<p>꽤 자주, 현대적인 프로그램은 CPU-bound하기 보다 I/O-bound한 일이 잦다.<br>
그러한 프로그램에서 파이썬의 쓰레드들은, 두 곳에서 전부 최악의 경우이다.:<br>
GIL에 의해서 락을 가진 쓰레드만을 인터프리터가 실행하기 때문에, 병행-컴퓨팅을 방지하고,<br>
선점형 스위칭은 레이스컨디션을 매우 줄여버린다.<br>
Async는 가끔 정답인 패턴이다. 하지만 콜백기반 비동기 코드가 커질수록, 이것은 종잡을 수 없이 난잡해지는 경항이 있다.<br>
코루틴들은 쌍당한 대처법이라 할 수 있다.<br>
그들은 자신들을 제대로 된 에러 핸들링과, 스택트레이싱을 통해서, 서브코루틴으로 자연스럽게 구성해낸다.</p>
<p>우리가 <code>yield from</code>문을 슬쩍 애매하게 본다면, 코루틴은 마치 기존의 blocking-io인 쓰레드가 하는 것처럼 보인다.<br>
우리는 멀티쓰레딩-프로그래밍처럼 코루틴들을 정렬해서, 고전적인 패턴처럼 보이게 할 수도 있다.<br>
그러므로, 콜백들에 비교해서 코루틴은 멀티쓰레딩으로 익숙한 코더들에게 익숙한 관용구이다.</p>
<p>그러나 우리가, <code>yield from</code>문을 제대로 인식하려 할 때,<br>
우리는 코루틴이 실행 컨텍스트를 넘겨주는 시기 같이, 유심히 체크해야할 포인트 들이 있다.<br>
쓰레드와 달리 코루틴들은 우리의 코드를 interrupted될 수 있는 것으로 보여준다.<br>
Glyph Lefkowitz가 적었듯이,</p>
<blockquote>
<p>“쓰레드들은 지역적인 추리를 어렵게 한다. 그리고 지역적인 이해는 소프트웨어 개발에서 가장 중요한 것중 하나이다.”</p>
</blockquote>
<p>명시적으로 <code>yielding</code>하는 것은 반면에 모든 시스템을 시험하는 것이 아닌 루틴으로써,<br>
루틴을 시험하는 것으로 루틴의 행동을 이해할 수 있도록 한다.</p>
<p>(중략…간편하게 사용할 수 있는 인터페이스가 버전업이 되면서 제공되었다 라는 등의 이야기, <code>async def</code>, <code>await</code>)</p>
<p>이런 발전들에 불구하고, 기존의 코어 개념은 그대로 있다. 파이썬의 새로운 내장 코루틴들은,<br>
통상적으로, 제너레이터와 구분되지만, 매우 유사하게 동작한다.<br>
게다가, 그들은 파이썬 인터프리터 내에서, 그 실행부를 공유한다.<br>
<code>Task</code>, <code>Future</code>, <code>event loop</code>같은 것들은 <code>asyncio</code>에서 계속 그들의 역할을 맞을 것이다.</p>
<p>이제 당신은 어떻게 <code>asyncio</code> 코루틴이 동작하는지 알았으니, 세부적인 것은 조금 잊어도 좋다.<br>
기계공은 매끈한 인터페이스 뒤에 dlTek.<br>
그러나 당신이 구조를 이해한다면, 너의 코드를 요즘 비동기 환경에서 더욱 효과적이고 올바르게 강화해줄 것이다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/09/05/python/post/async_coroutine_5/" data-id="ckkdb52hl002h1pqkbnrjllsr" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/06/http/1_http_1.0_basic_four_feature/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">최신</strong>
      <div class="article-nav-title">
        
          http/1.0의 신택스: 기본이 되는 네가지 요소
        
      </div>
    </a>
  
  
    <a href="/2019/08/30/python/post/pointer_in_python/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">이전</strong>
      <div class="article-nav-title">pointer in python 번역</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/custom-module/">custom module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fabric/">fabric</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/functional-programming/">functional programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-deploy/">hexo-deploy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pipenv/">pipenv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgresql/">postgresql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-module/">python module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-post/">python post</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/testing/">testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travel-note/">travel_note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tutorial/">tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그 클라우드</h3>
    <div class="widget tagcloud">
      <a href="/tags/c/" style="font-size: 11.43px;">c</a> <a href="/tags/custom-module/" style="font-size: 12.86px;">custom module</a> <a href="/tags/django/" style="font-size: 14.29px;">django</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/fabric/" style="font-size: 10px;">fabric</a> <a href="/tags/functional-programming/" style="font-size: 11.43px;">functional programming</a> <a href="/tags/hexo-deploy/" style="font-size: 10px;">hexo-deploy</a> <a href="/tags/http/" style="font-size: 11.43px;">http</a> <a href="/tags/linux/" style="font-size: 15.71px;">linux</a> <a href="/tags/network/" style="font-size: 11.43px;">network</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/pipenv/" style="font-size: 10px;">pipenv</a> <a href="/tags/postgresql/" style="font-size: 10px;">postgresql</a> <a href="/tags/project/" style="font-size: 10px;">project</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/python-module/" style="font-size: 17.14px;">python module</a> <a href="/tags/python-post/" style="font-size: 18.57px;">python post</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/testing/" style="font-size: 10px;">testing</a> <a href="/tags/travel-note/" style="font-size: 10px;">travel_note</a> <a href="/tags/tutorial/" style="font-size: 10px;">tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">아카이브</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">1월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">9월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">8월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">7월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">6월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">5월 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">최근 포스트</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/26/fastcamp/my_post/">test_post</a>
          </li>
        
          <li>
            <a href="/2019/09/17/http/2_http_sementics/">http_1.0_sementics</a>
          </li>
        
          <li>
            <a href="/2019/09/09/project/travel_note/">travel_note 서비스 고찰</a>
          </li>
        
          <li>
            <a href="/2019/09/06/http/1_http_1.0_basic_four_feature/">http/1.0의 신택스: 기본이 되는 네가지 요소</a>
          </li>
        
          <li>
            <a href="/2019/09/05/python/post/async_coroutine_5/">비동기 코루틴 번역-5-End</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 junehan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>