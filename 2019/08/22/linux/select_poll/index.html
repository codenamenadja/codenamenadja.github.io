<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>multiple io, select() and poll() | Junehan&#39;s workbook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="index  다중 입출력 select poll poll vs select epoll    다중_입출력 종종 키보드입력(stdin)과 IPC, 그리고 여러 파일 사이에서 일어나는 입출력을 처리하면서, 하나 이상의 파일디스크립터를 블록할 필요가 있다. 다중 입출력은 어플리케이션이 여러개의 파일 디스크립터를 동시에 블록하고, 그 중 하나라도 블록되지 않고, 읽">
<meta name="keywords" content="linux">
<meta property="og:type" content="article">
<meta property="og:title" content="multiple io, select() and poll()">
<meta property="og:url" content="https://codenamenadja.github.io/2019/08/22/linux/select_poll/index.html">
<meta property="og:site_name" content="Junehan&#39;s workbook">
<meta property="og:description" content="index  다중 입출력 select poll poll vs select epoll    다중_입출력 종종 키보드입력(stdin)과 IPC, 그리고 여러 파일 사이에서 일어나는 입출력을 처리하면서, 하나 이상의 파일디스크립터를 블록할 필요가 있다. 다중 입출력은 어플리케이션이 여러개의 파일 디스크립터를 동시에 블록하고, 그 중 하나라도 블록되지 않고, 읽">
<meta property="og:locale" content="ko">
<meta property="og:updated_time" content="2021-01-25T08:36:06.079Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="multiple io, select() and poll()">
<meta name="twitter:description" content="index  다중 입출력 select poll poll vs select epoll    다중_입출력 종종 키보드입력(stdin)과 IPC, 그리고 여러 파일 사이에서 일어나는 입출력을 처리하면서, 하나 이상의 파일디스크립터를 블록할 필요가 있다. 다중 입출력은 어플리케이션이 여러개의 파일 디스크립터를 동시에 블록하고, 그 중 하나라도 블록되지 않고, 읽">
  
    <link rel="alternate" href="/atom.xml" title="Junehan&#39;s workbook" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junehan&#39;s workbook</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">work flow and descriptions</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="검색"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://codenamenadja.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-linux/select_poll" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/22/linux/select_poll/" class="article-date">
  <time datetime="2019-08-22T06:27:08.000Z" itemprop="datePublished">2019-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      multiple io, select() and poll()
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> index</h2>
<ol>
<li><a href="#%EB%8B%A4%EC%A4%91_%EC%9E%85%EC%B6%9C%EB%A0%A5"><strong>다중 입출력</strong></a></li>
<li><a href="#select"><strong>select</strong></a></li>
<li><a href="#poll"><strong>poll</strong></a></li>
<li><a href="#poll%EA%B3%BC_select%EB%B9%84%EA%B5%90"><strong>poll vs select</strong></a></li>
<li><a href="#epoll"><strong>epoll</strong></a></li>
</ol>
<hr>
<h2 id="다중_입출력"><a class="markdownIt-Anchor" href="#다중_입출력"></a> 다중_입출력</h2>
<p>종종 키보드입력(stdin)과 IPC, 그리고 여러 파일 사이에서 일어나는 입출력을 처리하면서, 하나 이상의 파일디스크립터를 블록할 필요가 있다.</p>
<p>다중 입출력은 어플리케이션이 여러개의 파일 디스크립터를 동시에 블록하고,<br>
그 중 하나라도 블록되지 않고, 읽고 쓸 준비가 되면, 알려주는 기능을 제공한다.<br>
따라서 다음과 같은 설계방식을 따르는 어플리케이션을 위한 중심점이 된다.</p>
<ol>
<li>다중 입출력: 파일디스크립터중 하나가 입출력이 가능할때, 알려준다.</li>
<li>준비가 됐나? 준비된 파일 디스크립터가 없다면, 하나 이상의 파일 디스크립터가 준비될 때까지 잠든다.</li>
<li>꺠어나기. 어떤 파일 디스크립터가 준비됐나?</li>
<li>블록하지 않고, 모든 파일 디스크립터가 입출력을 준비하도록 관리한다.</li>
<li>1 로 돌아가서 다시 시작한다.</li>
</ol>
<p>리눅스는 <code>select, poll, epoll</code>인터페이스 라는 세가지를 제공한다.</p>
<h2 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *execptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line">FD_ZERO(fd_set *<span class="built_in">set</span>);</span><br></pre></td></tr></table></figure>
<p><code>select()</code>호출은 파일 디스크립터가 입출력을 수행할 준비가 되거나 옵션으로 정해진 시간이 경과할 때 까지만 블록된다.</p>
<p>감시 대상 파일 디스크립터는 세가지 집합으로 나뉘어 각각 다른 이벤트를 기다린다.</p>
<ul>
<li><code>readfds</code>: 블록되지 않고 데이터 읽기가 가능한지 (데이터가 없으면 block, read()작업이 가능한지) 감시한다.</li>
<li><code>wrtiefds</code>: 블록되지 않고 <code>write()</code>가 가능한지 감시한다.</li>
<li><code>exceptfds</code>: 예외가 발생했거나, 대역을 넘어서는 데이터(소켓에만 적용)가 존재하는지 감시.</li>
</ul>
<p>호출이 성공하면, 각 집합은 요청받은 입출력 유형을 대상으로 입출력이 준비된 파일 디스크립터만 포함되도록 변경된다.<br>
예를 들어 7, 9두개의 파일디스크립터가 <code>readfds</code>에 들어있다고 한다면 호출이 반환될 때, 7이 집합에 남아있을 경우,<br>
7번은 블록없이 읽기가 가능하다.</p>
<p>첫번째 인자인 n은 파일 디스크립터 집합에서 가장 큰 파일 디스크립터 숫자에 1을 더한 값이다.<br>
따라서 select()를 호출하려면 파일 디스크립터에서 가장 큰 값이 무엇인지 알아내서 이 값에 1을 더해 첫 인자에 넘겨야 한다.<br>
<code>timeout</code> 인자는 <code>timeval구조체</code>를 가르키는 포인터이며 이 구조체는 다음과 같이 정의되어 있다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec; <span class="comment">// 초</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec; <span class="comment">// 마이크로 초</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 인자가 NULL이 아니면 select()호출은 입력이 준비된 파일 디스크립터가 없을 경우에도 tv_sec초와 tv_usec 마이크로 초 이후에 반환된다.</p>
<p>고전적인 유닉스 시스템에서는 select()호출이 반환된 다음에 이 구조체가 정의되지 않은 상태로 남아 있으므로, 매번 호출전에<br>
파일 디스트립터 집합과 더불어 다시 초기화를 해줘야 한다. 실제로 최근 리눅스 버전은 이 인자를 자동으로 수정해서 남아있는 시각으로 값을 설정한다.</p>
<p>따라서 Timeout이 5초고 파일 디스트립터가 준비되기 까지 3초가 경과했다면, <code>tv.tv_sec</code>은 반환될때 2를 담고 있을 것이다.<br>
timeout에 설정된 두 값이 모두 0이면, 호출은 즉시 반환되며 호출하는 시점에서 대기중인 이벤트를 알려주지만, 그 다음 이벤트를 기다리지 않는다.</p>
<p><code>select</code>에서 사용하는 fds(집합)은 직접 조작하지 않고 매크로를 사용해서 관리한다.</p>
<p>대다수의 시스템에서는 fds를 비트 배열처럼 간단한 방식으로 구현하고 있다.</p>
<h3 id="매크로"><a class="markdownIt-Anchor" href="#매크로"></a> 매크로</h3>
<ul>
<li>FD_ZERO: <code>FD_ZERO(&amp;writefds);</code><br>
FD_ZERO는 지정한 집합내 모든 파일 디스크립터를 제거한다. 이 매크로는 항상 select()를 호출하기 전에 사용해야 한다.</li>
<li>FD_SET: <code>FD_SET(fd, &amp;writefds);</code><br>
주어진 집합에 파일 디스크립터를 추가한다.</li>
<li>FD_CLR: <code>FD_CLR(fd, &amp;writefds);</code><br>
주어진 집합에서 파일디스크립터 하나를 제거한다.</li>
<li>FD_ISSET: <code>FD_ISSET(fd, &amp;readfds);</code><br>
주어진 집합에 파일디스크립터가 존재하는지 확인한다. 존재하면 0이 아닌 정수를 반환한다.<br>
<code>select()</code>호출이 반환된 다음에 파일디스크립터가 입출력이 가능한 상태인지 확인하기 위해 사용된다.</li>
</ul>
<h3 id="예제"><a class="markdownIt-Anchor" href="#예제"></a> 예제</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMEOUT 5</span></span><br><span class="line"><span class="comment">// 타입 아웃 초</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN 1024</span></span><br><span class="line"><span class="comment">// 읽기 버퍼 크기</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 표준 입력에서 입력을 기다리기 위한 준비</span></span><br><span class="line">    FD_ZERO(&amp;readfds); <span class="comment">// select 호출 전 반드시 사용 해줘야.</span></span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;readfds); <span class="comment">// IN은 데이터가 들어오면 읽을 수 있는 FD</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// select가 5초 동안 기다리도록 timeval구조체 설정</span></span><br><span class="line">    tv.tv_sec = TIMEOUT;</span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 입력 대기 시작</span></span><br><span class="line">    ret = select(STDIN_FILENO + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">    <span class="comment">//  Readable한 STDIN_FILENO에 대해서 대기, 감시하는 select 선언</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"select"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d seconds elapesd.\n"</span>, TIMEOUT);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 이 아래부터는 select가 0이 아닌 양수를 반환했다는 의미</span></span><br><span class="line">    <span class="comment">// 대기중인 집합 중 하나라도 돌아왔다</span></span><br><span class="line">    <span class="comment">// 그것을 FD_ISSET으로 선별해서, 그것을 READ혹은 WRITE한다.</span></span><br><span class="line">    <span class="comment">// 바로 실행할 수 있으니 빠르게 블록되고 해제된다.</span></span><br><span class="line">    <span class="comment">// 그 전까지는 FD를 감시하며 LOOPING하는 쓰레드가 동작</span></span><br><span class="line">    <span class="comment">// 파일 디스크립터에서 즉시 읽기가 가능하다.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;readfds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUF_LEN + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read not block</span></span><br><span class="line">        len = read(STDIN_FILENO, buf, BUF_LEN);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"READ"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read %s\n"</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This should not happen!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poll"><a class="markdownIt-Anchor" href="#poll"></a> POLL</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">// 파일 디스크립터</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">// 대기 이벤트</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">// 발생이벤트</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>비트마스크 기반의 세가지 파일디스크립터 집합을 사용하는 <code>Select</code>와 달리,<br>
<code>poll</code>은 fds가 가리키는 단일 pollfd구조체 배열을 nfds개수 만큼 사용한다.</p>
<p>각 구조체의 <code>events</code>필드는, 그 파일 디스크립터에서 감시할 이벤트의 비트마스크 이다.</p>
<p>설정 가능한 이벤트는 아래와 같다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:left">desc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">POLLIN</td>
<td style="text-align:left">읽을 데이터가 존재</td>
</tr>
<tr>
<td style="text-align:center">POLLRDNORM</td>
<td style="text-align:left">일반 데이터를 읽을 수 있다.</td>
</tr>
<tr>
<td style="text-align:center">POLLRDBAND</td>
<td style="text-align:left">우선권이 있는 데이터를 읽을 수 있다.</td>
</tr>
<tr>
<td style="text-align:center">POLLPRI</td>
<td style="text-align:left">시급히 읽을 데이터가 존재한다.</td>
</tr>
<tr>
<td style="text-align:center">POLLOUT</td>
<td style="text-align:left">쓰기가 블록되지 않을 것이다.</td>
</tr>
<tr>
<td style="text-align:center">POLLWRNORM</td>
<td style="text-align:left">일반 데이터 쓰기가 블록되지 않을 것이다.</td>
</tr>
<tr>
<td style="text-align:center">POLLWRBAND</td>
<td style="text-align:left">우선권이 있는 데이터쓰기가 블록되지 않을 것이다.</td>
</tr>
<tr>
<td style="text-align:center">POLLMSG</td>
<td style="text-align:left">SIGPOLL메세지가 사용가능하다.</td>
</tr>
</tbody>
</table>
<p>그리고 <code>revents</code>필드에는 아래 이벤트가 추가로 설정될 수 있다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:left">desc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">POLLER</td>
<td style="text-align:left">주어진 파일 디스크립터에 에러가 있다.</td>
</tr>
<tr>
<td style="text-align:center">POLLHUP</td>
<td style="text-align:left">주어진 파일 디스크립터에서 이벤트가 지체되고 있다.</td>
</tr>
<tr>
<td style="text-align:center">POLLNVAL</td>
<td style="text-align:left">주어진 파일 디스크립터가 유효하지 않다.</td>
</tr>
</tbody>
</table>
<p>예를 들어 FD에서 읽가와 쓰기를 감시하려면, events를 <code>POLLIN | POLLOUT</code>으로 설정한다.<br>
호출이 반환되면, <code>pollfd</code>구조체 배열에서 원하는 파일 디스크립터가 들어있는 항목을 찾아<br>
<code>revents</code>에 해당 플래그가 켜져있는지 확인한다.</p>
<h3 id="반환과-에러코드"><a class="markdownIt-Anchor" href="#반환과-에러코드"></a> 반환과 에러코드</h3>
<p><code>poll()</code>호출이 성공하면, <code>revents</code>필드가 0이 아닌 구조체의 개수를 반환한다.<br>
이벤트가 발생하기 전에 타입아웃이 발생한다면 0을 반환한다.<br>
에러가 발생하면 -1을 반환하며, errno를 아래중 하나로 설정한다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:left">desc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">EBADF</td>
<td style="text-align:left">주어진 구조체의 파일디스크립터가 유효하지 않다.</td>
</tr>
<tr>
<td style="text-align:center">EFAULT</td>
<td style="text-align:left">fds를 가리키는 포인터가 프로세스 주소공간을 벗어난다.</td>
</tr>
<tr>
<td style="text-align:center">EINTR</td>
<td style="text-align:left">이벤트를 기다리는중 시그널이 발생했다. 다시 호출이 필요하다.</td>
</tr>
<tr>
<td style="text-align:center">EINVAL</td>
<td style="text-align:left">nfds인자가 RLIMIT_NOFILE값을 초과했다.</td>
</tr>
<tr>
<td style="text-align:center">ENOMEM</td>
<td style="text-align:left">요청을 완료하기위한 메모리가 부족하다.</td>
</tr>
</tbody>
</table>
<h3 id="예시"><a class="markdownIt-Anchor" href="#예시"></a> 예시</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMEOUT 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 표준 입력에 대한 이벤트 감지를 위한 세팅</span></span><br><span class="line">    fds[<span class="number">0</span>].fd = STDIN_FILENO;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 표준 출력에 쓰기가 가능한지 감지하기 위한 준비</span></span><br><span class="line">    fds[<span class="number">1</span>].fd = STDOUT_FILENO;</span><br><span class="line">    fds[<span class="number">1</span>].events = POLLOUT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 블록 시작</span></span><br><span class="line">    ret = poll(fds, <span class="number">2</span>, TIMEOUT * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"poll"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d seconds elapsed.\n"</span>, TIMEOUT);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stdin is readable\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stdout is writable\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poll과_select비교"><a class="markdownIt-Anchor" href="#poll과_select비교"></a> POLL과_SELECT비교</h2>
<ul>
<li><code>poll()</code>은 가장 높은 파일디스크립터 값에 1을 더해서 인자로 전달할 필요가 없다.</li>
<li><code>poll()</code>은 파일 디스크립터 숫자가 큰 경우에 좀 더 효율적을 동작한다.<br>
<code>select()</code>로 값이 900인 단일파일 디스크립터를 감시한다고 할 때,<br>
커널은 매번 전달된 파일디스크립터 집합에서 900번째 비트까지 일일이 검사해야한다.</li>
<li><code>select()</code>의 파일 디스크립터 집합은 크기가 정해져 있으므로, trade-off 발생.<br>
집합은 크기가 작으면, <code>select()</code>가 감시할 최대 디스크립터 개수를 제약하며, 집합의 크기가 크면 비효율적이다.<br>
큰 비트마스크에 대한 연산은 비효율적이며, 파일 디스크립터가 연속적이지 않을경우 특히 심각하다.<br>
<code>poll()</code>을 사용하면, 딱 맞는 키기의 배열 하나만 사용하면 된다.</li>
<li><code>select()</code>를 사용하면, 디스크립터 집합을 반환하는 시점에 재구성되므로<br>
잇다라 호출하게 되면, 파일디스크립터 집합 재초기화 필요함.<br>
<code>poll()</code>시스템 콜은 입력과 출력을 분리하므로, 변경없이 배열을 재사용 가능하다.</li>
<li><code>select()</code>의 timeout반환하게 되면 미정의 상태가 된다.<br>
따라서 코드의 이식성을 높이려면, timeout인자를 재초기화 해야한다.<br>
<code>pselect()</code>를 사용할 경우에는 이런 문제가 없다.</li>
</ul>
<p>select()시스템 콜에도 몇가지 장점이 있다.</p>
<ul>
<li><code>select()</code>는 상대적으로 이식성이 높아 거의 모든 유닉스에서 지원한다.</li>
<li><code>select()</code>는 타입아웃 값으로 마이크로초까지 지정할 수 있다. <code>poll()</code>은 milie-sec단위로 지정할 수 있다.</li>
</ul>
<blockquote>
<p><code>epoll()</code>은 <code>poll</code> <code>select</code>보다 훨씬 뛰어난 리눅스 입출력 멀티플렉싱 인터페이스이다. 추후에 정리한다.</p>
</blockquote>
<hr>
<h2 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h2>
<p><code>poll</code>과 <code>select</code>는 실행할 때 마다, 전체 파일 디스크립터를 요구한다.  그러면 커널은 검사해야할 파일 리스트를 다 살펴본다.p</p>
<h3 id="epoll_사용법"><a class="markdownIt-Anchor" href="#epoll_사용법"></a> epoll_사용법</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> epfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(epfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">"epoll_create1);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>epoll_create1()</code>에서 반환하는 fd는 폴링이 끝난뒤 반드시 <code>close()</code>해줘야 한다.  에러 발생시,</p>
<ul>
<li>EINVAL: 잘못된 flags인자</li>
<li>EMFILE: 사용자가 열 수 있는 최대 파일 초과</li>
<li>ENFILE: 시스템에서 열 수 있는 최대파일을 초과</li>
<li>ENOMEM: 작업을 수행하기 위한 메모리 부족</li>
</ul>
<p>-1 을 반환하고 errno를 위 중 하나로 설정한다.</p>
<hr>
<h3 id="epoll_create에서-epoll_create1으로"><a class="markdownIt-Anchor" href="#epoll_create에서-epoll_create1으로"></a> epoll_create에서 epoll_create1으로</h3>
<p><code>epoll_create()</code>는 구식 메서드며, epoll_create1()으로 대체됐다.<br>
epoll_create()는 아무런 인자를 받지 않으며 그대신 size인자를 받는데, 이는 사용되지 않음.</p>
<p>size는 감시할 파일 디스크립터 개수에 대한 힌트로 사용되는데,  <strong>최신 커널에서는 동적으로 요청된 자료구조로 크기를 정하며, 이 인자는 단지 0보다 크기만 하면 된다.</strong></p>
<p>만약에 size값이 0이거나 0보다 작다면 <code>EINVAL</code>을 반환한다.</p>
<hr>
<h3 id="epoll_제어"><a class="markdownIt-Anchor" href="#epoll_제어"></a> epoll_제어</h3>
<p><code>epoll_ctl()</code>시스템 콜은 주어진 epoll컨텍스트에 파일 디스크립터를 추가하거나 삭제할 때 사용한다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys/epoll.h에 정의된 epoll_event 구조체.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">    __u32 events; <span class="comment">// events</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *ptr;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        __u32 u32;</span><br><span class="line">        __u64 u64;</span><br><span class="line">    &#125;</span><br><span class="line">    data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>epoll_ctl()</code>호출이 성공하면 해당 epoll인스턴스는 <code>epfd</code>파일 디스크립터와 연결된다.<br>
op인자는 fd가 가리키는 파일에 대한 작업을 명시한다.</p>
<ul>
<li>op의 값
<ul>
<li>EPOLL_CTL_ADD: edfd와 연관된 epoll인스턴스에 fd와 연관된 파일을 감시하도록 추가하며, 각 이벤트는 event인자로 정의한다.</li>
<li>EPOLL_CTL_DEL: edfd와 연관된 epoll인스턴스에 fd를 감시하지 않도록 삭제한다.</li>
<li>EPOLL_CTL_MOD: 기존에 감시하고 있는 fd에 대한 이벤트를 event에 명시된 내용으로 갱신한다</li>
</ul>
</li>
</ul>
<p>event인자는 그 작업동작에 대한 설명을 담고 있다.</p>
<ul>
<li>epoll_event.events의 값(OR연산으로 여러 이벤트를 묶을 수 있음)
<ul>
<li>EPOLLERR: 해당 파일에서 발생하는 에러 상황. 이 이벤트는 따로 지정하지 않아도 항상 감시한다.</li>
<li>EPOLLET: 파일을 감시할 때, <code>edge-trigger</code>를 사용한다. 기본 동작은 레벨트리거 방식.</li>
<li>EPOLLHUP: 파일에서 발생하는 행업을 감시한다. 이 이벤트도 따로 지정하지 않아도 항상 감시한다.</li>
<li>EPOLLIN: 파일 읽기가 지연되지 않고 바로 가능한지 감시.</li>
<li>EPOLLONESHOT: 이벤트 발생 후 파일을 한번 읽고 나면 더 이상 감시하지 않는다. 이를 다시 활성화 하려면, <code>EPOLL_CTL_MOD</code>를 통해서 새로운 이벤트 값을 설정해야 한다.</li>
<li>EPOLLOUT: 파일 쓰기가 지연되지 않고 바로 가능한지 감시.</li>
<li>EPOLLPRI: 즉 시 읽어야한 OOB(TCP에서 말하는 OUT OF BAND데이터로, 전송순으로 받는 데이터의 순서를 무시하고 보내는 메세지. 잘 사용 안됨)데이터가 있는지 감시.</li>
</ul>
</li>
</ul>
<p>epoll_event구조체의 data필드는 사용자 데이터를 위한 필드다.<br>
이 필드에 담긴 내용은 이벤트 발생 후 사용자에게 반환될 때 함께 반환된다.<br>
주로 <code>event.data.fd</code>를 fd로 채워서 이벤트가 발생 했을 때,<br>
어떤 파일 디스크립터를 들여다 봐야 하는지 확인하는 용도로 사용한다.</p>
<p><code>epoll_ctl()</code>호출이 성공하면 0을 반환, 실패시 -1반환.<br>
errno를 다음 중 한 가지로 설정.</p>
<ul>
<li>EBADF: epdf가 유효한 epoll인스턴스가 아니거나, fd가 유효한 파일 디스크립터가 아니다.</li>
<li>EEXIST: op가 EPOLL_CTL_ADD인데, fd가 이미 epfd와 연결되어 있다.</li>
<li>EINVAL: epfd가 epoll인스턴스가 아니거나, epfd가 fd와 같다. 또는 잘못된 op값이 사용.</li>
<li>ENOENT: op가 EPOLL_CTL_MOD, 혹은 EPOLL_CTL_DEL인데, fd가 epfd와 연결되지 않았다.</li>
<li>ENOMEM: 해당 요청을 처리하기에는 메모리가 부족하다.</li>
<li>EPERM: fd가 epoll을 지원하지 않는다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *stream;</span><br><span class="line"><span class="keyword">int</span> fd, epfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">stream = fopen(<span class="string">"sample"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span> (!stream)&#123;</span><br><span class="line">    perror(<span class="string">"fopen"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd = fileno(stream);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">    perror(<span class="string">"fileno"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (epfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">"epoll_create1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이벤트 epfd에 추가</span></span><br><span class="line">ret = epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"><span class="comment">// 기존 이벤트 변경</span></span><br><span class="line">ret = epoll_ctl(epfd, EPOLL_CTL_MOD, fd, &amp;event);</span><br><span class="line"><span class="comment">// 기존 이벤트 삭제</span></span><br><span class="line">ret = epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret)&#123;</span><br><span class="line">    perror(<span class="string">"epoll_ctl"</span>);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(epfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="epoll로_이벤트_대기하기"><a class="markdownIt-Anchor" href="#epoll로_이벤트_대기하기"></a> epoll로_이벤트_대기하기</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 64</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span> <span class="comment">// event를 포인터를 담을 수 있는 공간으로</span></span><br><span class="line"><span class="keyword">int</span> nr_events, i, epfd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">events = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct epoll_event)* MAX_EVENTS);</span><br><span class="line"><span class="keyword">if</span> (!events)&#123;</span><br><span class="line">    perror(<span class="string">"malloc"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nr_events = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (nr_events &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">"epoll_wait"</span>);</span><br><span class="line">    <span class="built_in">free</span>(events);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_events; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"event=%ld on fd=%d\n"</span>, events[i].events, events[i].data.fd);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    이제 events[i].data.fd에 대한 events[i].events를</span></span><br><span class="line"><span class="comment">    블록하지 않고 처리할 수 있다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(events);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>epoll_wait()</code>를 호출</li>
<li>timeout밀리 초 동안 epoll인스턴스인 epfd에 등록한 파일의 이벤트를 기다린다.</li>
<li>성공시 events에는 해당 이벤트, 파일이 일기나 쓰기가 가능한 상태인지 나타내는<br>
<code>epoll_event</code>구조체에 대한 포인터가 기록.<br>
최대 maxevents만큼의 이벤트가 기록된다.<br>
발생한 이벤트 개수를 반환하며 에러시 -1, errno를 다음중 하나로 기록한다.</li>
<li><code>epoll_wait()</code>가 결과를 반환하면, epoll_event구조체의 evens필드에는 발생 이벤트가 기록된다.<br>
data필드에는 사용자가 <code>epoll_ctl()</code>을 호출하기 전에 설정한 값이 담겨있다.</li>
</ol>
<ul>
<li>EBADF: epfd가 유효한 fd가 아니다.</li>
<li>EFAULT: events가 가리키는 메모리에 대한 쓰기 권한이 없다.</li>
<li>EINTR: 시스템 콜이 완료되거나 타임아웃 전에 시그널이 발생해서 동작을 멈추었다.</li>
<li>EINVAL: epfd가 유효한 epoll인스턴스가 아니거나 maxevents값이 0이하이다.</li>
</ul>
<p>timeout이 0이면 즉히 반환 반환값은 0이다.<br>
timeout이 -1이면 이벤트가 발생 할 때까지 해당 호출은 반환되지 않는다.(블로킹 상태)</p>
<hr>
<h3 id="에지트리거와_레벨트리거"><a class="markdownIt-Anchor" href="#에지트리거와_레벨트리거"></a> 에지트리거와_레벨트리거</h3>
<p><code>epoll_ctl()</code>로 전달되는 event인자의 events필드를 EPOLLET로 설정하면,<br>
fd에 대한이벤트 모니터가 레벨 트리거가 아닌 엣지 트리거로 동작한다.</p>
<p>유닉스 파이프로 통신하는 입출력에 대한 사례는 아래와 같다.</p>
<ol>
<li>출력하는 측에서 파이프에 1kb만큼 데이터를 쓴다.</li>
<li>입력 받는 쪽에서는 파이프에 대해서 <code>epoll_wait()</code>를 수행하고</li>
<li>파이프에 데이터가 들어와서 읽을 수 있는 상태가 되기를 기다린다.</li>
</ol>
<ul>
<li>레벨 트리거로 이벤트를 모니터링하면, 2의 <code>epoll_wait()</code>호출은 즉시 반환하며,<br>
파이프가 읽을 준비가 되었음을 알려준다.</li>
<li>엣지 트리거로 모니터링하면 1단계가 완료될 때까지, 호출은 반환되지 않는다.</li>
</ul>
<p>기본 동작방식은 <strong>레벨트리거</strong>방식이다. **<code>poll()</code>**과 **<code>select()</code>**가 동작하는 방식이 레벨트리거 방식인데,<br>
대부분 개발자들이 생각하는 방식 이기도 하다.</p>
<p><strong>엣지 트리거</strong>방식은 일반적으로 <strong>논블로킹 입출력</strong>을 활용하는 접근방식을 <strong>요구</strong>하며, <code>EAGAIN</code>을 주의깊게 확인해야 한다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/08/22/linux/select_poll/" data-id="ckkdb52fm000f1pqkz5ms7l1v" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/08/27/c/io_functions_advanced/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">최신</strong>
      <div class="article-nav-title">
        
          소켓과 스트림을 이해하기 위한 고급 IO함수
        
      </div>
    </a>
  
  
    <a href="/2019/08/19/c/IO_functions/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">이전</strong>
      <div class="article-nav-title">소켓과 스트림을 이해하기 위한 C의 IO함수들</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/custom-module/">custom module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fabric/">fabric</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/functional-programming/">functional programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-deploy/">hexo-deploy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pipenv/">pipenv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgresql/">postgresql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-module/">python module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-post/">python post</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/testing/">testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travel-note/">travel_note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tutorial/">tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그 클라우드</h3>
    <div class="widget tagcloud">
      <a href="/tags/c/" style="font-size: 11.43px;">c</a> <a href="/tags/custom-module/" style="font-size: 12.86px;">custom module</a> <a href="/tags/django/" style="font-size: 14.29px;">django</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/fabric/" style="font-size: 10px;">fabric</a> <a href="/tags/functional-programming/" style="font-size: 11.43px;">functional programming</a> <a href="/tags/hexo-deploy/" style="font-size: 10px;">hexo-deploy</a> <a href="/tags/http/" style="font-size: 11.43px;">http</a> <a href="/tags/linux/" style="font-size: 15.71px;">linux</a> <a href="/tags/network/" style="font-size: 11.43px;">network</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/pipenv/" style="font-size: 10px;">pipenv</a> <a href="/tags/postgresql/" style="font-size: 10px;">postgresql</a> <a href="/tags/project/" style="font-size: 10px;">project</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/python-module/" style="font-size: 17.14px;">python module</a> <a href="/tags/python-post/" style="font-size: 18.57px;">python post</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/testing/" style="font-size: 10px;">testing</a> <a href="/tags/travel-note/" style="font-size: 10px;">travel_note</a> <a href="/tags/tutorial/" style="font-size: 10px;">tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">아카이브</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">1월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">9월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">8월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">7월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">6월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">5월 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">최근 포스트</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/26/fastcamp/my_post/">test_post</a>
          </li>
        
          <li>
            <a href="/2019/09/17/http/2_http_sementics/">http_1.0_sementics</a>
          </li>
        
          <li>
            <a href="/2019/09/09/project/travel_note/">travel_note 서비스 고찰</a>
          </li>
        
          <li>
            <a href="/2019/09/06/http/1_http_1.0_basic_four_feature/">http/1.0의 신택스: 기본이 되는 네가지 요소</a>
          </li>
        
          <li>
            <a href="/2019/09/05/python/post/async_coroutine_5/">비동기 코루틴 번역-5-End</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 junehan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>