<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>소켓과 스트림을 이해하기 위한 C의 IO함수들 | Junehan&#39;s workbook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Index  개요 입출력 함수 표준 입출력과 버퍼 File과 Stream, 그리고 일반파일 입출력 바이너리 데이터 읽기 버퍼 입출력 예제 프로그램 추가 유용한 기능   개요 콘솔 입출력을 위한 입력 스트림과 출력 스트림은 프로그램이 실행되면 자동으로 생성되고, 프로그램이 종료되면 자동으로 소멸되는 스트림이다.  표준 스트림     name desc tar">
<meta name="keywords" content="c">
<meta property="og:type" content="article">
<meta property="og:title" content="소켓과 스트림을 이해하기 위한 C의 IO함수들">
<meta property="og:url" content="https://codenamenadja.github.io/2019/08/19/c/IO_functions/index.html">
<meta property="og:site_name" content="Junehan&#39;s workbook">
<meta property="og:description" content="Index  개요 입출력 함수 표준 입출력과 버퍼 File과 Stream, 그리고 일반파일 입출력 바이너리 데이터 읽기 버퍼 입출력 예제 프로그램 추가 유용한 기능   개요 콘솔 입출력을 위한 입력 스트림과 출력 스트림은 프로그램이 실행되면 자동으로 생성되고, 프로그램이 종료되면 자동으로 소멸되는 스트림이다.  표준 스트림     name desc tar">
<meta property="og:locale" content="ko">
<meta property="og:updated_time" content="2021-01-25T08:36:06.067Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="소켓과 스트림을 이해하기 위한 C의 IO함수들">
<meta name="twitter:description" content="Index  개요 입출력 함수 표준 입출력과 버퍼 File과 Stream, 그리고 일반파일 입출력 바이너리 데이터 읽기 버퍼 입출력 예제 프로그램 추가 유용한 기능   개요 콘솔 입출력을 위한 입력 스트림과 출력 스트림은 프로그램이 실행되면 자동으로 생성되고, 프로그램이 종료되면 자동으로 소멸되는 스트림이다.  표준 스트림     name desc tar">
  
    <link rel="alternate" href="/atom.xml" title="Junehan&#39;s workbook" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junehan&#39;s workbook</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">work flow and descriptions</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="검색"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://codenamenadja.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-c/IO_functions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/19/c/IO_functions/" class="article-date">
  <time datetime="2019-08-19T09:34:26.000Z" itemprop="datePublished">2019-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      소켓과 스트림을 이해하기 위한 C의 IO함수들
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> Index</h2>
<ol>
<li><a href="#%EA%B0%9C%EC%9A%94"><strong>개요</strong></a></li>
<li><a href="#%EC%9E%85%EC%B6%9C%EB%A0%A5_%ED%95%A8%EC%88%98"><strong>입출력 함수</strong></a></li>
<li><a href="#%ED%91%9C%EC%A4%80_%EC%9E%85%EC%B6%9C%EB%A0%A5%EA%B3%BC_%EB%B2%84%ED%8D%BC"><strong>표준 입출력과 버퍼</strong></a></li>
<li><a href="#FILE%EA%B3%BC_STREAM_%EA%B7%B8%EB%A6%AC%EA%B3%A0_%EC%9D%BC%EB%B0%98%ED%8C%8C%EC%9D%BC%EC%9D%98_%EC%9E%85%EC%B6%9C%EB%A0%A5"><strong>File과 Stream, 그리고 일반파일 입출력</strong></a></li>
<li><a href="#%EB%B0%94%EC%9D%B4%EB%84%88%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%9D%BD%EA%B8%B0"><strong>바이너리 데이터 읽기</strong></a></li>
<li><a href="#%EB%B2%84%ED%8D%BC%EC%9E%85%EC%B6%9C%EB%A0%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8"><strong>버퍼 입출력 예제 프로그램</strong></a></li>
<li><a href="#%EC%B6%94%EA%B0%80_%EC%9C%A0%EC%9A%A9%ED%95%9C_%EA%B8%B0%EB%8A%A5%EB%93%A4"><strong>추가 유용한 기능</strong></a></li>
</ol>
<h2 id="개요"><a class="markdownIt-Anchor" href="#개요"></a> 개요</h2>
<p>콘솔 입출력을 위한 입력 스트림과 출력 스트림은 프로그램이 실행되면 자동으로 생성되고, 프로그램이 종료되면 자동으로 소멸되는 스트림이다.</p>
<ul>
<li>표준 스트림</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">name</th>
<th style="text-align:left">desc</th>
<th style="text-align:left">target</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">stdin</td>
<td style="text-align:left">표준 입력 스트림</td>
<td style="text-align:left">키보드 대상</td>
</tr>
<tr>
<td style="text-align:left">stdout</td>
<td style="text-align:left">표준 출력 스트림</td>
<td style="text-align:left">모니터 대상</td>
</tr>
<tr>
<td style="text-align:left">stderr</td>
<td style="text-align:left">표준 에러 스트림</td>
<td style="text-align:left">모니터 대상</td>
</tr>
</tbody>
</table>
<p>stdin이 <strong>입출력 리디렉션</strong>을 통해서 stdout의 파일로 전송되고 해당 바이트 만큼 stdin을 fflush하여 stdin은 비워진 상태로 인터럽션을 일으키지 않는다.</p>
<ul>
<li><a href="https://codenamenadja.github.io/2019/08/12/linux/basic_concept/#%ED%8A%B9%EC%88%98_%ED%8C%8C%EC%9D%BC">basic concept of Linux / about file 링크</a></li>
</ul>
<p>하드웨어 장치를 추상화하는 디바이스 파일로서 커널이 파일로서 관리하는 기본적인 2분류에 대해서 설명했었다.</p>
<p>키보드 디바이스 파일은,</p>
<ol>
<li>캐릭터 디바이스 파일로서 해당 파일에 캐릭터가 들어오면 바로 인터럽션을 일으키고,</li>
<li>영어의 경우 1바이트를 읽어내고 언어 설정에 따라 해당 키보드 입력 값을 UNICODE캐릭터로 변환</li>
<li>모니터 출력 디바이스파일로 전송한다.</li>
<li>브라우저프로세스를 예를 들면, Keyup이라하는 이벤트는, 키보드 인터럽션에 대해서, output스트림을 stdout이 아닌 브라우저 프로세스 메모리에 대해 연결해 놓은 것이다.</li>
<li>프로세스에서 처리가 끝나면, 부분적인 렌더링을 개시한다. 내가 입력한 것이 모니터로 전달한 것이 아니라, 내가 입력한 값이 속성으로 전달되고, 프로세스가 그것을 모니터 출력으로 연결하는 것이다.</li>
<li>그래서 프로세스에서 value를 조정해서 객체의 속성을 브라우저에 인식시키면, 해당 프로세스의 로직이 바로 모니터 out에 전달하게 하는지 아닌지는 로직에 달려있다.</li>
<li>stdin은 전달하고 나면 바로 fflush되어 해당 디바이스 파일은 비워지게 된다.</li>
</ol>
<p>만약 fflush되어 해당 피일이 비워지지 않는다면, 뭔가 에러가 날 가능 성이 있는데,<br>
가장 확실한 에러는 다음에 값을 입력해서 키보드 디바이스파일에 캐릭터가 들어왔다는 인터럽션이 일어났을 때,<br>
읽어야할 바이트가 1바이트인데, 앞에서 부터 1바이트를 읽는다하면, 이번에 입력된 값과 추후 들어올 값들은 모두 누적되기만 하는 것이다.</p>
<hr>
<h2 id="입출력_함수"><a class="markdownIt-Anchor" href="#입출력_함수"></a> 입출력_함수</h2>
<h3 id="문자-단위-입출력-함수"><a class="markdownIt-Anchor" href="#문자-단위-입출력-함수"></a> 문자 단위 입출력 함수</h3>
<ul>
<li>문자 출력 함수</li>
</ul>
<p><strong>함수 호출 성공시 쓰여진 문자정보, 실패 시 <code>EOF</code> 반환</strong></p>
<ol>
<li>
<p>putchar</p>
<p><code>int putchar(int c);</code></p>
<p>인자로 전달된 문자 정보를 <code>stdout</code>으로 전송하는 함수</p>
</li>
<li>
<p>fputc</p>
<p><code>int fputc(int c, FILE *stream);</code></p>
<p>위와 동일하지만, <code>FILE *stream</code>의 파일객체를 지정할 수 있다. 출력 스트림이 모니터 디바이스파일이 아닌, 일반 파일로 전송하는 것이 가능하다.</p>
<p>따라서 <code>stdout</code>을 2번째 매개변수로 전달하면 <code>putchar</code>과 동일한 함수가 된다.</p>
</li>
</ol>
<ul>
<li>문자 입력 함수</li>
</ul>
<p><strong>파일 끝에 도달하거나, 함수호출 실패 시 <code>EOF</code> 반환</strong></p>
<ol>
<li>
<p>getchar</p>
<p><code>int getchar(void);</code></p>
<p>모니터 출력 대응용으로 하나의 문자를 받아서 반환한다.</p>
</li>
<li>
<p>fgetc</p>
<p><code>int fgetc(FILE *stream)</code></p>
<p><code>fgetc</code>와 달리 입력 받을 스트림을 지정할 수 있다.</p>
</li>
</ol>
<h3 id="예제_1"><a class="markdownIt-Anchor" href="#예제_1"></a> 예제_1</h3>
<ul>
<li>단순 입출력 사용</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch1, ch2;</span><br><span class="line"></span><br><span class="line">    ch1 = getchar(); <span class="comment">// 문자 키 입력</span></span><br><span class="line">    ch2 = fgetc(<span class="built_in">stdin</span>); <span class="comment">// 엔터 키 입력</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(ch1) <span class="comment">// 문자 출력</span></span><br><span class="line">    fputc(ch2, <span class="built_in">stdout</span>) <span class="comment">// 엔터 키 출력</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">console-&gt;</span></span><br><span class="line"><span class="comment">p (p 누르고 엔터)</span></span><br><span class="line"><span class="comment">p (p출력, 엔터\n 으로 ascii 10인 값으로 출력)</span></span><br><span class="line"><span class="comment">(엔터로 인한 줄바꿈)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>문자 입출력에서의 <code>EOF</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">        <span class="keyword">if</span>(ch==EOF)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">console -&gt;</span></span><br><span class="line"><span class="comment">Hi~ (사용자 입력+엔터)</span></span><br><span class="line"><span class="comment">Hi~ ()</span></span><br><span class="line"><span class="comment">I like C lang. (사용자 입력+엔터)</span></span><br><span class="line"><span class="comment">I like C lang.</span></span><br><span class="line"><span class="comment">^Z (EOF를 반환시키는 CTRL+Z , CTRL+D)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>getchar()함수는 문자 하나를 입력 받기 위한 함수 이지만, 만약 키보드 디바이스파일에 문자 하나이상 입력되었다면,<br>
그 값이 비워질 만큼, getchar()을 누적해서 실행하여 해당 변수에 더한다.<br>
getchar()자체는 하나만을 리턴하는게 맞지만 만약 입력값이 남아있다면 파일이 빌 때 까지 계속 실행하는 것이다.</p>
<ul>
<li>문자 반환형이 int 인 이유는?</li>
</ul>
<p>반환되는 것은 1바이트 크기의 문자인데, 반환형이 int인 이유는<br>
반환하는 값 중 하나인 <code>EOF</code> 는 -1로 정의된 상수이다.</p>
<p>따라서 char형 이라면, 그리고 char을 unsigned char로 처리하는 컴파일러에 의해 컴파일이 되었다면, EOF는 반환의 과정에서</p>
<p>엉뚱하게도 양의 정수로 형변환이 되어버리고 만다.<br>
그래서 어떤 상황에서도 -1을 인식 할 수 있는 int형으로 반환형을 정의해 놓은 것이다.</p>
<hr>
<h3 id="문자열-단위-입출력-함수"><a class="markdownIt-Anchor" href="#문자열-단위-입출력-함수"></a> 문자열 단위 입출력 함수</h3>
<ul>
<li>문자열 출력 함수</li>
</ul>
<p><strong>성공시 음수가 아닌 값을, 실패 시 <code>EOF</code>반환</strong></p>
<p><strong>문자 열의 끝에는 항상 <code>Null</code>이 1바이트 사이즈로 있다.</strong></p>
<ol>
<li>
<p>puts<br>
<code>int puts(const char *s);</code></p>
<p>출력 후 자동 개행</p>
</li>
<li>
<p>fputs</p>
<p><code>int fputs(conts char *s, FILE *stream);</code></p>
<p>출력 후 개행 없음</p>
</li>
</ol>
<h3 id="예제_2"><a class="markdownIt-Anchor" href="#예제_2"></a> 예제_2</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> text[] = <span class="string">"Simple String"</span> <span class="comment">// 문자열은 이미 배열 포인터</span></span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    str = text <span class="comment">// str에는 주소가 들어올 수 있고 text는 이미 배열 포인터이다.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1. puts tests ---- \n"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"So Simple string!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2. fputs tests ---- \n"</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(str, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"So Simple String2!"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3. end of main ----"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">console --&gt;</span></span><br><span class="line"><span class="comment">1. puts tests ----</span></span><br><span class="line"><span class="comment">Simple String</span></span><br><span class="line"><span class="comment">So Simple string!</span></span><br><span class="line"><span class="comment">2. fputs tests ----</span></span><br><span class="line"><span class="comment">Simple String</span></span><br><span class="line"><span class="comment">So Simple String2!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>문자열 입력 함수</p>
</li>
<li>
<p>gets</p>
<p><code>char *gets(char *s);</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">7</span>]; <span class="comment">// 7바이트 메모리 문자배열 할당</span></span><br><span class="line">    gets(str); <span class="comment">// 입력 받은 문자열을 배열 str에 저장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>미리 마련해 놓은 배열을 넘어서 문자열이 입력되면, 할당 받지 않은 할당 받지 않은 메모리 공간을 침범하여 오류가 발생.</p>
<p>따라서 가급적이면 아래의 형태로 <code>fgets</code>함수를 호출 하는 것이 좋다.</p>
<ul>
<li>
<p>fgets</p>
<p><code>char *fgets(char *s, int n, FILE *stream);</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">7</span>];</span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>); <span class="comment">// stdin으로부터 문자열 받아 str에 저장.</span></span><br></pre></td></tr></table></figure>
<p>stdin으로부터 문자열을 받아 배열 <code>str</code>함수에 저장화되, sizeof(str)의 길이 만큼만 저장해라.</p>
<p>이럴 경우 stdin에 10바이트가 들어왔으면,<br>
앞에서부터 7바이트만 끊어서 저장하게 된다.</p>
<ol>
<li><code>&quot;123456789&quot;</code>를 입력.</li>
<li><code>&quot;123456&quot;</code>이 저장. 마지막 1바이트는 NULL문자.</li>
</ol>
</li>
<li>
<p>한 줄씩 읽기</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limit.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[LINE_MAX];</span><br><span class="line"><span class="keyword">if</span> (!fgets(buf, LINE_MAX, stream))&#123;</span><br><span class="line">    &lt;!-- 에러 --&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>POSIX는 <code>&lt;limit.h&gt;</code>에서 LINE_MAX를 정의하고 있는데,<br>
이는 POSIX의 행처리 인터페이스가 다룰 수 있는 입력행의 최대 길이이다.</p>
</li>
<li>
<p>원하는 만큼 문자열 읽기</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stream = fopen(<span class="string">"/etc/manifest"</span>, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *s;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">s = str;</span><br><span class="line"><span class="keyword">while</span> (--n &gt; <span class="number">0</span> &amp;&amp; (c = fgetc(stream)) != EOF &amp;&amp; (*s++ = c) != d)&#123;</span><br><span class="line">    <span class="comment">// str에 n-1바이트를 읽어 str에 저장하고, \0을 추가한다.</span></span><br><span class="line">    <span class="comment">// *s의 다음 주소에 c(n-1바이트를 읽은 것)를 넣고 그것이 d(같은 바이트)와 같지않은 동안 계속 stream에서 읽고 저장한다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c == d)&#123;</span><br><span class="line">    *--s = <span class="string">"/0"</span>;</span><br><span class="line">    &lt;!-- 키워드 매치가 되면서<span class="keyword">break</span>했을떄 --&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    *s = <span class="string">"/0"</span>;</span><br><span class="line">    &lt;!-- n<span class="number">-1</span> 바이트가 <span class="number">0</span>이거나, 파일을 전부 읽었을 때,--&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>d를 &quot;\n&quot;으로 설정하면 <code>fgets</code>와 유사하게 동작한다. 단 버퍼에 개행문자를 저장하지 않는다.</p>
</li>
</ul>
<hr>
<h2 id="표준_입출력과_버퍼"><a class="markdownIt-Anchor" href="#표준_입출력과_버퍼"></a> 표준_입출력과_버퍼</h2>
<p>ANSI C의 표준에서 정의된 함수들을 표준 입출력 함수라 한다.</p>
<p><code>printf</code>, <code>scanf</code>, <code>fputc</code>, <code>fgetc</code>, <code>fputs</code>, <code>fgets</code> 모두 표준 입출력 함수이다.</p>
<p>이 표준 입출력 함수를 통해서 입출력 하는 경우, 해당 데이터들은 운영체제가 제공 하는 **<code>메모리 버퍼</code>**를 중간에 통과하게 된다.</p>
<p><code>메모리 버퍼</code>는 디바이스 드라이버에 있으며, 커널과 연계된 데이터를 임시로 모아두는 메모리 공간이다.</p>
<h3 id="버퍼링을-하는-이유는-무엇-인가"><a class="markdownIt-Anchor" href="#버퍼링을-하는-이유는-무엇-인가"></a> 버퍼링을 하는 이유는 무엇 인가?</h3>
<ol>
<li>물론, 키보드 디바이스는 캐릭터 디바이스로서 단일 문자가 입력되면, 바로 인터럽션이 일어나지만,</li>
<li>버퍼링을 통해서 그것을 저장해놓는 등으로 해당 인터럽션을 중요도가 낮은 인터럽션으로 처리하는 행동을 한다.</li>
<li>그리고 엔터키가 입력되었을떄. 읽어들인다는 행동으로 연결지어,</li>
<li>저장해놓았던 버퍼를 소모하고 메모리를 비운다.</li>
</ol>
<p>이 버퍼링의 가장 큰 이유는 <strong>데이터 전송의 효율성</strong>과 관련이 있다.</p>
<p>키보드나 모니터 같은 외부장치의 데이터 입출력은 생각보다 시간이 오래 걸리는 작업이다.<br>
따라서 버퍼링 없이 키보드가 눌릴때마다, 바로 목적지 프로세스로 이동시키는 것보다.<br>
중간에 메모리 버퍼를 둬서 데이터를 한데 묶어 이동시키는 것이 효율적이고 빠르다.</p>
<h3 id="출력-버퍼를-비우는-fflush함수"><a class="markdownIt-Anchor" href="#출력-버퍼를-비우는-fflush함수"></a> 출력 버퍼를 비우는 <code>fflush</code>함수</h3>
<p><strong>함수호출 성공 시 0, 실패시 EOF 반환</strong></p>
<p><code>int fflush(FILE *stream)</code></p>
<p><code>fflush(stdout)</code>으로 호출하면, 표준 출력버퍼를 비워라 라는 명령이다.</p>
<hr>
<h3 id="입력버퍼-비우기"><a class="markdownIt-Anchor" href="#입력버퍼-비우기"></a> 입력버퍼 비우기</h3>
<p>출력버퍼를 비우는 것이 데이터가 목적지(프로세스)로 전송됨을 의미한다면,<br>
입력버퍼를 비우는 것은 <strong>데이터의 소멸</strong>을 의미한다.</p>
<ul>
<li>예제_1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> perID[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"주민번호 앞 6자리 입력: "</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    fgets(perID, <span class="keyword">sizeof</span>(perID), <span class="built_in">stdin</span>); <span class="comment">// block IOWAIT</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"이름 입력: "</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    fgets(name, <span class="keyword">sizeof</span>(name), <span class="built_in">stdin</span>); <span class="comment">// block_IOWAIT</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"주민번호: %s\n"</span>, perID);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"이름: %s\n"</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">console --&gt;</span></span><br><span class="line"><span class="comment">주민번호 앞 6자리 입력: 231423</span></span><br><span class="line"><span class="comment">이름 입력: 주민번호: 231423</span></span><br><span class="line"><span class="comment">이름: </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol>
<li>첫 <code>fgets()</code> 에서 7바이트를 읽어들이라고 했지만, \n을 만나는 순간 읽지 못하고 6바이트만 읽어들임.</li>
<li>2번째 <code>fputs()</code>에서 \n이 버퍼에 있기 떄문에, 바로 이스케이프.</li>
</ol>
<ul>
<li>예제_1 개선</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearLineFromReadBuffer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(getchar()!= <span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> perID[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"번호 앞 6자리 입력: "</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    fgets(perID, <span class="keyword">sizeof</span>(perID), <span class="built_in">stdin</span>); <span class="comment">// block IOWAIT</span></span><br><span class="line">    <span class="comment">// buffer = '\n'</span></span><br><span class="line">    ClearLineFromReadBuffer(); <span class="comment">// 입력버퍼 비우기</span></span><br><span class="line">    <span class="comment">// buffer = ''</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"이름 입력: "</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    fgets(name, <span class="keyword">sizeof</span>(name), <span class="built_in">stdin</span>); <span class="comment">// block_IOWAIT</span></span><br><span class="line">    ClearLineFromReadBuffer(); <span class="comment">// 입력버퍼 비우기</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"주민번호: %s\n"</span>, perID);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"이름: %s\n"</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ClearLineFromReadBuffer</code>에서 한문자로 취급되는 <code>\n</code> null이 읽혀지면 while문을 더 이상 수행하지 않는다.</p>
<p>따라서 그 시점에 버퍼에서 \n이라는 문자가 읽혀짐으로써 버퍼의 첫 \n이 사라짐.</p>
<hr>
<h2 id="file과_stream_그리고_일반파일의_입출력"><a class="markdownIt-Anchor" href="#file과_stream_그리고_일반파일의_입출력"></a> FILE과_STREAM_그리고_일반파일의_입출력</h2>
<h3 id="fopen함수-호출을-통한-파일과-스트림-형성-file구조체"><a class="markdownIt-Anchor" href="#fopen함수-호출을-통한-파일과-스트림-형성-file구조체"></a> fopen함수 호출을 통한 파일과 스트림 형성, FILE구조체</h3>
<p><strong>성공 시 해당파일의 FILE구조체 변수의 주소 값, 실패시 NULL포인터 반환</strong></p>
<p><code>FILE fopen(const char *filename, const char *mode);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE * fp=fopen(<span class="string">"simple.txt"</span>, <span class="string">"wt"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"file open fails!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fputc(<span class="string">'A'</span>, fp);</span><br><span class="line">    fputc(<span class="string">'B'</span>, fp);</span><br><span class="line">    fputc(<span class="string">'C'</span>, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"sample!\n"</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>wt</code>모드로 inode를 가르키고 close하는 순간 실행중인 프로세스 메모리가 해제된다.</p>
<p>fputc를 실행한다고, 바로 저장되는 것이 아니라,<br>
운영체제 단에서는 어느정도 버퍼메모리에 저장해놓고, 모든 변경된 버퍼를 수집해서 최적수준으로 정려한 후에 디스크에 쓴다.<br>
이러한 과정을 <code>writeback</code>이라 한다.</p>
<p>이런 방식은 쓰기호출을 빠르게 수행해서 거의 즉시 반환하도록 만든다.</p>
<p>그래서 버퍼메모리에 있지만 아직 파일 HDD로 저장하겠다는 시스템콜로 전달되지 않았다면.<br>
중간에 있던 커널쪽에 프로세스별로 디바이스 드라이버를 통해 관리하던 버퍼가 소멸되면서, 저장되지 못한채로 끝나게 된다.</p>
<p>그런 문제를 방지 하기 위해서, 커널은 최대 버퍼나이를 만들어 나이가 꽉찬 변경된 버퍼를 빠짐없이 기록한다.<br>
물론 HDD에 전달하였으나, HDD에서 또한 버퍼메모리로 잡아놓고 실제 물리적으로 저장하는 것은 좀 더딘 일이 되기도 한다.</p>
<hr>
<h2 id="바이너리데이터_읽기"><a class="markdownIt-Anchor" href="#바이너리데이터_읽기"></a> 바이너리데이터_읽기</h2>
<p>어떤 어플리케이션에서는 개별 문자나 행을 읽어서 버퍼에 입력하는 기능만으로는 부족한 경우가 있다.<br>
종종 C구조체같은 복잡한 바이너리데이터를 읽고 써야 하는 경우가 생긴다.<br>
이를 위해 표준입출력 라이브러리는 <code>fread()</code>함수를 제공한다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nr, FILE *stream);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>stream</code>에서 크기가 <code>size</code>바이트인 엘리먼트를 <code>nr</code>개 읽어서 buf가 가리키는 버퍼에 저장한다.</li>
<li>파일 포인터가 읽은 바이트에 숫자만큼 증가한다.</li>
<li>읽어들인 엘리먼트 개수가 반환된다.</li>
<li><code>nr</code>보다 적은 값을 반환하여 실패나 EOF를 알려준다.</li>
<li><code>ferror()</code>, <code>feof()</code>를 사용해야 두 조건중 어디에 해당하는지 확인 가능하다.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">size_t</span> nr;</span><br><span class="line">nr = fread(buf, <span class="keyword">sizeof</span>(buf), <span class="number">1</span>, stream);</span><br><span class="line"><span class="keyword">if</span> (nr == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="바이너리데이터_쓰기"><a class="markdownIt-Anchor" href="#바이너리데이터_쓰기"></a> 바이너리데이터_쓰기</h3>
<p>C변수처럼 바이너리 데이터를 직접 저장하려면 표준 입출력에서 제공하는 <code>fwrite()</code>를 사용한다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nr, FILE *stream);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>buf</code>가 가리키는 데이터에서 <code>size</code>크기의 엘리먼트 nr개를 stream에 쓴다.</li>
<li>파일 포인터는 기록한 바이트 개수만큼 전진한다.</li>
<li>성공시 엘리먼트 개수를 반환하고,</li>
<li><code>nr</code>보다 받은 반환값은 실패를 나타낸다.</li>
</ol>
<hr>
<h2 id="버퍼입출력_프로그램"><a class="markdownIt-Anchor" href="#버퍼입출력_프로그램"></a> 버퍼입출력_프로그램</h2>
<ol>
<li><code>struct pirate</code>를 정의 하고 이 타입의 변수 2개 선언.</li>
<li>변수 값중 하나를 초기화,</li>
<li>출력 스트림을 통해 data파일에 이 내용을 기록.</li>
<li>data에 대한 입력스트림을 열고 이를 통해 내용을 읽은 다음,</li>
<li>다른 <code>struct pirate</code>인스턴스를 그대로 복구.</li>
<li>마지막으로 그 구조체의 내용을 표준 출력에 전달.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *in, *out;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pirate</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> booty;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> beard_len;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pirate</span> <span class="title">blackbeard</span> = &#123;</span><span class="string">"Edward Teach"</span>, <span class="number">950</span>, **<span class="number">48</span>**&#125;; <span class="comment">// data FILE에 저장할(초기화정보)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pirate</span> <span class="title">p</span>;</span> <span class="comment">// data FILE을 읽어서 저장할.</span></span><br><span class="line"></span><br><span class="line">    out = fopen(<span class="string">"data"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!out)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fwrite(&amp;blackbeard, <span class="keyword">sizeof</span>(struct pirate), <span class="number">1</span>, out))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fwrite"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fclose(out))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fclose"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    in = fopen(<span class="string">"data"</span>, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fread(&amp;p, <span class="keyword">sizeof</span>(struct pirate), <span class="number">1</span>, in))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fread"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fclose(in))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fclose"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name=\"%s\" booty=%lu beard_len=%u\n"</span>,</span><br><span class="line">           p.name, p.booty, p.beard_len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total=%li\np.name=%li\np.booty=%li\np.bread_len=%li"</span>, <span class="keyword">sizeof</span>(p),<span class="keyword">sizeof</span>(p.name), <span class="keyword">sizeof</span>(p.booty), <span class="keyword">sizeof</span>(p.beard_len));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">"Edward Teach"</span> booty=950 beard_len=48</span><br><span class="line">total=120</span><br><span class="line">p.name=100</span><br><span class="line">p.booty=8</span><br><span class="line">p.bread_len=4</span><br></pre></td></tr></table></figure>
<p>변수 크기, 정렬등에서 차이가 있기 때문에, 특정 어플리케이션에서 쓴 바이너리 데이터를<br>
다른 어플리케이션에서 읽지 못할 수 있다.</p>
<blockquote>
<p>아키텍쳐와 ABI가 동일한 경우에만, 바이너리 데이터를 일관적으로 읽고 쓸 수 있다.</p>
</blockquote>
<h2 id="추가_유용한_기능들"><a class="markdownIt-Anchor" href="#추가_유용한_기능들"></a> 추가_유용한_기능들</h2>
<h3 id="스트림-비우기"><a class="markdownIt-Anchor" href="#스트림-비우기"></a> 스트림 비우기</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<p>스트림을 비우는 것은 이해해야할 것이 많다. 일단 이것은 사용자 영역에서 일어나는 함수이고,</p>
<p>스트림을 비우면 <code>프로세스 stream</code>에 있고 <code>아직 커널 파일버퍼로</code> 전달되지 않은 <code>데이터를 커널로</code> 비운다.</p>
<p><code>stream이 NULL이면</code> 프로세스에 할당된 <code>모든 파일 디스크립터의 입력스트림이</code> 비워진다.</p>
<p>데이터를 커널메모리로 내리고 프로세스 메모리에서 해제한다.<br>
만약 동기식 입출력처럼 물리적인 기록을 어느정도 보장 받고 싶다면, <code>fsync()</code>를 사용한다.</p>
<p><code>fflush()</code>를 호출한 다음 바로 <code>fsync()</code>를 호출한다.</p>
<h3 id="fd스트림_에러체크"><a class="markdownIt-Anchor" href="#fd스트림_에러체크"></a> fd스트림_에러체크</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ferror(f))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error on f!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (feof(f))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"EOF on f!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">clearerr(f); <span class="comment">// void 타입, 항시 성공. 에러를 비운다.</span></span><br></pre></td></tr></table></figure>
<h3 id="파일-디스크립터-얻어오기"><a class="markdownIt-Anchor" href="#파일-디스크립터-얻어오기"></a> 파일 디스크립터 얻어오기</h3>
<ul>
<li>파일 디스크립터 생성
<ol>
<li><code>open</code></li>
<li><code>creat</code></li>
</ol>
</li>
<li>파일을 추상화하는 스트림 생성
<ol>
<li><code>fopen</code></li>
</ol>
</li>
<li>디스크립터로부터 추상화된 스트림으로 변환
<ol>
<li><code>fdopen</code></li>
</ol>
</li>
</ul>
<p>종종 스트림에서부터 디스크립터를 구해야하는 경우가 있다.<br>
예를 들어. 표준 입출력함수가 없을 때, 그 파일 디스크립터를 통해서 시스템콜을 수행할 수 있다면 유용할 것이다.</p>
<p>스트림에서 파일디스크립터를 구하려면 <code>fileno()</code>를 사용한다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<p>성공하면 stream과 관련된 파일 디스크립터를 반환하고, 실패하면 -1을 반환한다.</p>
<p>주어진 스트림이 유효하지 않는 경우에만 실패하며 이 경우 <code>errorno</code>는 <code>EBADF</code>로 설정</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/08/19/c/IO_functions/" data-id="ckkdb52f300011pqk3mnqplcx" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/08/22/linux/select_poll/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">최신</strong>
      <div class="article-nav-title">
        
          multiple io, select() and poll()
        
      </div>
    </a>
  
  
    <a href="/2019/08/16/linux/memory_of_process/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">이전</strong>
      <div class="article-nav-title">basic concept of linux / about memory</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/custom-module/">custom module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fabric/">fabric</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/functional-programming/">functional programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-deploy/">hexo-deploy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pipenv/">pipenv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgresql/">postgresql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-module/">python module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-post/">python post</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/testing/">testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travel-note/">travel_note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tutorial/">tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그 클라우드</h3>
    <div class="widget tagcloud">
      <a href="/tags/c/" style="font-size: 11.43px;">c</a> <a href="/tags/custom-module/" style="font-size: 12.86px;">custom module</a> <a href="/tags/django/" style="font-size: 14.29px;">django</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/fabric/" style="font-size: 10px;">fabric</a> <a href="/tags/functional-programming/" style="font-size: 11.43px;">functional programming</a> <a href="/tags/hexo-deploy/" style="font-size: 10px;">hexo-deploy</a> <a href="/tags/http/" style="font-size: 11.43px;">http</a> <a href="/tags/linux/" style="font-size: 15.71px;">linux</a> <a href="/tags/network/" style="font-size: 11.43px;">network</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/pipenv/" style="font-size: 10px;">pipenv</a> <a href="/tags/postgresql/" style="font-size: 10px;">postgresql</a> <a href="/tags/project/" style="font-size: 10px;">project</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/python-module/" style="font-size: 17.14px;">python module</a> <a href="/tags/python-post/" style="font-size: 18.57px;">python post</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/testing/" style="font-size: 10px;">testing</a> <a href="/tags/travel-note/" style="font-size: 10px;">travel_note</a> <a href="/tags/tutorial/" style="font-size: 10px;">tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">아카이브</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">1월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">9월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">8월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">7월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">6월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">5월 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">최근 포스트</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/26/fastcamp/my_post/">test_post</a>
          </li>
        
          <li>
            <a href="/2019/09/17/http/2_http_sementics/">http_1.0_sementics</a>
          </li>
        
          <li>
            <a href="/2019/09/09/project/travel_note/">travel_note 서비스 고찰</a>
          </li>
        
          <li>
            <a href="/2019/09/06/http/1_http_1.0_basic_four_feature/">http/1.0의 신택스: 기본이 되는 네가지 요소</a>
          </li>
        
          <li>
            <a href="/2019/09/05/python/post/async_coroutine_5/">비동기 코루틴 번역-5-End</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 junehan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>