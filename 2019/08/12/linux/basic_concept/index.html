<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>basic concept of linux / about file | Junehan&#39;s workbook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Index  파일과 프로세스, 파이프와 소켓을 다루기 위한 추상적 인터페이스 등이 유닉스의 핵심.    file  select 시스템 콜   일반 파일 디렉터리와 링크  하드 링크 심볼릭 링크   특수 파일   파일 파일은 리눅스에서 가장 기본적이고 핵심이 되는 추상화 개념   리눅스에서는 모든 것이 파일이다   파일에 접근하려면 먼저 파일을 열어야 한다">
<meta name="keywords" content="linux">
<meta property="og:type" content="article">
<meta property="og:title" content="basic concept of linux &#x2F; about file">
<meta property="og:url" content="https://codenamenadja.github.io/2019/08/12/linux/basic_concept/index.html">
<meta property="og:site_name" content="Junehan&#39;s workbook">
<meta property="og:description" content="Index  파일과 프로세스, 파이프와 소켓을 다루기 위한 추상적 인터페이스 등이 유닉스의 핵심.    file  select 시스템 콜   일반 파일 디렉터리와 링크  하드 링크 심볼릭 링크   특수 파일   파일 파일은 리눅스에서 가장 기본적이고 핵심이 되는 추상화 개념   리눅스에서는 모든 것이 파일이다   파일에 접근하려면 먼저 파일을 열어야 한다">
<meta property="og:locale" content="ko">
<meta property="og:updated_time" content="2021-01-25T08:36:06.071Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="basic concept of linux &#x2F; about file">
<meta name="twitter:description" content="Index  파일과 프로세스, 파이프와 소켓을 다루기 위한 추상적 인터페이스 등이 유닉스의 핵심.    file  select 시스템 콜   일반 파일 디렉터리와 링크  하드 링크 심볼릭 링크   특수 파일   파일 파일은 리눅스에서 가장 기본적이고 핵심이 되는 추상화 개념   리눅스에서는 모든 것이 파일이다   파일에 접근하려면 먼저 파일을 열어야 한다">
  
    <link rel="alternate" href="/atom.xml" title="Junehan&#39;s workbook" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junehan&#39;s workbook</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">work flow and descriptions</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="검색"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://codenamenadja.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-linux/basic_concept" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/12/linux/basic_concept/" class="article-date">
  <time datetime="2019-08-12T01:09:52.000Z" itemprop="datePublished">2019-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      basic concept of linux / about file
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> Index</h2>
<blockquote>
<p>파일과 프로세스, 파이프와 소켓을 다루기 위한 추상적 인터페이스 등이 유닉스의 핵심.</p>
</blockquote>
<hr>
<ol>
<li><a href="#%ED%8C%8C%EC%9D%BC"><strong>file</strong></a>
<ol>
<li><a href="#c%EC%9D%98_select%ED%95%A8%EC%88%98"><strong>select 시스템 콜</strong></a></li>
</ol>
</li>
<li><a href="#%EC%9D%BC%EB%B0%98%ED%8C%8C%EC%9D%BC"><strong>일반 파일</strong></a></li>
<li><a href="#%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC%EC%99%80_%EB%A7%81%ED%81%AC"><strong>디렉터리와 링크</strong></a>
<ol>
<li><a href="#%ED%95%98%EB%93%9C_%EB%A7%81%ED%81%AC"><strong>하드 링크</strong></a></li>
<li><a href="#%EC%8B%AC%EB%B3%BC%EB%A6%AD_%EB%A7%81%ED%81%AC"><strong>심볼릭 링크</strong></a></li>
</ol>
</li>
<li><a href="#%ED%8A%B9%EC%88%98_%ED%8C%8C%EC%9D%BC"><strong>특수 파일</strong></a></li>
</ol>
<h2 id="파일"><a class="markdownIt-Anchor" href="#파일"></a> 파일</h2>
<p>파일은 리눅스에서 가장 기본적이고 핵심이 되는 추상화 개념</p>
<blockquote>
<h3 id="리눅스에서는-모든-것이-파일이다"><a class="markdownIt-Anchor" href="#리눅스에서는-모든-것이-파일이다"></a> 리눅스에서는 모든 것이 파일이다</h3>
</blockquote>
<ol>
<li>파일에 접근하려면 먼저 파일을 열어야 한다.<br>
파일은 읽기, 쓰기 모드 등으로 열 수 있고, 이렇게 열린 파일은,<br>
해당 파일에 대한 메타데이터와 연결된 고유한 기술자(<strong>descriptor</strong>)를 통해 참조될 수 있다.</li>
<li>파일 디스크립터는 사용자 영역에서 공유되며, 응용프로갬이 파일에 접근할 떄 직접 사용.</li>
</ol>
<p>따라서,</p>
<ul>
<li>리눅스 프로그래밍의 대부분은 바로 이 파일 디스트립터(fd)를 열고 조작하고 닫는 작업이다.</li>
<li>파일 디스크립터는 정수로 표현된다.</li>
</ul>
<h3 id="c의_select함수"><a class="markdownIt-Anchor" href="#c의_select함수"></a> C의_select함수</h3>
<ul>
<li>동기적 통신</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sock = socket.socket()</span><br><span class="line">request = <span class="string">"GET &#123;&#125; HTTP/1.0\r\nHOST: xkcd.com\r\n\r\n"</span>.format(url)</span><br><span class="line">encoded = request.encode(<span class="string">"ascii"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.send(encoded) <span class="comment"># blocking 발생</span></span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># Done</span></span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"sent"</span>)</span><br></pre></td></tr></table></figure>
<p>이 메서드는 <code>IO wait</code>에 의해 단순히 전력을 낭비할 뿐만 아니라해 효과적으로 다수의 소켓에서 이벤트를 대기하는 것도 할 수 없다.<br>
고전적인 방법으로 <strong>BSD Unix</strong>의 해결책은 <code>select</code>였다.<br>
C함수이고, 그것은 Nonblocking소켓 또는 small array를 그들에게서 부터 기다릴 수 있다.</p>
<p>요즘에는 인터넷 어플리케이션이 무지막지한 연결수를 초래하여서 <code>poll</code>보다는,<br>
BSD의 <code>kqueue</code>, Linux의 <code>epoll</code>로 대체하게 되었다.<br>
이들은 <code>select</code>와 비슷한 동작을 가지고 있지만 다수의 연결을 잘 해결해 낸다.</p>
<p>파이썬 3.4의 <code>DefaultSelector</code>이 당신의 OS중에 가능한 최고의 <code>select</code>같은 함수를 사용한다.</p>
<p><code>network I/O</code>에 대한 인터럽션에 대응하는 알림을 등록하기 위해서</p>
<ol>
<li>우리는 논블로킹 소켓을 생성하고,</li>
<li>이것을 DefaultSelector에 등록한다.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_WRITE</span><br><span class="line"></span><br><span class="line">selector = DefaultSelector()</span><br><span class="line"></span><br><span class="line">sock = socket.socket()</span><br><span class="line">sock.setblocking(<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sock.connect((<span class="string">"xkcd.com"</span>, <span class="number">80</span>))</span><br><span class="line"><span class="keyword">except</span> BlockingIOError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">()</span>:</span></span><br><span class="line">    seletor.unregister(sock.fileno())</span><br><span class="line">    print(<span class="string">"connected!"</span>)</span><br><span class="line"></span><br><span class="line">selector.register(sock.fileno(), EVENT_WRITE, connected)</span><br><span class="line"><span class="comment"># sock.fileno()가 네트워크 소켓에 대한 파일 디스크립터(정수)로 자동 생성되고 할당된다.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>DefaultSelector() : select함수와 같은 역할
<ul>
<li>소켓을 생성하면 파일 디스트립터(IO wait, Read, write)가 1:1관계로 자동 생성된다.</li>
<li>소켓과 매핑된 <strong>파일디스트립터</strong>를 등록하고, 해당 파일에 대해 이벤트를 감지하면 약속된 행동을 개시한다.</li>
<li><code>select</code>함수는 비동기 소켓에 대해 또 다른 파일을 등록해 해당 파일 디스크립터에 대해 특정 이벤트를 감시하는(해당 인터럽션이 중요하다고 여기는 것) 약속을 등록하고 해제해준다.(이 또한 파일)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="일반파일"><a class="markdownIt-Anchor" href="#일반파일"></a> 일반파일</h2>
<p>일반 파일은 바이트 스트림이라 불리는 연속적으로 나열된 바이트 배열에 저장된 데이터를 의미한다.</p>
<ul>
<li><strong>파일 디스크립터</strong>
<ul>
<li>정수로 특정 파일에 대한 METADATA가 담긴 프로세스의 특수 메모리주소를 가리킨다.</li>
</ul>
</li>
<li><strong>파일 읽기</strong>
<ul>
<li>해당 파일 디스트립터가 가르키는 메타데이터의 inode의 오프셋(bytes)만큼 나열된 연속적 데이터(byte-array)를 가져온다.</li>
</ul>
</li>
</ul>
<p>리눅스에는 파일을 위한 특별한 자료구조가 없다. 따라서 어떠한 값이가도 들어갈 수 있다.<br>
시스템수준에서 살펴보면 리눅스는 <strong>바이트 스트림</strong>외어 어떤 자료구조도 강제하지 않는다.</p>
<p>파일이 처음 열리면 file-offset은 0이다.</p>
<p>직접 파일 오프셋을 지정할 수 도 있는데, 파일 끝을 넘길 수도 있다.<br>
파일 크기를 넘어 바이트를 기록하면 파일 끝에서 지정한 위치가 시작하는 부분까지 내용은 모두 0이 된다.</p>
<blockquote>
<p>파일을 쓰는 작업은 대부분 파일 끝에서 일어난다.<br>
파일 오프셋의 최댓값은 오프셋을 저장하기 위해 사용하는 C타입의 크기로 결정된다.<br>
최신리눅스에서는 64비트 값이다.</p>
</blockquote>
<p>하나의 파일은 다른 프로세스나 동일한 프로세스에서 한 번이상, 혹은 동시에 열려질 수 있다.<br>
그들은 열릴때마다 고유한 파일 디스크립터를 반환한다.<br>
프로세스에서는 따라서 파일 디스트립터를 공유할 수 있다.</p>
<p><strong>커널은 파일에 대한 동시 접근을 막지 않는다.</strong></p>
<p>일반적으로 파일 이름을 통해 파일에 접근하지만,<br>
실제로 파일은 <code>inode(information node)</code>라 하는 파일시스템의 고유한 정수값으로 참조 된다.</p>
<blockquote>
<p><code>Inode</code> 의 구성</p>
<ol>
<li>변경된 날짜</li>
<li>소유자</li>
<li>타입</li>
<li>길이</li>
<li>물리 데이터 저장 위치</li>
</ol>
</blockquote>
<p>파일이름은 저장하지 않는다.<br>
<code>inode</code>는 유닉스 파일 시스템에서 디스크에 저장된 물리적 객체임과 동시에,<br>
리눅스 커널에서 자료구조로 표현되는 논리적인 개념이기도 하다.</p>
<hr>
<h2 id="디렉터리와_링크"><a class="markdownIt-Anchor" href="#디렉터리와_링크"></a> 디렉터리와_링크</h2>
<p>inode번호로 파일에 접근하면 보안위협이 있어서, 파일 이름을 사용한다.<br>
디렉터리는 파일에 접근하기 위한 이름을 제공하는데, 이 이름과 inode의 Pair를 <code>Link</code>라고 한다.</p>
<p>개념적으로 디렉터리는 일반파일과 유사한 모습이지만 데이터가 존재하지 않는다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">type</th>
<th style="text-align:left">name</th>
<th style="text-align:left">data</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">directory</td>
<td style="text-align:left">in directory</td>
<td style="text-align:left">file’s namespaces</td>
</tr>
<tr>
<td style="text-align:left">file</td>
<td style="text-align:left">in directory</td>
<td style="text-align:left">as inode</td>
</tr>
<tr>
<td style="text-align:left">inode</td>
<td style="text-align:left">no</td>
<td style="text-align:left">file location, offset, elses</td>
</tr>
</tbody>
</table>
<p>실제 디렉터리도 inode가 있다. 따라서 디렉터리 내부의 링크 역시 다른 inode를 가질 수 있다.<br>
즉, 디렉터리는 계층적인 구조를 형성할 수 있게 된다.</p>
<p>이를 이용하여 <code>/home/sample/data.png</code>처럼 파일 경로를 사용할 수 있는 것이다.</p>
<p><code>/home/sample/data.png</code>같은 경로로 파일을 열겠다고 요청하면,</p>
<ol>
<li>해당 파일 경로에 속한 각 디렉터리 엔트리 (called as <code>dentry</code> by kernel)를 탐색하여 다음 항목의 inode를 찾음.</li>
<li><code>/</code>로 시작, <code>sample</code>디렉터리의 inode를 찾는다.</li>
<li><code>sample.png</code>의 inode를 얻는다.</li>
</ol>
<p>리눅스 커널은 <code>dentry</code> 캐시를 활용하여 찾기 결과를 저장하고 나중에 <strong>일시적인 지역성</strong>을 이용해 탐색속도를 높인다.</p>
<blockquote>
<p>지역성(locality) : 한번 접근한 데이터의 근처의 데이터에 또 접근하는 경우가 많다.</p>
</blockquote>
<p>비록 디렉터리도 inode가 있고 네임이 있으니, 일반 파일처럼 취급하지만,<br>
커널은 사용자 영역에서 디렉터리를 일반 파일처럼 열고 조작하지 못하도록 제한한다.<br>
따라서 디렉터리는 특수한 시스템 콜을 통해 조작해야하는데, 이를 위한 시스템 콜은 아래와 같다.</p>
<ol>
<li>링크 추가</li>
<li>링크 삭제</li>
</ol>
<p>사용자 영역에서 커널의 중제없이 디렉터리를 조작할 수 있게 하면, 조그만 오류가 발생해도 파일시스템 전체를 망가뜨릴 수 있다.</p>
<hr>
<h3 id="하드_링크"><a class="markdownIt-Anchor" href="#하드_링크"></a> 하드_링크</h3>
<table>
<thead>
<tr>
<th style="text-align:left">type</th>
<th style="text-align:left">origin</th>
<th style="text-align:left">name</th>
<th style="text-align:left">linkto</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">hard link</td>
<td style="text-align:left">A</td>
<td style="text-align:left">h_link_A</td>
<td style="text-align:left">A’s inode</td>
</tr>
<tr>
<td style="text-align:left">hard link</td>
<td style="text-align:left">A</td>
<td style="text-align:left">h_link_B</td>
<td style="text-align:left">A’s inode</td>
</tr>
<tr>
<td style="text-align:left">symbolic link</td>
<td style="text-align:left">B</td>
<td style="text-align:left">B_link_A</td>
<td style="text-align:left">B’s inode</td>
</tr>
<tr>
<td style="text-align:left">symbolic link</td>
<td style="text-align:left">B</td>
<td style="text-align:left">B_link_B</td>
<td style="text-align:left">B_link_A’s inode</td>
</tr>
</tbody>
</table>
<p>다른 이름으로 동일한 inode를 가르키지 못하게 하는 방법은 없다.<br>
다중 링크는 동일한 inode를 여러가지 이름으로 맵핑한다. 이를 <strong>하드링크</strong>라 한다.</p>
<p>동일한 inode에 대한 다수의 하드링크에 대해서 커널은 1회의 실행을 통해 원본의 inode를 알아낸다.</p>
<p>따라서 해당 원본에 대한 하드링크가 늘어난다면? 그만큼 <code>Referencing counter</code>이 늘어난다.<br>
원본을 지워도 원본의 inode를 가지고 있는 Referencing이 살아 있기 때문에, 해당 inode의 데이터는 삭제되지 않는다.</p>
<blockquote>
<p>링크 카운터가 0이 되는 순간 비로소 해당 inode가 포함하는 자료가 실제로 삭제된다.</p>
</blockquote>
<hr>
<h3 id="심볼릭_링크"><a class="markdownIt-Anchor" href="#심볼릭_링크"></a> 심볼릭_링크</h3>
<p>심벌릭 링크는 최종 엔드포인트가 origin의 inode를 가르키고 있지만, 독자적인 inode값을 가지게 된다.<br>
그래서 일반 디렉터리처럼 달리 독자성을 가지고 있기 때문에, 파일처럼 생겼다.</p>
<ol>
<li>
<p>하드 링크보다 심볼릭 링크가 결론적으로 오버헤드를 많이 가져오는 이유는,<br>
심벌릭 링크를 효과적으로 탐색하기 위해,<br>
해당 링크와 그 링크로 연결된 파일 둘다 다뤄야 하기 때문이다.</p>
</li>
<li>
<p>하드링크에서 추가적인 오버헤드가 발생하지 않는 이유는,<br>
파일 시스템에서는 링크가 둘 이상 걸린 파일에 접근하거나,<br>
하나만 걸린파일에 접근하거나 구현상 차이가 없기 때문이다.</p>
</li>
<li>
<p>심벌릭 링크가 단일로서는 오버헤드가 매우 작지만,(원본 레퍼런스의 couter을 늘리지 않는 점등에서,)  그래도 부정적인 것으로 취급받고 있다.</p>
</li>
<li>
<p>하드링크는 사용자 입장에서 봤을떄 원본 주소 그 자체이기 때문에, 완전히 투명하다.</p>
</li>
<li>
<p>그러나 실제로 2번 이상 링크된 파일을 찾아내는 작업이 더 어렵다.</p>
</li>
<li>
<p>반면 심볼릭 링크를 조작하려면 특수 시스템 콜이 필요하다.<br>
이런 투명성 결여는 심벌릭 링크가 명료하게 생성되며, 파일시스템내부 링크가 아닌,<br>
일종의 바로가기 처럼 사용되기 떄문에,<br>
종종 장점으로 작용하기도 한다.</p>
</li>
</ol>
<hr>
<h2 id="특수_파일"><a class="markdownIt-Anchor" href="#특수_파일"></a> 특수_파일</h2>
<p>정의</p>
<ul>
<li>파일로 표현되는 커널 객체</li>
</ul>
<p>종류</p>
<ol>
<li>캐릭터 디바이스 파일</li>
<li>블록 디바이스 파일</li>
<li>네임드 파이프</li>
<li>유닉스 도메인 소켓</li>
</ol>
<p>특수 파일은 모든 것이 파일이라는 유닉스 철학에 맞게,<br>
파일 시스템 위에 구현된 추상화 개념이며 리눅스는 특수파일을 생성하는 시스템 콜을 제공한다.</p>
<h3 id="하드웨어-장치를-추상화하는-디바이스-파일"><a class="markdownIt-Anchor" href="#하드웨어-장치를-추상화하는-디바이스-파일"></a> 하드웨어 장치를 추상화하는 디바이스 파일</h3>
<blockquote>
<p>하드웨어 장치마다 특수 디바이스파일이 존재한다.<br>
장치의 종류가 같다면 같은 인터페이스의 드라이버를 사용한다.<br>
특수 파일은 개별적이나 종류가 같다면 같은 인터페이스를 사용.</p>
</blockquote>
<ol>
<li>
<p><strong>캐릭터 디바이스 파일</strong></p>
<p>디바이스 드라이버는 큐에 바이트를 하나씩 집어 넣고, 사용자 영역에서는 큐에 쌓인 순서대로 바이트를 읽어낸다.</p>
<p>대표적인 예: 키보드</p>
<ol>
<li>사용자가 'peg’라고 입력</li>
<li>애플리케이션은 키보드 드라이버 인터페이스를 통해 디바이스 파일에서 p, e, g 를 순서대로 읽음.</li>
<li>읽을 문자 없을 시 <code>EOF(End of Line)</code>을 반환.</li>
</ol>
</li>
<li>
<p><strong>블록 디바이스 파일</strong></p>
<p>반면 블록 디바이스는 바이트 배열로 접근한다. 보통 저장장치를 말하는데,<br>
위치 지정이 가능한 장치에 여러 바이트를 맵핑해,<br>
사용자 영역에서는 이 배열이 포함하고 있는 유효한 바이트에 임의 접근할 수 있다.<br>
(하드 디스크 드라이브, 플로피 드라이브, CD-ROM드라이브, 플래시 메모리)</p>
<p>대표적인 예: HDD</p>
<ol>
<li>12바이트를 읽음</li>
<li>7바이트 읽음</li>
<li>12바이트 읽음</li>
</ol>
<p>블록 디바이스의 최소 접근 단위는 <code>섹터</code>이다.<br>
섹터는 디바이스의 물리적인 속성며 2의 승수로 나타내며 512가 가장 일반적이다.<br>
블록 디바이스는 섹터보다 더 작은 데이터 단위를 전송하거나 접근하지 못한다.<br>
따라서 모든 입출력은 섹터 하나를 가져오는 것 혹은 보내는 것을 기준으로 일어난다.</p>
</li>
<li>
<p><strong>네임드 파이프</strong></p>
<p>FIFO로 부르기도 한다.<br>
<code>IPC(Inter Process Communication)</code>메커니즘으로 특수파일을 읽고 쓰는 파일 디스크립터 형태로 통신 채널을 제공한다.</p>
<p>일반 파이프는 특정 프로그램 출력을 자신의 입력으로 잇는 것처럼, 다른 프로그램 입력으로 연결하기 위한 방법이다.</p>
<blockquote>
<p>시스템 콜로 만들어지는 일반 파이프는 파일 시스템이 아니라 메모리에 존재한다.</p>
</blockquote>
<p>네임드 파이프는 일반 파이프와 동일하게 동작하지만, <code>FIFO</code>라는 특수 파일을 거쳐 접근한다.<br>
서로 무관한 프로세스도 이 파일에 접근하는 방식으로 프로세스 사이에 통신이 가능해진다.</p>
</li>
<li>
<p><strong>소켓</strong></p>
<p>소켓은 다른 프로세스끼리 통신할 수 있는 고급 <code>IPC</code>의 한 종류이며, 다른머신과의 통신도 가능하다는 점이 다르다.</p>
<blockquote>
<p>소켓은 네트워크와 인터넷 프로그래밍의 근간.</p>
</blockquote>
<p>로컬 머신 내부에서 통신을 위해 사용하는 소켓형태인 유닉스 도메인 소켓을 포함하여, 많은 변종이 있다.</p>
<ol>
<li>인터넷에서 통신하는 소켓은 IP를 파악하기위해 <code>host name</code>, <code>port</code>를 사용.</li>
<li>유닉스 도메인 소켓은 파일 시스템에 만들어진 소켓파일(특수 파일)을 사용한다.</li>
</ol>
</li>
</ol>
<hr>
<h3 id="파일-시스템"><a class="markdownIt-Anchor" href="#파일-시스템"></a> 파일 시스템</h3>
<ul>
<li>
<p>접근단위</p>
<p>블록에서 최소 접근 단위가 <code>섹터</code>라면 파일 시스템에서의 논리적 최소 접근단위는 <code>블록</code>이다.</p>
</li>
<li>
<p>블록</p>
<p>블록은 파일시스템을 추상화한 개념으로 파일시스템이 존재하는 물리매체와 무관하다.<br>
블록은 보통 섹터크기의 2의 승수이다.</p>
<blockquote>
<p>따라서 일반적으로 섹터보다 더 크지만, 페이지 크기 보다는 작다.<br>
페이지 크기: 하드웨어 메모리 관리 유닛에서 지정 가능한 최소 단위</p>
</blockquote>
<p>보통 블록 크기는 512, 1024, 4096 바이트다.</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/08/12/linux/basic_concept/" data-id="ckkdb52ff00081pqky8ql2ffd" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/08/12/linux/basic_concept_procss_2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">최신</strong>
      <div class="article-nav-title">
        
          basic concept of linux / process and Thread
        
      </div>
    </a>
  
  
    <a href="/2019/08/11/linux/understanding_kernel/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">이전</strong>
      <div class="article-nav-title">커널의 이해와 시스템 콜 이해</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/custom-module/">custom module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fabric/">fabric</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/functional-programming/">functional programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-deploy/">hexo-deploy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pipenv/">pipenv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgresql/">postgresql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-module/">python module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-post/">python post</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/testing/">testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travel-note/">travel_note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tutorial/">tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그 클라우드</h3>
    <div class="widget tagcloud">
      <a href="/tags/c/" style="font-size: 11.43px;">c</a> <a href="/tags/custom-module/" style="font-size: 12.86px;">custom module</a> <a href="/tags/django/" style="font-size: 14.29px;">django</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/fabric/" style="font-size: 10px;">fabric</a> <a href="/tags/functional-programming/" style="font-size: 11.43px;">functional programming</a> <a href="/tags/hexo-deploy/" style="font-size: 10px;">hexo-deploy</a> <a href="/tags/http/" style="font-size: 11.43px;">http</a> <a href="/tags/linux/" style="font-size: 15.71px;">linux</a> <a href="/tags/network/" style="font-size: 11.43px;">network</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/pipenv/" style="font-size: 10px;">pipenv</a> <a href="/tags/postgresql/" style="font-size: 10px;">postgresql</a> <a href="/tags/project/" style="font-size: 10px;">project</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/python-module/" style="font-size: 17.14px;">python module</a> <a href="/tags/python-post/" style="font-size: 18.57px;">python post</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/testing/" style="font-size: 10px;">testing</a> <a href="/tags/travel-note/" style="font-size: 10px;">travel_note</a> <a href="/tags/tutorial/" style="font-size: 10px;">tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">아카이브</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">1월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">9월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">8월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">7월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">6월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">5월 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">최근 포스트</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/26/fastcamp/my_post/">test_post</a>
          </li>
        
          <li>
            <a href="/2019/09/17/http/2_http_sementics/">http_1.0_sementics</a>
          </li>
        
          <li>
            <a href="/2019/09/09/project/travel_note/">travel_note 서비스 고찰</a>
          </li>
        
          <li>
            <a href="/2019/09/06/http/1_http_1.0_basic_four_feature/">http/1.0의 신택스: 기본이 되는 네가지 요소</a>
          </li>
        
          <li>
            <a href="/2019/09/05/python/post/async_coroutine_5/">비동기 코루틴 번역-5-End</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 junehan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>