---
title: 비동기 코루틴 번역-2
p: translates/python/async_coroutine_2
date: 2019-06-19 18:11:02
tags: ['python', 'async', 'coroutine', 'translates']
---

## Coroutines
우리는 당신을 Promise로 유도하고 싶다. 
비동기처리에 대한 콜백을 과거 멀티쓰레딩 프로그래밍의 좋은 외관처럼 작성하는 것이 가능하다.
이 조합은 "Coroutine"이라는 패턴과 함께 얻을 수 있는 것이다.

```python
@async.coroutine
def fetch(self,url):
    respnse = yield from self.session.get(url) # 콜백의 첫 단계
    body = yield from response.read() # 연속적 이벤트에 대한 콜백
```
이것은 또한 스케일러블 하다. 멀티쓰레딩으로 작업하던 당시, 50K의 자원이 쓰레드를 생성하는데 들어갔었고, OS는 그것에 대해 엄격한 CAPs를 적용하고 있었다.\
그러나 파이썬의 코루틴은 거의 3K만을 차지하고 있고, 따라서 매우 쉽게 수십만개의 코루틴한 객체들을을 생성하고 실행할 수 있다.
****
- ### 코루틴에 대한 컨셉은 아주 쉽다!!? (고전적인 컴퓨터 과학과 비추어 봤을때...)
그것은 서브루틴이며 멈출 수 있고 다시 진입 할 수 있다.

반면에 쓰레드는 우선적으로 OS에 의해 멀티테스킹 되어진다.
그것은 파이썬의 프라이빗 힙 중 스텍프레임에 직속으로 할당되는 프레임들이기에, 기존의 메인 쓰레드를 중심으로 생성된 쓰레드가 스텍프레임으로서 레벨에 존재한다.

개별적으로 이전의 공유자원에 대해 접근할 수 있지만, **Race condition**이 발생할 수 있고,\
프로그래머 레벨에서 **MUTEX(Mutual exclusion)** 처리로 핸들링을 해주거나,
> MUTEX는 기본적으로 작동원리의 레벨이나, 그 기저에 위치한 것이 아니라, 업무의 할당이라는 개념으로 로직-코드레벨에서 직접 제어하는 것이다.

세마포어 기법을 통해 멀티프로그래밍 환경에서 실행자들이 임계구역(공유자원)에 접근하기 전에 각각 전처리, 후처리 등을 추가하는 방법이 있다.

그러나 코루틴은 자신이 서브루틴으로서 직접 언제 멈출지, 이후 어떤 코루틴을 실행할 지 선택할 수 있다.\
코루틴에 대한 많은 실행법이 있지만, ("파이썬만 해도 여러가지를 가지고 있다!")

1. 스탠다드 라이브러리 "asyncio"에 있는 코루틴들은 제너레이터를 기반으로 만들어져 있다
2. Future class
3. `yield from CALLBACK_on_Socket_connected()`

yield 하는 싱글 스레드의 주도권은 일시적을 해당 제너레이터로 넘어간다.\
yield from 을 통해 외부 Global frame에서 전달받은 것은 자신의 프레임 내부로 가져온다.\
routine과 위와 같은 방식으로 소통한다.

python.exe입장에서는 자신의 프로세스가 늘어나는것도, 공식적인 쓰레드가 늘어나는 것도 아니어서, OS에 대해서 영향을 주는 것이 아니다.\
그저 자신의 기존 스텍에 대해서 혼란을 주지 않고, 힙에 있는 가스텍을 메인스텍으로 대체한다는 개념에 더욱 가깝다.

파이썬 3.4의 제너레이터기반 코루틴을 설명하기 위해, 제너레이터를 자세히 살펴보고, 어떻게 그들이 asyncio에서 코루틴으로 사용되는지 알아볼 것이다.