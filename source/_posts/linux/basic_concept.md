---
title: basic concept of linux / about file
p: linux/basic_concept
date: 2019-08-12 10:09:52
tags: ["linux"]
---

## Index

> 파일과 프로세스, 파이프와 소켓을 다루기 위한 추상적 인터페이스 등이 유닉스의 핵심.
___

1. [**file**][i1]
   1. [**select 시스템 콜**][i1-1]
1. [**일반 파일**][i2]
1. [**디렉터리와 링크**][i3]
   1. [**하드 링크**][i3-1]
   1. [**심볼릭 링크**][i3-2]
1. [**특수 파일**][i4]

## 파일

[i1]: #파일

파일은 리눅스에서 가장 기본적이고 핵심이 되는 추상화 개념  

> ### 리눅스에서는 모든 것이 파일이다

1. 파일에 접근하려면 먼저 파일을 열어야 한다.  
파일은 읽기, 쓰기 모드 등으로 열 수 있고, 이렇게 열린 파일은,  
해당 파일에 대한 메타데이터와 연결된 고유한 기술자(**descriptor**)를 통해 참조될 수 있다.
1. 파일 디스크립터는 사용자 영역에서 공유되며, 응용프로갬이 파일에 접근할 떄 직접 사용.

따라서,

* 리눅스 프로그래밍의 대부분은 바로 이 파일 디스트립터(fd)를 열고 조작하고 닫는 작업이다.
* 파일 디스크립터는 정수로 표현된다.
  
### C의_select함수

[i1-1]: #c의_select함수

* 동기적 통신

```python
sock = socket.socket()
request = "GET {} HTTP/1.0\r\nHOST: xkcd.com\r\n\r\n".format(url)
encoded = request.encode("ascii")

while True:
    try:
        sock.send(encoded) # blocking 발생
        break # Done
    except OSError as e:
        pass

print("sent")
```

이 메서드는 `IO wait`에 의해 단순히 전력을 낭비할 뿐만 아니라해 효과적으로 다수의 소켓에서 이벤트를 대기하는 것도 할 수 없다.  
고전적인 방법으로 **BSD Unix**의 해결책은 `select`였다.  
C함수이고, 그것은 Nonblocking소켓 또는 small array를 그들에게서 부터 기다릴 수 있다.

요즘에는 인터넷 어플리케이션이 무지막지한 연결수를 초래하여서 `poll`보다는,  
BSD의 `kqueue`, Linux의 `epoll`로 대체하게 되었다.  
이들은 `select`와 비슷한 동작을 가지고 있지만 다수의 연결을 잘 해결해 낸다.

파이썬 3.4의 `DefaultSelector`이 당신의 OS중에 가능한 최고의 `select`같은 함수를 사용한다.

`network I/O`에 대한 인터럽션에 대응하는 알림을 등록하기 위해서

1. 우리는 논블로킹 소켓을 생성하고,
2. 이것을 DefaultSelector에 등록한다.

```python
from selectors import DefaultSelector, EVENT_WRITE

selector = DefaultSelector()

sock = socket.socket()
sock.setblocking(False)
try:
    sock.connect(("xkcd.com", 80))
except BlockingIOError:
    pass

def connected():
    seletor.unregister(sock.fileno())
    print("connected!")

selector.register(sock.fileno(), EVENT_WRITE, connected)
# sock.fileno()가 네트워크 소켓에 대한 파일 디스크립터(정수)로 자동 생성되고 할당된다.
```

* DefaultSelector() : select함수와 같은 역할
  * 소켓을 생성하면 파일 디스트립터(IO wait, Read, write)가 1:1관계로 자동 생성된다.
  * 소켓과 매핑된 **파일디스트립터**를 등록하고, 해당 파일에 대해 이벤트를 감지하면 약속된 행동을 개시한다.
  * `select`함수는 비동기 소켓에 대해 또 다른 파일을 등록해 해당 파일 디스크립터에 대해 특정 이벤트를 감시하는(해당 인터럽션이 중요하다고 여기는 것) 약속을 등록하고 해제해준다.(이 또한 파일)

___

## 일반파일

[i2]: #일반파일

일반 파일은 바이트 스트림이라 불리는 연속적으로 나열된 바이트 배열에 저장된 데이터를 의미한다.  

* **파일 디스크립터**
  * 정수로 특정 파일에 대한 METADATA가 담긴 프로세스의 특수 메모리주소를 가리킨다.
* **파일 읽기**
  * 해당 파일 디스트립터가 가르키는 메타데이터의 inode의 오프셋(bytes)만큼 나열된 연속적 데이터(byte-array)를 가져온다.

리눅스에는 파일을 위한 특별한 자료구조가 없다. 따라서 어떠한 값이가도 들어갈 수 있다.  
시스템수준에서 살펴보면 리눅스는 **바이트 스트림**외어 어떤 자료구조도 강제하지 않는다.

파일이 처음 열리면 file-offset은 0이다.

직접 파일 오프셋을 지정할 수 도 있는데, 파일 끝을 넘길 수도 있다.  
파일 크기를 넘어 바이트를 기록하면 파일 끝에서 지정한 위치가 시작하는 부분까지 내용은 모두 0이 된다.

> 파일을 쓰는 작업은 대부분 파일 끝에서 일어난다.  
> 파일 오프셋의 최댓값은 오프셋을 저장하기 위해 사용하는 C타입의 크기로 결정된다.  
> 최신리눅스에서는 64비트 값이다.

하나의 파일은 다른 프로세스나 동일한 프로세스에서 한 번이상, 혹은 동시에 열려질 수 있다.  
그들은 열릴때마다 고유한 파일 디스크립터를 반환한다.  
프로세스에서는 따라서 파일 디스트립터를 공유할 수 있다.

**커널은 파일에 대한 동시 접근을 막지 않는다.**  

일반적으로 파일 이름을 통해 파일에 접근하지만,  
실제로 파일은 `inode(information node)`라 하는 파일시스템의 고유한 정수값으로 참조 된다.

> `Inode` 의 구성
>
> 1. 변경된 날짜
> 2. 소유자
> 3. 타입
> 4. 길이
> 5. 물리 데이터 저장 위치

파일이름은 저장하지 않는다.  
`inode`는 유닉스 파일 시스템에서 디스크에 저장된 물리적 객체임과 동시에,  
리눅스 커널에서 자료구조로 표현되는 논리적인 개념이기도 하다.
___

## 디렉터리와_링크

[i3]:#디렉터리와_링크

inode번호로 파일에 접근하면 보안위협이 있어서, 파일 이름을 사용한다.  
디렉터리는 파일에 접근하기 위한 이름을 제공하는데, 이 이름과 inode의 Pair를 `Link`라고 한다.

개념적으로 디렉터리는 일반파일과 유사한 모습이지만 데이터가 존재하지 않는다.

|type|name|data|
|:-|:-|:-|
|directory|in directory|file's namespaces|
|file|in directory|as inode|
|inode|no|file location, offset, elses|

실제 디렉터리도 inode가 있다. 따라서 디렉터리 내부의 링크 역시 다른 inode를 가질 수 있다.  
즉, 디렉터리는 계층적인 구조를 형성할 수 있게 된다.

이를 이용하여 `/home/sample/data.png`처럼 파일 경로를 사용할 수 있는 것이다.

`/home/sample/data.png`같은 경로로 파일을 열겠다고 요청하면,
1. 해당 파일 경로에 속한 각 디렉터리 엔트리 (called as `dentry` by kernel)를 탐색하여 다음 항목의 inode를 찾음.
2. `/`로 시작, `sample`디렉터리의 inode를 찾는다.
3. `sample.png`의 inode를 얻는다.

리눅스 커널은 `dentry` 캐시를 활용하여 찾기 결과를 저장하고 나중에 **일시적인 지역성**을 이용해 탐색속도를 높인다.

> 지역성(locality) : 한번 접근한 데이터의 근처의 데이터에 또 접근하는 경우가 많다.

비록 디렉터리도 inode가 있고 네임이 있으니, 일반 파일처럼 취급하지만,  
커널은 사용자 영역에서 디렉터리를 일반 파일처럼 열고 조작하지 못하도록 제한한다.  
따라서 디렉터리는 특수한 시스템 콜을 통해 조작해야하는데, 이를 위한 시스템 콜은 아래와 같다.

1. 링크 추가
2. 링크 삭제

사용자 영역에서 커널의 중제없이 디렉터리를 조작할 수 있게 하면, 조그만 오류가 발생해도 파일시스템 전체를 망가뜨릴 수 있다.
___

### 하드_링크

[i3-1]:#하드_링크

|type|origin|name|linkto|
|:-|:-|:-|:-|
|hard link|A|h_link_A|A's inode|
|hard link|A|h_link_B|A's inode|
|symbolic link|B|B_link_A|B's inode|
|symbolic link|B|B_link_B|B_link_A's inode|

다른 이름으로 동일한 inode를 가르키지 못하게 하는 방법은 없다.  
다중 링크는 동일한 inode를 여러가지 이름으로 맵핑한다. 이를 **하드링크**라 한다.

동일한 inode에 대한 다수의 하드링크에 대해서 커널은 1회의 실행을 통해 원본의 inode를 알아낸다.

따라서 해당 원본에 대한 하드링크가 늘어난다면? 그만큼 `Referencing counter`이 늘어난다.  
원본을 지워도 원본의 inode를 가지고 있는 Referencing이 살아 있기 때문에, 해당 inode의 데이터는 삭제되지 않는다.

> 링크 카운터가 0이 되는 순간 비로소 해당 inode가 포함하는 자료가 실제로 삭제된다.
___

### 심볼릭_링크

[i3-2]:#심볼릭_링크

심벌릭 링크는 최종 엔드포인트가 origin의 inode를 가르키고 있지만, 독자적인 inode값을 가지게 된다.  
그래서 일반 디렉터리처럼 달리 독자성을 가지고 있기 때문에, 파일처럼 생겼다.  

1. 하드 링크보다 심볼릭 링크가 결론적으로 오버헤드를 많이 가져오는 이유는,  
심벌릭 링크를 효과적으로 탐색하기 위해,  
해당 링크와 그 링크로 연결된 파일 둘다 다뤄야 하기 때문이다.

1. 하드링크에서 추가적인 오버헤드가 발생하지 않는 이유는,  
파일 시스템에서는 링크가 둘 이상 걸린 파일에 접근하거나,  
하나만 걸린파일에 접근하거나 구현상 차이가 없기 때문이다.  

1. 심벌릭 링크가 단일로서는 오버헤드가 매우 작지만,(원본 레퍼런스의 couter을 늘리지 않는 점등에서,)  그래도 부정적인 것으로 취급받고 있다.

1. 하드링크는 사용자 입장에서 봤을떄 원본 주소 그 자체이기 때문에, 완전히 투명하다.

1. 그러나 실제로 2번 이상 링크된 파일을 찾아내는 작업이 더 어렵다.
1. 반면 심볼릭 링크를 조작하려면 특수 시스템 콜이 필요하다.  
이런 투명성 결여는 심벌릭 링크가 명료하게 생성되며, 파일시스템내부 링크가 아닌,  
일종의 바로가기 처럼 사용되기 떄문에,
종종 장점으로 작용하기도 한다.

___

## 특수_파일

[i4]:#특수_파일

정의

* 파일로 표현되는 커널 객체

종류

1. 캐릭터 디바이스 파일
2. 블록 디바이스 파일
3. 네임드 파이프
4. 유닉스 도메인 소켓

특수 파일은 모든 것이 파일이라는 유닉스 철학에 맞게,  
파일 시스템 위에 구현된 추상화 개념이며 리눅스는 특수파일을 생성하는 시스템 콜을 제공한다.

### 하드웨어 장치를 추상화하는 디바이스 파일

> 하드웨어 장치마다 특수 디바이스파일이 존재한다.  
> 장치의 종류가 같다면 같은 인터페이스의 드라이버를 사용한다.  
> 특수 파일은 개별적이나 종류가 같다면 같은 인터페이스를 사용.

1. **캐릭터 디바이스 파일**

    디바이스 드라이버는 큐에 바이트를 하나씩 집어 넣고, 사용자 영역에서는 큐에 쌓인 순서대로 바이트를 읽어낸다.

    대표적인 예: 키보드

    1. 사용자가 'peg'라고 입력
    2. 애플리케이션은 키보드 드라이버 인터페이스를 통해 디바이스 파일에서 p, e, g 를 순서대로 읽음.
    3. 읽을 문자 없을 시 `EOF(End of Line)`을 반환.

2. **블록 디바이스 파일**

    반면 블록 디바이스는 바이트 배열로 접근한다. 보통 저장장치를 말하는데,  
    위치 지정이 가능한 장치에 여러 바이트를 맵핑해,  
    사용자 영역에서는 이 배열이 포함하고 있는 유효한 바이트에 임의 접근할 수 있다.  
    (하드 디스크 드라이브, 플로피 드라이브, CD-ROM드라이브, 플래시 메모리)

    대표적인 예: HDD

    1. 12바이트를 읽음
    2. 7바이트 읽음
    3. 12바이트 읽음

    블록 디바이스의 최소 접근 단위는 `섹터`이다.  
    섹터는 디바이스의 물리적인 속성며 2의 승수로 나타내며 512가 가장 일반적이다.  
    블록 디바이스는 섹터보다 더 작은 데이터 단위를 전송하거나 접근하지 못한다.  
    따라서 모든 입출력은 섹터 하나를 가져오는 것 혹은 보내는 것을 기준으로 일어난다.

3. **네임드 파이프**

    FIFO로 부르기도 한다.  
    `IPC(Inter Process Communication)`메커니즘으로 특수파일을 읽고 쓰는 파일 디스크립터 형태로 통신 채널을 제공한다.

    일반 파이프는 특정 프로그램 출력을 자신의 입력으로 잇는 것처럼, 다른 프로그램 입력으로 연결하기 위한 방법이다.

    > 시스템 콜로 만들어지는 일반 파이프는 파일 시스템이 아니라 메모리에 존재한다.

    네임드 파이프는 일반 파이프와 동일하게 동작하지만, `FIFO`라는 특수 파일을 거쳐 접근한다.  
    서로 무관한 프로세스도 이 파일에 접근하는 방식으로 프로세스 사이에 통신이 가능해진다.

4. **소켓**

    소켓은 다른 프로세스끼리 통신할 수 있는 고급 `IPC`의 한 종류이며, 다른머신과의 통신도 가능하다는 점이 다르다.  
    > 소켓은 네트워크와 인터넷 프로그래밍의 근간.

    로컬 머신 내부에서 통신을 위해 사용하는 소켓형태인 유닉스 도메인 소켓을 포함하여, 많은 변종이 있다.  

    1. 인터넷에서 통신하는 소켓은 IP를 파악하기위해 `host name`, `port`를 사용.
    2. 유닉스 도메인 소켓은 파일 시스템에 만들어진 소켓파일(특수 파일)을 사용한다.

___

### 파일 시스템

* 접근단위

    블록에서 최소 접근 단위가 `섹터`라면 파일 시스템에서의 논리적 최소 접근단위는 `블록`이다.

* 블록

    블록은 파일시스템을 추상화한 개념으로 파일시스템이 존재하는 물리매체와 무관하다.  
    블록은 보통 섹터크기의 2의 승수이다.
    >따라서 일반적으로 섹터보다 더 크지만, 페이지 크기 보다는 작다.  
    > 페이지 크기: 하드웨어 메모리 관리 유닛에서 지정 가능한 최소 단위

    보통 블록 크기는 512, 1024, 4096 바이트다.

