<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Junehan&#39;s workbook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="with python and javascript, could be some descriptions or workflow writtens for project">
<meta name="keywords" content="python django">
<meta property="og:type" content="website">
<meta property="og:title" content="Junehan&#39;s workbook">
<meta property="og:url" content="https://codenamenadja.github.io/index.html">
<meta property="og:site_name" content="Junehan&#39;s workbook">
<meta property="og:description" content="with python and javascript, could be some descriptions or workflow writtens for project">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Junehan&#39;s workbook">
<meta name="twitter:description" content="with python and javascript, could be some descriptions or workflow writtens for project">
  
    <link rel="alternate" href="/atom.xml" title="Junehan&#39;s workbook" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junehan&#39;s workbook</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">work flow and descriptions</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="검색"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://codenamenadja.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-fastcamp/my_post" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/26/fastcamp/my_post/" class="article-date">
  <time datetime="2021-01-26T01:09:17.000Z" itemprop="datePublished">2021-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/26/fastcamp/my_post/">test_post</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="my-test-hexo"><a class="markdownIt-Anchor" href="#my-test-hexo"></a> My Test Hexo</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">"Hello WOrld!"</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">f"<span class="subst">&#123;message&#125;</span>"</span>) <span class="comment"># print가 리턴하는 것이 무엇인가?</span></span><br><span class="line"></span><br><span class="line">exit()</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2021/01/26/fastcamp/my_post/" data-id="ckkdb52ey00001pqk06c7kqzd" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo-deploy/">hexo-deploy</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tutorial/">tutorial</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-http/2_http_sementics" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/17/http/2_http_sementics/" class="article-date">
  <time datetime="2019-09-17T14:09:02.000Z" itemprop="datePublished">2019-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/17/http/2_http_sementics/">http_1.0_sementics</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> index</h2>
<ol>
<li><a href="#simple_form_transportation"><strong>Simple Form Trasportation: 간단한 폼 전송</strong></a></li>
<li><a href="#file_transport_with_form"><strong>File trasnport with form: 폼을 통한 파일 전송</strong></a></li>
</ol>
<h2 id="simple_form_transportation"><a class="markdownIt-Anchor" href="#simple_form_transportation"></a> Simple_form_transportation</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client</span></span><br><span class="line">curl --http1.0 -d title=<span class="string">"art of..."</span> -d author=<span class="string">"jono"</span> http://127.0.0.1:18888/</span><br><span class="line"></span><br><span class="line"><span class="comment"># server</span></span><br><span class="line">Content-Length: 27</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">User-Agent: curl/7.58.0</span><br><span class="line"></span><br><span class="line">title=art of...&amp;author=jono</span><br><span class="line"></span><br><span class="line"><span class="comment"># httpclient</span></span><br><span class="line">http http://127.0.0.1:18888/ username=sample password=asdqrfrg -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># server</span></span><br><span class="line">Content-Length: 33</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=utf-8</span><br><span class="line">User-Agent: HTTPie/0.9.8</span><br><span class="line"></span><br><span class="line">username=sample&amp;password=asdqrfrg</span><br></pre></td></tr></table></figure>
<p>위 커맨드로 처리하는 바디는 브라우저의 웹폼과는 달리 지정된 문자열의 특수문자를 변환없이 그대로 연결한다.<br>
<code>RFC 1866</code>에서 책정한 변환 포멧에 따라,</p>
<ul>
<li>알파벳</li>
<li>숫자</li>
<li>별표</li>
<li>하이픈</li>
<li>마침표</li>
<li>언더스코어</li>
</ul>
<p>의 종류 외 문자는 변환이 되어 아래와 같은 형식이 된다.</p>
<p><code>title=Head First PHP &amp; MySQL&amp;authre = Lynn Beighley, Micheal Morrison</code><br>
<code>title=Head+First+PHP+%26+MySQL&amp;author=Lynn+Beighley%2C+Micheal+Morrison</code></p>
<p>curl커맨드에서는 <code>--data-urlencode</code>옵션을 통해서 <code>RFC 3986</code>에 정의된 방법으로 변환한다.<br>
이 경우에는 <code>RFC 1866</code>과 달리 공백이 <code>+</code>가 아닌 <code>%20</code>으로 처리한다.</p>
<hr>
<h2 id="file_transport_with_form"><a class="markdownIt-Anchor" href="#file_transport_with_form"></a> File_transport_WITH_form</h2>
<p>HTML Form에서 <code>multipart</code>라는 폼 형식 인코딩 타입을 통해서, 파일을 전송할 수 있다.<br>
이는  <code>RFC 1867</code>에 정의된다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"mulitpart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>HTTP응답은 한번에 한 바디만 반환하므로, 빈줄로부터 <code>Content-Length</code>바이트 만큼 읽어내면 종료된다.<br>
하지만 멀티파트를 통하는 경우 한번의 요청으로 복수의 파일의 경계를 받는쪽에서 처리해야 한다.</p>
<p><code>Content-Type</code>은 모두 <code>multipart/form-data</code>이지만, 또 하나의 속성인 경계 문자열이 있다. 각 따라 독자적인 포멧으로 랜덤하게 생성한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=---WebKitFormBoundaryy0YfbccgoID172j7</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryy0YfbccgoID172j7</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"title"</span></span><br><span class="line"></span><br><span class="line">The Art of Community</span><br><span class="line">------WebKitFormBoundaryy0YfbccgoID172j7</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"author"</span></span><br><span class="line"></span><br><span class="line">Jono Bacon</span><br><span class="line">------WebKitFormBoundaryy0YfbccgoID172j7</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:18888</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 2719</span><br><span class="line">Content-Type: multipart/form-data; boundary=--------------------------925161045727238542287839</span><br><span class="line">Postman-Token: cd5fc7b3-3090-4cc7-921e-223c3defc0a5</span><br><span class="line">User-Agent: PostmanRuntime/7.6.0</span><br><span class="line"></span><br><span class="line">----------------------------925161045727238542287839</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">""</span>; filename=<span class="string">"3_8_buffer_io.c"</span></span><br><span class="line">Content-Type: text/x-c</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *<span class="keyword">in</span>, *out;</span><br><span class="line">    struct pirate</span><br><span class="line">    &#123;</span><br><span class="line">        char name[100];</span><br><span class="line">        unsigned long booty;</span><br><span class="line">        unsigned int beard_len;</span><br><span class="line">    &#125;;</span><br><span class="line">    struct pirate p;</span><br><span class="line">    struct pirate blackbeard = &#123;<span class="string">"Edward Teach"</span>, 950, 48&#125;;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------925161045727238542287839</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">""</span>; filename=<span class="string">"sample.txt"</span></span><br><span class="line">Content-Type: application/javascript</span><br><span class="line"></span><br><span class="line">sample file_2 content-data</span><br><span class="line">----------------------------925161045727238542287839--</span><br></pre></td></tr></table></figure>
<p>curl에서는 <code>-d</code> 대신 <code>-F</code>를 사용하는 것만으로 enctype=&quot;multipart/form-data&quot;로 설정한다.</p>
<p><code>curl --http1.0 -F &quot;attachment-file@test.txt;filename=sample.txt;type=text/html&quot; http://127.0.0.1:18888/</code></p>
<ul>
<li>filename과 type은 메뉴얼하게 지정하며, 내용은 text.txt에서 취득한다.</li>
</ul>
<h2 id="content-negotiation"><a class="markdownIt-Anchor" href="#content-negotiation"></a> Content-Negotiation</h2>
<ul>
<li>컨텐츠 협상에 사용되는 대상과 헤더</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Header</th>
<th style="text-align:center">Response</th>
<th style="text-align:center">Negotiation-Target</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept</td>
<td style="text-align:center">Content-Type 헤더</td>
<td style="text-align:center">MIME 타입</td>
</tr>
<tr>
<td style="text-align:left">Accept-Language</td>
<td style="text-align:center">Content-Language 헤더 / html 태그</td>
<td style="text-align:center">표시 언어</td>
</tr>
<tr>
<td style="text-align:left">Accept-Charset</td>
<td style="text-align:center">Content-Type 헤더</td>
<td style="text-align:center">문자의 문자셋</td>
</tr>
<tr>
<td style="text-align:left">Accept-Encoding</td>
<td style="text-align:center">Content-Encoding 헤더</td>
<td style="text-align:center">바디 압축</td>
</tr>
</tbody>
</table>
<h3 id="파일_종류_결정"><a class="markdownIt-Anchor" href="#파일_종류_결정"></a> 파일_종류_결정</h3>
<p><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</code></p>
<ul>
<li><code>image/webp</code></li>
<li><code>*/*;q=0.8</code></li>
</ul>
<p>q는 우선순위르 나타내는 품질 계수로 0~1사이 수치로 표현되며, 기본값은 1.0으로 이때는 생략된다.<br>
웹서버가 <code>Webp</code>(“구글이 권장하는 PNG보다 20%절약 포멧”)를 지원하면 webp를,<br>
그렇지 않으면 PNG등 다른 포멧(q=0.8)을 서버에 보낼 것을 요구한다.</p>
<p>서버는 Request에서 요구한 형식중에서 파일을 반환.<br>
우선 순위를 해석해, 위에서부터 차례로 지원하는 포멧을 찾고, 그 포멧을 반환한다.<br>
만약 일치하는 형식이 없으면 서버가 <code>406 NOT Acceptable</code>을 반환한다.</p>
<h3 id="표시_언어_결정"><a class="markdownIt-Anchor" href="#표시_언어_결정"></a> 표시_언어_결정</h3>
<p><code>Accept-Language: en-US,en;q=0.8,ko;q=0.6</code></p>
<ol>
<li>en-US</li>
<li>en</li>
<li>ko</li>
</ol>
<p>순의 우선순위로 요청 헤더를 보낸다.</p>
<h3 id="문자셋_결정"><a class="markdownIt-Anchor" href="#문자셋_결정"></a> 문자셋_결정</h3>
<p><code>Accept-Charset: windows-949,utf-8;q=0.7,*;q=0.3</code></p>
<p>현재는 어떤 브라우저도 <code>Accept-Charset</code>헤더를 송신하지 않는다.<br>
대부분 브라우저가 문자셋 인코더를 내장하고 있어, 대부분의 문자를 처리할 수 있기 때문이다.<br>
문자셋은 MIME타입과 세트로 Content-Type헤더에 실려서 전달된다.</p>
<p><code>Content-Type: text/html; charset=UTF-8</code></p>
<p>HTML의 경우 문서 안에 쓰기도 한다. <code>RFC 1866</code>의 HTML/2.0으로 이용할 수 있다.<br>
HTML을 로컬에 저장했다가 다시 표시하는 경우도 많으므로, 이용된다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>http-equiv태그는 HTTP헤더와 똑같은 지시를 문서 내부에 삽입해서 반환하는 상자.<br>
HTML5의 경우, 아래와 같이 표기 가능하다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/09/17/http/2_http_sementics/" data-id="ckkdb52fb00051pqkrnwq01vc" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-project/travel_note" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/09/project/travel_note/" class="article-date">
  <time datetime="2019-09-09T06:10:16.000Z" itemprop="datePublished">2019-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/09/project/travel_note/">travel_note 서비스 고찰</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> index</h2>
<ol>
<li><a href="#mvp"><strong>main mvp</strong></a></li>
<li><a href="#model"><strong>model</strong></a></li>
</ol>
<h2 id="mvp"><a class="markdownIt-Anchor" href="#mvp"></a> MVP</h2>
<ol>
<li>여행후기를 공유한다</li>
<li>작성 시기</li>
<li>제주도 (지역, 인원, 필터링)</li>
<li>독자적인 SNS Follow. Follow한 유저가 구독</li>
</ol>
<p>경험</p>
<ol>
<li>로그인</li>
<li>지역선택(성향선택최초 1회)</li>
<li>관심사(후에 여행 태그 기반 추천 검색)</li>
</ol>
<p>메인 페이지</p>
<ol>
<li>(Favorite Places)</li>
<li>친구들 후기(New from friends)</li>
<li>예산에 맞는 추천</li>
<li>Popular</li>
</ol>
<p>검색 필터</p>
<ol>
<li>지역, 금액, 태그, 본문(키워드)&gt;타이틀(찰워드) 3:1</li>
</ol>
<h2 id="model"><a class="markdownIt-Anchor" href="#model"></a> model</h2>
<h3 id="location"><a class="markdownIt-Anchor" href="#location"></a> location</h3>
<ul>
<li>location.country</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">name</th>
<th style="text-align:center">travel_ids</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">USA</td>
<td style="text-align:center">3,5,7[one to many(travels)]</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">France</td>
<td style="text-align:center">1,2,4[one to many(travels)]</td>
</tr>
</tbody>
</table>
<ul>
<li>location.spot</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">name</th>
<th style="text-align:center">country_id</th>
<th style="text-align:center">day_ids</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">effel_tower</td>
<td style="text-align:center">2[related name]</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<ul>
<li>유저</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">email</th>
<th style="text-align:center">gender</th>
<th style="text-align:center">likes</th>
<th style="text-align:center">interests</th>
<th style="text-align:center">planings</th>
<th style="text-align:center">travels</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><a href="mailto:sample@facebook.com" target="_blank" rel="noopener">sample@facebook.com</a></td>
<td style="text-align:center">True</td>
<td style="text-align:center">one to many(tags)</td>
<td style="text-align:center">one to many(location.country)</td>
<td style="text-align:center">one to many()</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<ul>
<li>여행
<ul>
<li>태그</li>
<li>스팟(여정에 대한 기념, 상징적인 장소 개념, 날짜별로 4개정도는 가능하다.) 스팟은 사실 검색용도로 사용되고, 다른 의미는 없다?</li>
<li>금액
<ul>
<li>날짜, 분류, 디테일(숙박, 1일자, 무슨호텔/ 식음료, 1일자, 무슨음식)</li>
</ul>
</li>
<li>총 교통수단에 대한 요금(Transportation)</li>
<li>Accomodation(Hotel)</li>
<li>Expenditure(일반 소비), 화폐에 대한 기준 달러화</li>
<li>Post(사진과 글)</li>
</ul>
</li>
<li>마이페이지
<ul>
<li>팔로잉, 팔로워수</li>
<li>나의 여행들</li>
</ul>
</li>
</ul>
<h2 id="고찰"><a class="markdownIt-Anchor" href="#고찰"></a> 고찰</h2>
<h3 id="190911"><a class="markdownIt-Anchor" href="#190911"></a> 190911</h3>
<p>가입할때 interests로 등록하는 목록(activity, food, relax, tradition, shopping, festival)</p>
<p>day.tags(어떤 날의 주요 액티비티 종류)<br>
travel.tag(여행의 주 목표)</p>
<p>지역에 대해서 검색할때, 기본적으로 travel이라는 패키지를 출력하지만, 유저의 취향에 맞춰서 키워드 기반으로 유저의 관심 안에 있는 활동을 한 날이 있다면?<br>
특정 날만 별도 뷰로 전달해줄 필요가 있다.<br>
애초에 매칭률이 높다면, 특정 키워드가 컨텐츠에 등장한다? 텍스트의 키워드 검색을 어플리케이션에 맞기고(정렬), tag가 어떤날에 부합하면서, 키워드가 등장하고,</p>
<p>내가 등록한 정보로 어떤 의미있는 데이터를 가져올 수 있을 것인가?<br>
내 취향과 유사한 사람들이 어떤 선택을 하는지 참고하고 싶어한다,<br>
나와 같은 성향. (1~2명이라면 신경쓰지 않지만, 나와 같은 성향으로 그나라에 대한 여행 정보를 등록해준 동성 100명의 통계가 이러한데 이렇다. 그리고 거기서 만족도가 높았다.)</p>
<p>왜 평가가 높았는지 정확한 디테일을 캐치하는 것은, 표본중에 랜덤하게 선택하여 유저가 직접 검토하는 것이 맞다.</p>
<p>평가가 높았던 날에 키워드에서 장소에 대한 키워드를 수집해서, 처리하는 것.<br>
어느 스팟이 들어간 곳이 통계적으로 평가가 높았다.<br>
통계라고 하면 100명이서 통합 4점과, 30명이서 4.3점이라면, 100명이서 4점을 더 좋게</p>
<p>하지만, 나와 같은 취향을 선별한다면, 좀 더 유저가 원하는 정보에 가까울 수…</p>
<p>나와 같은 성향.</p>
<p>만족도는 어떻게 체크 할 것인가?<br>
사실 디테일하게 처리하기 위해선, 그 날짜에 대한 전반적인 점수가 높다라는 것으로?<br>
만족도를 어떻게 체크해야 간편하면서, 구체적일 수 있을까?<br>
1,2 평하<br>
3 평중<br>
4,5 평상</p>
<p>사람들이 통계적으로 봤을때, 1~5점으로 매긴다고 하면은, 정말 너무 행복했던 기억만을 가졌던 날을 누군가 있었다면, 정말 흔치않지만, 5점일 것이고<br>
대게 좋았거나, 비교적 순탄했다면 4점을 매길것이다<br>
새롭지 않고, 문제 없었다면 3점이고<br>
기분 안 좋은 일이 있었다면, 1~2점</p>
<p>나와 같은 성향은 어떻게 진단 할 것인가?<br>
interests와 budgets이 어떤 나라에대해서 맞는 사람들이 다녀온 여행.<br>
budgets 항공료를 제외한, 남녀에 맞춰서.</p>
<p>통계정보를 통해서, 사용자가 어떤 선택을 긍정적으로 검토 할 수 있도록 유도하는 것.</p>
<h2 id="190914"><a class="markdownIt-Anchor" href="#190914"></a> 190914</h2>
<p>첫번쨰 즐거움은 작성하는 즐거움을, 자신이 작성한 것이,</p>
<ol>
<li>한 눈에 보기 쉽고 작성하기 쉬우면서</li>
<li>작성할때 너무 어렵지 않게,</li>
<li>언제든 세부적으로 검토하는 것도 가능하지만,</li>
<li>모드조정을 통해 간략한 글쓰기, 세부적으로 글쓰기</li>
</ol>
<ul>
<li>간단한 여행일지 쓰기.(1장의 사진, 1~2줄의 글)</li>
</ul>
<ol>
<li>사진 하나, 타임라인, 엽서에 사진과 쪽지가 붙어있는.</li>
<li>그것을 다시 봤을떄, 누구나 이해할 수 있도록 돌려주려면?</li>
<li>엽서들을 어떤식으로?</li>
<li>여행 중에는 간단히 사진한장을 찍으면, 그곳의 위치와 지역시간을 기록하고. 간단한 메세지(노천카페에서 누구와)</li>
<li>그것들을 모아서 스팟에 등록하면,</li>
<li>시간 별로 스팟에 대한 시퀸스를 만들어준다.</li>
<li>지역이 이전 사진지역과 500m근방이거나, 30분 이하의 기록이라면 자동으로 하나의 스팟으로 자동 처리해주고(예를 들어 길거리 여러 상점을 들린다거나?)</li>
<li>그날 여행의 종료했을떄, 스팟의 최초 등록된 포스트의 위치(~거리 단위로)가제목을 붙여주고, 실제목은 따로 없으나,</li>
<li>유저가 직접 수정해서 스팟내의(시퀸셜한 여정(여행중에는 20분에 한장정도는 자주 찍는 편이라고 한다면))</li>
<li>그것을 파일로 처리해서 인쇄물로 받아볼 수 있도록.</li>
<li>물리적인 기록물과 연결된 것으로 처리하고, 디지털정보도 같이 보관할 수 있도록</li>
<li>그래도 3~5시간 내로는 보통 스팟을 벗어난다고 가정할 수 있다.</li>
<li>최초 스팟에서 1km이상 벗어났다면, 혹은 스팟을 전환하고 싶을 때 메뉴얼하게 전환하면, 해당 포스트를 기점으로 스팟을 처리해준다.</li>
</ol>
<ul>
<li>디테일한 여행일지 쓰기.(소설 형식)</li>
</ul>
<ol>
<li>가끔 좀 더 디테일한 기록을 남기는 사람들이 있다.</li>
<li>우리의 대화의 양상이라거나, 그날 분위기가 어땠지만, 난 기분이 좋지 않았다 라거나. 소설 쓰듯이 일지를 작성하는 스타일</li>
</ol>
<ul>
<li>디테일한 여행일지 쓰기_v2(여러 사진과 4~5줄의 글이 더 많은경우.)</li>
</ul>
<ol>
<li>앞의 사람들에 비하면, 사진에 대해서 중요시 생각하는 타입.</li>
<li>디바이스를 조금 더 생각해보면, 사진기능이 좋아지고, 한장의 사진이 특정 부분만 클립으로 재생되고 나머지는 하나의 프레임으로 가진 GIF파일도 있다.</li>
<li>하나의 포스트에 많은 사진을 저장하지 말고 시퀸스를 풍부하게 구성하세요.(이 정도 규칙은 유저들이 충분히 수용 할 수 있을 만한 범위)</li>
<li>당신이 사진가라는 것을 우리가 존중하지 않는 것은 아니지만, 서버에 RAW파일을 저장할 순 없잖아요? 아직 21세기는 시작했을 뿐입니다.</li>
</ol>
<ul>
<li>공통점</li>
</ul>
<ol>
<li>하나의 사진에 긴 텍스트를 하는 경우도 있으나, 여정을 기록할 떄는 사진으로 더 설명을 하려고 하는 경향이 많다.</li>
<li>한 스팟의 하나의 시퀸스에 여러장을 게시하는 것은 없앤다. 그 정도의 많은 사진은 직접 디바이스에 저장하고, 우리 서비스를 통해 등록하는 사진은</li>
<li>하나의 스팟을 구성하는 시퀸스중 하나로, 5분간격 20m 간격으로 촬영하는 갭이 짧은 플롯이 될 수 있지만,</li>
</ol>
<ul>
<li>여행포스팅을 어떻게 정리해야 많이 공유되고,</li>
</ul>
<ol>
<li>네비게이션을 자동으로 생성해줘서, 시간-지역의 드래그가능한 선형 그래프</li>
<li>스팟별로 색깔을 다르게 표시하고, 개별 시퀸스는 작은 글씨로 표시한다.</li>
<li>시간대별로 정렬하지만, 가장 위쪽에 비용이나 빠르게 참고하고 읽은 후에 이 정보를 읽을 만 한지 판별할 수 있는 장치가 필요.</li>
<li>10중 7은 마음에 안드는 것은 정상적인 것. 내가 이 글을 읽어봐야 할지 아닐지 판별 할 수 있는 정보를 빠르게 전달해야 한다.</li>
</ol>
<ul>
<li>여행정보 공유하기 좋은 형태로 재가공하기</li>
</ul>
<ol>
<li>스팟이동 경로와 시간 표시</li>
<li>비용에 대한 정보는 애초에 신뢰성이 없다. 그것은 그냥 텍스트 데이터에 맞길것인가?</li>
<li>총 비용 혹은 스팟에 대한 비용으로 처리하거나, 가계부처럼 여정을 진행중에 자신이 얼마나 썼는지 작성 할 수 있도록.</li>
<li>작성하면서 시간을 따로 기록 하지 않는다면, 특정 시퀸스에서 일어난 일이 아니라, 하나의 스팟에서 몰아서 처리하도록</li>
</ol>
<ul>
<li>자동으로 스팟을 전환해주는 기능</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">스팟</th>
<th style="text-align:center">위치</th>
<th style="text-align:center">시간</th>
<th style="text-align:center">사진</th>
<th style="text-align:center">텍스트</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">산호세거리 23-바르셀로나</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">아래 포스팅이 최초여서 스팟그룹이 묶여진다.</td>
</tr>
<tr>
<td style="text-align:center">산호세거리 23-바르셀로나</td>
<td style="text-align:center">산호세거리 23</td>
<td style="text-align:center">13:00(esp)</td>
<td style="text-align:center">pic</td>
<td style="text-align:center">걷다가 너무 힘들었다</td>
</tr>
<tr>
<td style="text-align:center">산호세거리 23-바르셀로나</td>
<td style="text-align:center">산호세거리 15</td>
<td style="text-align:center">13:21(esp)</td>
<td style="text-align:center">pic</td>
<td style="text-align:center">가게 조형물들이 너무 아름답다. 한국가면, 유리 세공공방이나 차려볼까… ㅎㅎ</td>
</tr>
<tr>
<td style="text-align:center">산호세거리 23-바르셀로나</td>
<td style="text-align:center">콜리뇨거리 33</td>
<td style="text-align:center">13:45(esp)</td>
<td style="text-align:center">pic</td>
<td style="text-align:center">젤라또를 먹으러 왔다. 이것이 본토의 맛인가…</td>
</tr>
<tr>
<td style="text-align:center">산호세거리 43-바르셀로나</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">거리는 비슷하나, 마지막 포스팅으로부터 3시간 이상 지났기 떄문에 스팟그룹이 전환된다.</td>
</tr>
<tr>
<td style="text-align:center">산호세거리 43-바르셀로나</td>
<td style="text-align:center">산호세거리 43</td>
<td style="text-align:center">17:55(esp)</td>
<td style="text-align:center">pic</td>
<td style="text-align:center">호텔을 겨우 잡았다. 방이 솔직히 맘에 들지 않지만, 특히 주인장은 동양인을 무시한다.</td>
</tr>
</tbody>
</table>
<p>이렇게 되면 장점이, 비행기내에서 포스팅을 한번 하면, 10분내로 수십 KM를 이동하기 때문에, 스팟을 전환해서 처리해주고,<br>
또 수십킬로 지나면 스팟이 전환된다. 이게 은근히 매력적인 구성.<br>
중국해 영공에서(스팟)-&gt; 발트해 영공에서(스팟 10분경과)</p>
<ul>
<li>
<p>소비를 기록 하는 기능,<br>
그냥 기록하면 알아서 해당 스팟내에서 발생한 것으로 간주하고 시간 순으로 정렬해줘요.<br>
직접 스팟을 지정하거나, 시간을 지정하면 어찌됐건 해당 스팟으로 처리되요.</p>
</li>
<li>
<p>스팟 혹은, 포스트에 대한 태그<br>
태그가 어떤 기능을 해결해 줄 수 있을까? 어떤 지역 여행을 한 사람들의 족적을 미리 체크해봄으로 간접체험하고, 내가 더 나은 경험을 하기 위함이 큰 목적이라면.<br>
스팟마다 사용한 비용을 포스트:잠, 태그:라인에 맞춰서, 지도상이나 그래픽위에, 시간과 금액을 표시하고, 총액은 스팟별로.<br>
여행을 마감하면, 종료된 여행으로 간주하고, 모든 금액을 산출해서 정확히 어디에 소비했고 이런게 아니라, 그냥 얼마나 썼는지, 하나의 스팟에서 시퀸스가<br>
음식이나, 쇼핑, 여행 물품, 지역교통비, 관광료 등 여러요소가 존재 할 수 있으니 그것은 이름만 적어서 작성할 수 있도록.<br>
어차피 가계부에서도, 종목을 정하지만 세부적인 상품명은 별도로 달아준다.<br>
그리고 사실 한눈에 보면 간편해 보이는 듯 하지만, 식음료비용이 전달보다 2만원 늘었다는 사실이, 그렇게 큰 도움은 되지 않는다.<br>
소비 패턴은 분석해 줄 수 있겠지.</p>
</li>
</ul>
<p>검색할때, 태그가 부연설명으로 도움이 될 수 있을까?<br>
우리는 기본적으로 지역에 대한 정리된 여정을 검색하고 보는 것에 의미를 두고 있다면, 어떤 검색을 통해서, 내가 원하는 정보를 얻을 수 있을까?</p>
<p>유효한 지역을 검색하면, 스팟이 그 지역 부근 1km안에 포함된다면? 모두 출력하고, 1KM밖이라면, 제일 가까운 순위별로 주는 것도 괜찮다.<br>
그러면 거리를 출력해줄 필요가 있다.<br>
해당 스팟의 위도경도정보를 같이 저장해준다면, 구글에 분석을 요청하지 않고도, 바로 처리할 수 있다.<br>
최초 포스트를 등록하거나를 통해서 스팟이 시작되면, 그 시작점을 기준으로 위도경도 정보를, 서버에서 요청하는 것이 아니라, 클라이언트에서 작성해서 넘긴다.</p>
<p>물론 조작의 위험도는 있지만, 크리티컬한 이슈가 아니고, 단순히 정보가 잘못됐다는 것이기 때문에, 그것은 사용자가 이거 엉터리 글이네 하고 넘길 수 있다.</p>
<p>위도경도의 수치계산 알고리즘을 통해서 인접 거리를 구해서?<br>
일단 나라는 같아야 한다?</p>
<p>그러면 스팟마다 위도경도를 해당 스팟 아래 속하는 모든 시퀸셜 포스트가 동일하다고 간주하고 처리하니, 어차피 거리가 일정 이상 벗어나면 스팟을 넘겨버릴 것이다.</p>
<p>모든 스팟에 대해서 풀스캔?<br>
아니다 최소한 나라라는 기준은 매치해야한다. 시와 시를 왔다 갔다 하는 것은 굉장히 애매한 기준이기 때문에, 물론 왠만하면 시의 중심지가 주요 관광지이겠지만,<br>
그냥 나라를 기준을 나눈다면 가장 안전할 수도있다.<br>
인접 지역이라도 같은 나라가 아니라면 여행자가 원하는 정보가 아닐 가능성이 매우 높다.</p>
<p>지역적 키워드를 검색하면 그것의 해당하는 나라와, 위도경도정보를 서버로 전송한다.<br>
나라에 등록된 스팟을 모두 검색한다.</p>
<p>잠깐. 하나의 여정노트를 완성한다고 할떄, 여러 나라를 들릴 수 있다고하면, 하나로 묶어주는게 좋을까 별개로 나누는게 좋을까?<br>
나누는게 백번 나은데, 도저히 나눌 수 없는 상황도 있지 않을까?<br>
잠깐 미국에서 캐나다 하루 들렸다 오는 길이며, 미국에서 1주일 머무는 거라고 하면 얘기가 달라진다.<br>
그렇다면 여정에서 나라는 제외하자.<br>
스팟 기준으로 나라는 바뀔 수 있고. 만약 유저가 해당 여정노트를 마감하고 싶다고하면, 매뉴얼하게 할 수 있다.</p>
<p>포스트를 등록할때. 어떤 나라로, 포스트를 등록하겠다고 하면</p>
<h3 id="스팟과-시퀸셜-포스팅-기준-모델"><a class="markdownIt-Anchor" href="#스팟과-시퀸셜-포스팅-기준-모델"></a> 스팟과 시퀸셜 포스팅 기준 모델</h3>
<ul>
<li>유저</li>
</ul>
<p>|이름|여정|</p>
<ul>
<li>여정</li>
</ul>
<p>|유저|스팟|주요 테마|</p>
<ul>
<li>
<p>스팟<br>
|나라|위도,경도|시퀸셜 포스팅|지역적 테마(태그 1개)|</p>
</li>
<li>
<p>시퀸셜 포스트</p>
</li>
</ul>
<p>|시간|텍스트|멀티파트-이미지, 동영상(1<sub>5)|소비|태그(1</sub>3개)|</p>
<p>지역적 테마를 통해서, 주 목적과 조금 다른 일시적인 여흥도 커버 할 수 있다.</p>
<h2 id="190917"><a class="markdownIt-Anchor" href="#190917"></a> 190917</h2>
<p>유저가 초기 입력값인, interests를 설정하면, 그것에 대해서 유효한 추천건을 어떻게 가져올 것인가.<br>
유저가 음식에 관심이 있다고 처음 입력 했다면, 검색할때, 여정에 총 테마가 음식인 것 패스의 테마가 음식인 것.</p>
<ul>
<li>SPOT RENAMED TO PATH</li>
</ul>
<p>|country|pos_x|pos_y|post_ids|theme|</p>
<ul>
<li>POST(의미적으로 SPOT과 동일)</li>
</ul>
<p>|time|text|pos_x|pos_y|media(1~5) auto_layout기능, 업로드 순으로 보이도록 처리를 해야 한다.|payments|tags|</p>
<p>TAG는 검색에 연동시키기 위한 장치라고하면 THEME은 순전이 키워드 기반 주제를 골라주도록 유도하는 것.<br>
healing, nature, shopping, locality, experience등으로 THEME을 정하면, 그것을 기반으로 작은 조각으로 POST가 아닌 PATH를 검색하면,<br>
POST가 여행을 이해하기에는 너무 내러티브가 존재하지 않는다고 하면, PATH는 앞뒤로 어느정도 과정이 있으니, 그것을 충족시켜줄 수 있다.</p>
<ul>
<li>사진을 로컬앱으로 업로드하는 과정에서, 레이아웃이 적용되서 처리되니까, 유저가 서버에 업로드 전(글 작성 완료)에 알아서 수정할 수 있다.</li>
</ul>
<p>여행중 유저의 시나리오.</p>
<p>여행을 하고 있고, 시장으로 나가는 길에서부터 앱을 실행해서, 여행시작하기 를 하고 첫번 쨰 포스트를 등록하려 한다.<br>
시장의 과일상들의 사진과 시장의 일부 오브젝트를 촬영하여 4장을 업로드 하겠다.<br>
글은 간단한게 작성했다.(ㅇㅇㅇ시장의 풍경 #ㅇㅇㅇ시장 #푸드)<br>
20미터 쯤 지났을까, 또 포스트작성하기를 하니, 이전촬영지역의 이름의 앨범에 이어서 작성하도록 되어있다.<br>
… 마찬가지로 작성한것으로…</p>
<p>그리고 20분쯤뒤에 새로운 포스트를 작성하려고 하는데, 앨범을 전환하도록 했다.(새로운 지역이름)<br>
기존에 진행중이던 앨범이 마감되면서, 해당 앨범이 그래픽으로 뭔가 고정되었음을 알 수 있고,<br>
해당 앨범을 클릭하니, 지도에 지역이 점으로 찍혀서 선으로 나와있고, 밑에 요약이 되어있으면서, 그 루트 안의 총 지출이 요약되어있다.<br>
정확히 어느지점에서 썼는지는 모르겠으나, 어떤 소비가 있었는지는, 해당 앨범이 활성화 되어있을때, 포스트등록하기가 아닌, 지출입력하기 로 큰카테고리와 상품명, 가격을<br>
해당 지역의 화폐단위에 맞춰서 처리했다.</p>
<p>여행 후 유저의 시나리오</p>
<p>앨범 에 사진이 몰려있고, 그것을 순차적으로 조금 나눠서 날짜별로 정리하려 한다.<br>
사진 5개를 등록하고, 태그를 작성했고, 시간과 위치를 메뉴얼하게 입력해 주었다.</p>
<p>다음에 이어서 하다가, 날짜를 전환하도록 한다.</p>
<ul>
<li>이경우 한날짜에 너무 많은 데이터가 몰려서 들어간다면, 검색할때 그 정보가 그렇게 유효하지 않기 떄문에, 1일차-ㅌㅌㅌ시장</li>
</ul>
<p>이런식으로 수정을 하도록 권고할 수 있으면 좋겠다.</p>
<p>그러면, 어차피 유저가 정리할 떄는, 대부분 여행기록은 시간적으로 묶어서 처리하는 경우가 많기 때문에, 물론 그렇게 하지 않아도 되지만,<br>
장소적으로는 인근지역을 몰아서 처리하거나, 하는 경우는 분명 대다수 라 할 수 있다.</p>
<p>화폐단위 처리는, 저장할떄, 단위는 해외에서 USD를 안쓰는 곳에서도 USD를 처리하는 경우가<br>
많기 떄문에, 서버에 저장할때는 USD든 뭐든 해당 국가의 화폐단위로 변환해서 저장해주면,<br>
모든 소비가 해당국가의 화폐단위의 수치로 기록이 되고, 그것을 나중에 자국 화폐로 변환해서 볼떄는 매번 바뀌는 식으로.<br>
소수점 2자리까지 허용해서, 300.12정도로 기록?</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/09/09/project/travel_note/" data-id="ckkdb52fq000h1pqkxl4a13sv" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/project/">project</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/travel-note/">travel_note</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-http/1_http_1.0_basic_four_feature" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/06/http/1_http_1.0_basic_four_feature/" class="article-date">
  <time datetime="2019-09-06T11:03:56.000Z" itemprop="datePublished">2019-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/06/http/1_http_1.0_basic_four_feature/">http/1.0의 신택스: 기본이 되는 네가지 요소</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> index</h2>
<ol>
<li><a href="#http%EC%97%AD%EC%82%AC%EC%99%80_%EB%8B%B4%EB%8B%B9%EA%B8%B0%EA%B4%80"><strong>HTTP 역사 및 대표 기관명칭</strong></a></li>
<li><a href="#http_0.9"><strong>HTTP 0.9</strong></a></li>
<li><a href="http_1.0"><strong>HTTP 1.0 전환</strong></a></li>
<li><a href="#mime%ED%83%80%EC%9E%85"><strong>Content-Type의 값 MIME타입</strong></a></li>
<li><a href="%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80_status_code"><strong>메서드와 스테이터스 코드</strong></a></li>
<li><a href="#url"><strong>URL</strong></a></li>
<li><a href="#body"><strong>BODY</strong></a></li>
</ol>
<h2 id="http의_역사와_담당기관"><a class="markdownIt-Anchor" href="#http의_역사와_담당기관"></a> HTTP의_역사와_담당기관</h2>
<ul>
<li>1990년: HTTP/0.9, CREN에서 근무하던 팀 버너스리가 최초 웹서버 CERN HTTPd 개발</li>
<li>1996년: HTTP/1.0</li>
<li>1997년: HTTP/1.1</li>
<li>2005년: HTTP/2</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">이름</th>
<th style="text-align:center">정식 명칭</th>
<th style="text-align:center">역할/의미</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IETF</td>
<td style="text-align:center">Internet Engineering Task Force</td>
<td style="text-align:center">인터넷의 상호 접속성을 향상시키는 것을 목적으로 만들어진 임의 단체 (통신프로토콜 관리자)</td>
</tr>
<tr>
<td style="text-align:center">RFC</td>
<td style="text-align:center">Request For Comments</td>
<td style="text-align:center">IETF가 만든 규약문서         (상호 접속성 유지를 위한 사양서 모음)</td>
</tr>
<tr>
<td style="text-align:center">IANA</td>
<td style="text-align:center">Internet Assigend Numbers Authority</td>
<td style="text-align:center">포트번호와 컨텐츠타입등 웹에 관한 데이터베이스를 관리하는 단체</td>
</tr>
<tr>
<td style="text-align:center">W3C</td>
<td style="text-align:center">World Wide Web Consortium</td>
<td style="text-align:center">웹 관련 표준화를 하는 비영리 단체    (브라우저에 특화된 기능 책정)</td>
</tr>
<tr>
<td style="text-align:center">WHATWG</td>
<td style="text-align:center">Web Hypertext Application Technology Working Group</td>
<td style="text-align:center">웹 관련 규격을 논의하는 단체, W3C와 겸하는 멤버가 많다.</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="http_09"><a class="markdownIt-Anchor" href="#http_09"></a> HTTP_0.9</h2>
<ul>
<li>go 에코서버</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(writer http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    dump, err := httputil.DumpRequest(req, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    func dumprequst(req *http.request, body bool)([]byte, error)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(writer, fmt.Sprint(err), http.StatusInternalServerError)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(dump))</span><br><span class="line">    fmt.Fprintf(writer, <span class="string">"&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// 초기실행부</span></span><br><span class="line">    <span class="keyword">var</span> httpServer http.Server</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">    <span class="comment">// "/"에 접속이 있을 때, handler함수를 호출</span></span><br><span class="line">    log.Println(<span class="string">"start http listening :18888"</span>)</span><br><span class="line">    httpServer.Addr = <span class="string">":18888"</span></span><br><span class="line">    <span class="comment">// 18888포트로 설정</span></span><br><span class="line">    log.Println(httpServer.ListenAndServe())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>request 전달</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client</span></span><br><span class="line">$ curl --http1.0 http://localhost:18888/greeting</span><br><span class="line"><span class="comment"># response</span></span><br><span class="line">&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># server: request</span></span><br><span class="line">GET / HTTP/1.0</span><br><span class="line">Host: 127.0.0.1:18888</span><br><span class="line">Connection: close</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: curl/7.58.0</span><br></pre></td></tr></table></figure>
<p>0.9버전은 1.0과 호환되지 않기 때문에, 0.9요청을 전달하는 것은 현재는 불가능하다.<br>
0.9버전 당시에 content/type은 text/html밖에 존재하지 않음</p>
<ul>
<li>검색 기능</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client</span></span><br><span class="line">$ curl --http1.0 --get --data-urlencode <span class="string">"search word"</span> http://</span><br><span class="line">localhost:18888/greeting</span><br><span class="line"></span><br><span class="line"><span class="comment"># server</span></span><br><span class="line">GET /?search%20word HTTP/1.0</span><br><span class="line">Host: 127.0.0.1:18888</span><br><span class="line">Connection: close</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: curl/7.58.0</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="http_09에서_10으로"><a class="markdownIt-Anchor" href="#http_09에서_10으로"></a> http_0.9에서_1.0으로</h2>
<ul>
<li>HTTP/0.9의 프로토콜로는 할 수 없는 일
<ul>
<li>하나의 문서를 전송하는 기능만 존재(<code>&lt;html&gt; -&gt; &lt;/html&gt;</code>)</li>
<li>컨텐츠 타입은 모두 text/html로 가정. 다운로드할 컨텐츠를 서버가 바꿀 수 없었다.</li>
<li>클라이언트에서 검색이외 요청을 보낼 수 없었다.</li>
<li>새로운 문장을 전송하거나 갱신 또는 삭제 불가?(소켓유지?)</li>
<li>요청이 올바른지 혹은 서버가 올바르게 처리했는지 전달할 수 없음.</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">curl --get -v --http1.0 http://127.0.0.1:18888/</span><br><span class="line"></span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* TCP_NODELAY <span class="built_in">set</span></span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 18888 (<span class="comment">#0)</span></span><br><span class="line"><span class="comment"># &gt;로 시작하는 행이 클라이언트에서 서버로 갈 내용</span></span><br><span class="line">&gt; GET / HTTP/1.0</span><br><span class="line">&gt; Host: 127.0.0.1:18888</span><br><span class="line">&gt; User-Agent: curl/7.58.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line"><span class="comment"># 여기까지</span></span><br><span class="line">* HTTP 1.0, assume close after body</span><br><span class="line"><span class="comment"># &lt;로 시작하는 행은 서버 응답</span></span><br><span class="line">&lt; HTTP/1.0 200 OK</span><br><span class="line">&lt; Date: Fri, 06 Sep 2019 11:53:03 GMT</span><br><span class="line">&lt; Content-Length: 31</span><br><span class="line">&lt; Content-Type: text/html; charset=utf-8</span><br><span class="line">&lt; </span><br><span class="line">* Closing connection 0</span><br><span class="line">&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>1.0으로 버전업 변경점
<ul>
<li>요청 시 메서드가 추가</li>
<li>요청 시 HTTP버정이 추가(HTTP/1.0)</li>
<li>헤더가 추가(Host, User-Agent, Accept)</li>
<li>응답 시 HTTP버전과 스테이터스 코드가 포함</li>
<li>요청과 같은 형식의 헤더가 포함됨</li>
</ul>
</li>
</ul>
<p>ARPAnet에서 부터 시작된 전자메일(RFC822)이 HTTP보다 더욱 발달 했었기 때문에, 많은 참조, 승계가 일어남.</p>
<ol>
<li>
<p>Req header From Client</p>
<ul>
<li>User-Agent: 클라이언트가 자신의 어플리케이션 이름을 전달 하는 키값.</li>
<li>Referer: 서버에서 참고할 수 있는 추가 정보, 요청을 보내는 시점의 URL등을 포함. 보안때문에, 사양이 당초 보다 크게 변경됨.</li>
<li>Authorization: 특별한 클라이언트에만 통신을 허가할 떄 인증 정보를 서버에게 전달</li>
</ul>
</li>
<li>
<p>Res header From Server</p>
<ul>
<li>Content-Type: 파일 종류. MIME타입 이라는 식별자를 기술.(전자메일을 위해 만들어짐)</li>
<li>Content-Length: 바디 크기. 압축이 이루어지는 경우 압축 후의 크기</li>
<li>Content-Encoding: 압축이 이루어진 경우 압축 형식</li>
<li>Date: 문서 날짜</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 윈도우 7의 익스플로러 10 버전으로 User-Agent설정</span></span><br><span class="line">curl -v --http1.0 -A <span class="string">"Mozilla/5.0(compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)"</span> http://127.0.0.1:18888/</span><br><span class="line"></span><br><span class="line"><span class="comment"># server output</span></span><br><span class="line"></span><br><span class="line">GET / HTTP/1.0</span><br><span class="line">Host: 127.0.0.1:18888</span><br><span class="line">Connection: close</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: Mozilla/5.0(compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># client output</span></span><br><span class="line"></span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* TCP_NODELAY <span class="built_in">set</span></span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 18888 (<span class="comment">#0)</span></span><br><span class="line">&gt; GET / HTTP/1.0</span><br><span class="line">&gt; Host: 127.0.0.1:18888</span><br><span class="line">&gt; User-Agent: Mozilla/5.0(compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line">* HTTP 1.0, assume close after body</span><br><span class="line">&lt; HTTP/1.0 200 OK</span><br><span class="line">&lt; Date: Fri, 13 Sep 2019 07:41:43 GMT</span><br><span class="line">&lt; Content-Length: 31</span><br><span class="line">&lt; Content-Type: text/html; charset=utf-8 <span class="comment"># MIME타입 문자열</span></span><br><span class="line">&lt; </span><br><span class="line">* Closing connection 0</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="mime타입"><a class="markdownIt-Anchor" href="#mime타입"></a> MIME타입</h2>
<h3 id="mime타입_개요-rfc-1341"><a class="markdownIt-Anchor" href="#mime타입_개요-rfc-1341"></a> MIME타입_개요 (RFC 1341)</h3>
<p>RFC1341에 처음 등장하여, 전자메일을 위해 만들어졌으며, 파일의 종류를 구별하는 문자열이다.<br>
인터넷이 보급된 시기는 MS-DOS, 윈도우3.x, 맥 OS7등이 사용되던 시기.</p>
<p>OS별 파일의 구별</p>
<ul>
<li>윈도우: 파일 확장자를 통해 구별</li>
<li>맥: Resource fork라 불리는 메타정보로 파일 종류를 판단</li>
</ul>
<p>지금도 위 사항은 기본적으로 유지되고 있음.</p>
<h3 id="content-type의-등장-rfc-1049"><a class="markdownIt-Anchor" href="#content-type의-등장-rfc-1049"></a> Content-Type의 등장 (RFC 1049)</h3>
<p>이 시기(1988년)에는 Content-Type인 MIME_TYPE(아직 MIME타입이 아니라 값)에는</p>
<ol>
<li>POSTSCRIPT</li>
<li>TEX</li>
</ol>
<p>와 같은 것들이 있었다.</p>
<p><strong>대항목/상세</strong>, 같은 식의 표기방식을 채택한 1992년 RFC 1341에서(HTML 미등장)</p>
<ol>
<li>‘text/plain’</li>
<li>‘image/jpeg’</li>
<li>‘multipart/form-data’</li>
</ol>
<p>같은 포멧을 위한 표기 방법이 등장하게 되면서 MIME타입이라 공식화 하게된다.</p>
<ol>
<li>서버에서 클라이언트로 데이터를 전송할 때, 컨텐트 타입을 헤더에 MIME타입값으로 정의하여 send하면,</li>
<li>브라우저 혹은 무엇이든 요청을 보낸 클라이언트 어플리케이션은 그것을 수용할 수 있는지 없는지 판단하고</li>
<li>서버와 소통을 통해 최종 결정하여 body를 받는다. 이 과정을 Negotiation이라 한다.</li>
</ol>
<p>RFC 1590에서 새로운 종류의 MIME타입을 IANA에 등록신청하는 절차를 구성하였다.<br>
RFC 3023에서, JSON, XML등의 MIME타입이 공식화 되었다.<br>
이로써, XML을 기반으로 한 SVG이미지를 application/xml이 아니라,<br>
Image/svg+xml로 표기 할 수 있게 되었다.</p>
<h3 id="content-type과_보안"><a class="markdownIt-Anchor" href="#content-type과_보안"></a> Content-Type과_보안</h3>
<p>특정 타입으로 BODY를 해석해 달라는 요청을 Content-Type대신 확장자를 사용하려고 해도, 클라이언트에 따라 전송되지 않을 수 있다.</p>
<p>2000년 초기까지는 CGI를 이용한 접속 카운터(숫자가 들어간 이미지를 생성하는 Pearl등의 스크립트 언어 프로그램)로 대체.<br>
이 카운터는 .cgi라는 확장자로 HTML에서 아래와 같은 식으로 CGI를 호출하여 사용하였다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"cgi-bin/counter.cgi"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>이 경우, cgi프로그램이 <code>Content-Type:image/gif</code>같은 헤더를 생성하여 처리.</p>
<p>그러나 익스플로러는 인터넷 옵션에 따라, MIME타입이 아니라 내용을 보고 파일 형식을 추측하기도 한다.<br>
이런 동작을 <em>content sniffing</em>이라 한다.<br>
서버에서 잘못된 처리로 타입과 언매치한 바디를 주었을 때, 해결해 줄 수 있는 장점이 있으나,<br>
브라우저가 추측하는 정보가 잘못되어, 예상 외의 분석, 실행을 하는 경우에 보안의 문제가 일어난다.<br>
예를 들어 자바스크립트가 아닌데, 자바스크립트로 해석하면, 엄격한 규칙에 따라 그 응답을 브라우저에서 실행하지 않는 경우등이 있다.</p>
<p>서버에서 다음과 같은 헤더를 통하여, 브라우저의 추측을 금지하도록 지시하는 방식을 주로 사용하고 있다.</p>
<p><code>X-Content-Type-Options: nosniff</code></p>
<hr>
<h2 id="메서드와_status_code"><a class="markdownIt-Anchor" href="#메서드와_status_code"></a> 메서드와_STATUS_CODE</h2>
<h3 id="http의_또다른_메타_뉴스그룹"><a class="markdownIt-Anchor" href="#http의_또다른_메타_뉴스그룹"></a> HTTP의_또다른_메타_뉴스그룹</h3>
<p>인터넷 이전의 주요 미디어로서, 지금은 사용되지 않는 뉴스그룹은 분산 아키텍쳐로 구성되어 있다.<br>
사용자는 서버에 구독하는 최신기사를 요청하고 기사가 있으면 가져온다.<br>
웹처럼 모든 사용자가 한 곳의 서버에 접속하러 가는 것이 아니라, 복수의 서버가 master/slave구조로 연결.</p>
<p>슬레이브의 서버가 마스터로 접속하고 정보를 가져와 로컬에 저장.<br>
스토리지 용량제한으로 오래된 기사는 삭제한다.<br>
마스터서버를 참조하는 복수의 슬레이브 서버, 그리고 슬레이브에 접근하는 클라이언트 간 통신에 사용된 것이,</p>
<p><code>NNTP(Network News Transfer Protocol)</code>이다. <code>(RFC 977)</code></p>
<p>HTTP0.9보다 5년 빠른 1986년에 정식화 되었으며, 메세지 포멧은 그보다 3년 전인 <code>RFC 850</code>에서 등장하였다.<br>
이 포멧도 전자메일을 영향을 받아 정식화되었고, 마찬가지로 헤다와 본문이 있고, 사이에 빈줄이 들어가는 구성이다.<br>
HTTP는 뉴스그룹 프로토콜로 부터 <code>METHOD</code>, <code>STATUS CODE</code>를 이어받는다.</p>
<h3 id="method"><a class="markdownIt-Anchor" href="#method"></a> METHOD</h3>
<p>지정된 주소에 있는 리소스에 대한 조작을 지시한다.</p>
<ul>
<li>뉴스그룹 메서드
<ol>
<li>LIST: 그룹 목록 취득</li>
<li>HEAD: 헤더 취득</li>
<li>BODY: 기사 취득</li>
<li>POST: 투고</li>
</ol>
</li>
</ul>
<p>HTTP의 경우는 파일 시스템과 같은 설계철학으로 만들어졌다.<br>
기본으로 <code>GET</code>, <code>HEAD</code>, <code>POST</code>는 가장 많이 쓰이는 메서드이며,<br>
<code>PUT</code>, <code>DELETE</code>는 사용빈도에 따라 필수가 아니라 구현에 따라 Optional한 기능이 되었다.</p>
<ol>
<li>GET: 헤더와 컨텐츠 요청</li>
<li>HEAD: 헤더만 요청</li>
<li>POST: 새로운 문서 투고</li>
<li>PUT: 이미 존재하는 URL의 문서를 갱신</li>
<li>DELETE: 지정된 URL의 문서를 삭제, 성공시 해당 URL은 무효</li>
</ol>
<p><code>curl --http1.0 --request POST http://127.0.0.1:18888/</code></p>
<h3 id="status_code"><a class="markdownIt-Anchor" href="#status_code"></a> STATUS_CODE</h3>
<p>뉴스그룹 프로토콜에서 가져온 기능으로, 5가지 카테고리로 나눌 수 있다.</p>
<ul>
<li>1XX번대: 처리가 계속됨을 나타낸다.</li>
<li>2XX번대: 성공했을 때의 응답. 200 OK 정상종료</li>
<li>3XX번대: 서버에서 클라이언트로의 명령. 오류가 아니라 정상처리의 범주이며, <code>리디렉트</code>, <code>캐시 이용</code>등을 지시한다.</li>
<li>4XX번대: 클라이언트가 보낸 요청에 오류가 있다.</li>
<li>5XX번대: 서버 내부에서 오류가 발생했다.</li>
</ul>
<h3 id="리디렉트"><a class="markdownIt-Anchor" href="#리디렉트"></a> 리디렉트</h3>
<p>Redirect를 통해 다른 페이지를 GET하라는 권고로, 해당 요청에서는 시나리오가 없으니, 다시 요청을 날리라는 표현.</p>
<table>
<thead>
<tr>
<th style="text-align:center">코드번호</th>
<th style="text-align:center">메서드 변경</th>
<th style="text-align:center">영구적/일시적</th>
<th style="text-align:center">캐시</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">301 Moved Permanently</td>
<td style="text-align:center">O</td>
<td style="text-align:center">영구적</td>
<td style="text-align:center">한다</td>
<td style="text-align:center">도메인 전송, 웹사이트 이전, HTTPS</td>
</tr>
<tr>
<td style="text-align:center">302 Found</td>
<td style="text-align:center">O</td>
<td style="text-align:center">일시적</td>
<td style="text-align:center">지시에 따름(<code>Cache-Control</code>, <code>Expires</code>헤더를 통해)</td>
<td style="text-align:center">일시적 관리, 모바일 기반 전송</td>
</tr>
<tr>
<td style="text-align:center">303 See Other</td>
<td style="text-align:center">허가</td>
<td style="text-align:center">영구적</td>
<td style="text-align:center">하지않음</td>
<td style="text-align:center">로그인 후 페이지 전환</td>
</tr>
<tr>
<td style="text-align:center">307 Temporary Redirect</td>
<td style="text-align:center"></td>
<td style="text-align:center">일시적</td>
<td style="text-align:center">지시에 따름</td>
<td style="text-align:center"><code>RFC 7231</code>에서 추가</td>
</tr>
<tr>
<td style="text-align:center">308 Moved Permanetly</td>
<td style="text-align:center"></td>
<td style="text-align:center">영구적</td>
<td style="text-align:center">한다</td>
<td style="text-align:center"><code>RFC 7538</code>에서 추가</td>
</tr>
</tbody>
</table>
<ul>
<li>영구적: 영구적인 접근 차단.(무효한 자원, HTTP -&gt; HTTPS)</li>
<li>일시적: 이동하려던 페이지에 언젠가는 이동 가능(존재하는 자원)</li>
<li>303의 경우: 로그인 같은 경우는 보통 POST메서드로 이루어지는데,<br>
자원에 대한 요청이 아니기 때문에, 반환할 컨텐츠가 없으며, 동시에 별도로 처리할 페이지가 있는 경우이다.<br>
따라서 해당 리디렉션은 일시적으로 접근 못하는 것이 아니라 정상적인 시나리오 내에서,<br>
영구적으로 가야하는 곳을 다시 지정하는 시나리오.</li>
<li>301의 경우: 요청된 페이지가 다른 장소로 이동했을떄, 기존도메인에서 301을 처리해주면,<br>
<strong>구글검색엔진은 해당 페이지에 대한 평가를 리디렉션으로 상속</strong>시킨다.</li>
</ul>
<p>Redirection의 경우 대부분 헤더에 <code>Location</code>키값이 존재히는데,<br>
<code>curl --location --max-redirs 5 GET http://127.0.0.0.1:18888/get_to_redirect/</code><br>
Response-헤더에 location이 존재할 경우, 해당 값으로 GET 최대 5회까지 리디렉션을 보내고, 기존 Request-헤더를 유지한다.</p>
<blockquote>
<p>구글은 리디렉트의 사이드 이펙트를 염려하며, 권장 3회 이하, 최대 5회 이하라는 가이드 라인을 제시하였다.</p>
</blockquote>
<p><code>RFC 2616</code>에서는 302의 코드설명상,</p>
<blockquote>
<p>메서드변경을 허가가 필요하도록 하였고, 현재 유저에이전트는 대부분 GET으로 변경한다.</p>
</blockquote>
<p><code>RFC 7231</code>애서는,</p>
<blockquote>
<p>302를 301처럼 메서드 변경을 허용하고, 변경허가가 필요한 307, 308을 추가한다.</p>
</blockquote>
<hr>
<h2 id="url"><a class="markdownIt-Anchor" href="#url"></a> URL</h2>
<p><code>RFC 1738</code>에서 등장하였으며, 상대적 URL은 <code>RFC 1808</code>에서 등장.<br>
이들은 모두 HTTP/1.0보다 빠른 시기의 문서로,<br>
HTTP/0.9중에 HTTP/1.0를 계획하에 먼저 규격화 되었다.</p>
<h3 id="url의_구조"><a class="markdownIt-Anchor" href="#url의_구조"></a> URL의_구조</h3>
<p>일반적인 경우</p>
<p><code>스키마://호스트명/경로</code>의 형태로 구성이 되지만, URL사양에 포함되는 모든 요소가 들어간 경우는<br>
<code>스키마://사용자:패스워드@호스트명:포트/경로#프래그먼트?쿼리</code>로 구성된다.</p>
<ol>
<li><code>스키마</code>: 스키마해석은, 브라우저의 책임이며, https. mailto, ftp등이 올 수 있다.<br>
로컬 파일을 브라우저로 열면 <code>file:</code>로 표시된다.</li>
<li><code>사용자:패스워드</code>: Basic인증 방식이며, 로그에 URL이 남게되어 유출되기 때문에, 웹 시스템에서는 사용하지 않는다.</li>
<li><code>호스트명</code>: DNS서버에, 엔드포인트로는 실제 IP라우팅 주소값을 특정하여 목적지를 찾아간다.</li>
<li><code>포트</code>: 스키마에 따라서 기본 well-known-port로 처리되며, 한 서버에 여러포트를 사용하는 경우 복수 서비스를 운영할 수 있다,</li>
<li><code>프래그먼트</code>: HTML문서 내의 링크 앵커를 지정</li>
<li><code>쿼리</code>: 해당 웹페이지에 대해서 특정 파라미터를 부여하고 싶은 경우 사용</li>
</ol>
<h3 id="url과_국제화"><a class="markdownIt-Anchor" href="#url과_국제화"></a> URL과_국제화</h3>
<p>기존엔 URL의 도메인 이름으로 영숫자와 하이픈만 사용 가능.<br>
2003년 <code>RFC 3492</code>에서 IDN(International Domain Name)을 표현하는 인코딩 규칙 <strong>PUNY CODE</strong>가 정해져,<br>
퓨니코드가 구현된 브라우저에서는 다국어를 도메인 네임으로 사용할 수 있다.<br>
정해진 규칙에 따라, 영숫자이외의 문자를 반각영숫자로 치환해 요청을 보낸다.</p>
<p><code>한글도메인.kr</code> -&gt; <code>xn--bj0bj3i97fq8o5lq.kr</code>이 된다.</p>
<p>퓨니코드는 반드시 <code>xn--</code>로 시작되는 문자열을 생성한다.</p>
<hr>
<h2 id="body"><a class="markdownIt-Anchor" href="#body"></a> BODY</h2>
<p>HTTP1.0이후부터 요청, 응답 모두 헤더를 포함하게 되면서, 헤더와 바디를 분리할 필요가 있어졌다.<br>
전자메일과 같이 헤더의 끝에 빈줄<code>\n</code>을 넣으면 그 이후는 모두 바디가 된다.</p>
<p>그러나 바디의 전송할 때, 데이터를 저장하는 포멧이 2종류가 존재하여서, 용도에 맞게 구분법이 다르다.</p>
<ol>
<li><code>Content-Encoding</code>의 압축알고리즘을 통한 압축전송과 HTMLFORM, XMLHttpRequest를 사용한 Request측 바디 전송</li>
<li>청크 형식의 바디 송신</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">헤더1: 값</span><br><span class="line">헤더2: 값</span><br><span class="line">Content-Length: 바디의 바이트 수</span><br><span class="line"></span><br><span class="line">--이 줄부터 지정된 바이트 수 만큼 바디--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Head요청시, 헤더만을 요구하는 요청이지만, Content-Length와 E-Tag등을 바르게 전송해야한다.</p>
</blockquote>
<ul>
<li>Curl커맨드의 바디 획득 옵션</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">옵션</th>
<th style="text-align:right">용도</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-d, --data, --data-ascii</td>
<td style="text-align:right">변환 완료된 텍스트데이터</td>
</tr>
<tr>
<td style="text-align:center">–data-urlencode</td>
<td style="text-align:right">텍스트 데이터 ascii변환</td>
</tr>
<tr>
<td style="text-align:center">–data-binary</td>
<td style="text-align:right">바이너리 데이터</td>
</tr>
<tr>
<td style="text-align:center">-T Filename, -d @Filename</td>
<td style="text-align:right">보내고 싶은 데이터를 파일에서 읽어온다.</td>
</tr>
</tbody>
</table>
<p>송신시 바디를 서버에 보내려면 -d옵션을 사용한다.<br>
그럴 경우 기본적으로 <code>Content-Type:application/x-www-form-urlencoded</code>가 된다.</p>
<ul>
<li>JSON을 전송하고 싶은 경우</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -d <span class="string">"&#123;\"hello\":\"world\"&#125;"</span> -H <span class="string">"Content-Type: application/json"</span> http://127.0.0.1:18888/</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON파일에서 읽어서 전송</span></span><br><span class="line">curl -d @test.json -H <span class="string">"Content-Type: application/json"</span> http://127.0.0.1:18888/</span><br></pre></td></tr></table></figure>
<p><code>application/x-www-from-urlencoded</code>같은 형식은 http0.9에서 파생되어,<br>
http1.0보다 먼저 표준화된 HTML 2.0의 사양이다.<br>
이는 <code>RFC 1866</code>에서 표준화 되었으며, RFC로 정의된 html은 이게 처음이자 마지막.<br>
<code>RFC 2854</code>의 결정으로 HTML사양 결정은 <code>W3C</code>로 넘어간다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/09/06/http/1_http_1.0_basic_four_feature/" data-id="ckkdb52f700031pqkzoricj7m" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/async_coroutine_5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/05/python/post/async_coroutine_5/" class="article-date">
  <time datetime="2019-09-05T09:17:02.000Z" itemprop="datePublished">2019-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/05/python/post/async_coroutine_5/">비동기 코루틴 번역-5-End</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="코루틴_정비하기"><a class="markdownIt-Anchor" href="#코루틴_정비하기"></a> 코루틴_정비하기</h2>
<p>우리는 어떻게 크롤러가 동작하는지 설명하는 것으로 부터 시작했다.<br>
이제 asyncio 코루틴을 사용해서 구현할 차례이다.</p>
<ol>
<li>우리 크롤러는 첫 페이지를 fetch한다.</li>
<li>그것의 링크들을 파싱하고,</li>
<li>그것들을 queue에 더할 것이다.</li>
<li>웹사이트를 돌고나면</li>
<li>pages를 동시적으로 fetching할 것이다.
<ul>
<li>하지만 클라이언트와 서버의 제한된 load때문에, 우리를 최대 워커 수를 필요로 한다.</li>
</ul>
</li>
<li>언제든 워커가 페이지를 fetching하는 것이 종료되면, 그 워커는 급히 다음 링크를 queue에서 꺼내야한다.</li>
<li>그리고 더 돌아갈 작업이 없다면, 일부 워커는 멈춰야한다.</li>
<li>하지만 워커가 수많은 링크를 지닌 페이지를 히트한다면,</li>
<li>큐는 급격히 커지고, 멈췄던 워커들은 다시 동작해야한다.</li>
<li>따라서 우리의 프로그램은 모든 일이 끝났을 때만 종료된다.</li>
</ol>
<p>워커가 쓰레드라고 가정해보자, 우리가 크롤러의 알고리즘을 어떻게 표현해야 할까?<br>
우리는 파이썬 표준 라이브러리에서 <strong>Synchronized queue</strong>를 사용할 수 있다. (공유자원 개념?)<br>
아이템이 queue에 들어갈 때마다, queue는 그의 tasks의 count를 증가시킨다.<br>
워커 쓰레드들은 task_done을 개별 아이템이 끝날 때마다 호출한다.<br>
그러면 메인쓰레드가 Queue에 들어간 각아이템이 task_done콜에 의해 매칭될 때까지 Queue.join에서 블록하고, 종료할 것이다.</p>
<p>코루틴은 asyncio queue를 이용한 동일한 패턴을 사용한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> asyncio <span class="keyword">import</span> JoinableQueue <span class="keyword">as</span> Queue</span><br><span class="line"><span class="keyword">except</span> ImportError: <span class="comment"># 파이썬 3.5 버전 이상</span></span><br><span class="line">    <span class="keyword">from</span> asyncio <span class="keyword">import</span> Queue</span><br></pre></td></tr></table></figure>
<p>우리는 워커들의 공유상태를 crwaler class에 모을 것이고, 메인 로직을 그것의 crwal메서드에 작성할 것이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Queue, get_event_loop</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line">loop = get_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crwaler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root_url, max_redirect)</span>:</span></span><br><span class="line">        self.max_tasks = <span class="number">10</span></span><br><span class="line">        self.max_redirect = max_redirect</span><br><span class="line">        self.q = Queue()</span><br><span class="line">        self.seen_urls = set()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># aiohttp의 클라이언트 세션이 connection을 풀링하고,</span></span><br><span class="line">        <span class="comment"># HTTP Keep-alives for us.</span></span><br><span class="line">        self.session = ClientSession(loop=loop)</span><br><span class="line">        self.q.put((root_url, self.max_redirect))</span><br></pre></td></tr></table></figure>
<p>현재 q에서 끝나지 않은 작업은 하나이다. 우리의 메인 스크립트로 돌아가서,<br>
event루프와 crwal메서드를 실행한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl</span><span class="params">(self)</span>:</span></span><br><span class="line">    workers = [Task(self.work()) <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.max_tasks)]</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> self.q.join()</span><br><span class="line">    <span class="keyword">from</span> w <span class="keyword">in</span> workers:</span><br><span class="line">        w.cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    crawler = Crwaler(<span class="string">"http://xkcd.com"</span>, max_redirect=<span class="number">10</span>)</span><br><span class="line">    loop.run_until_complete(crawler.crawl())</span><br></pre></td></tr></table></figure>
<p>만약 워커가 쓰레드 였다면, 우리는 그들이 동시에 실행되는 것을 원하지 않을 것이다.<br>
그들이 특별히 필요로 해지기 전까지 그들이 생성되는 비용을 피하기 위해서,<br>
쓰레드 풀은 대게 필요한 때에만 커질 것이다.</p>
<p>하지만 코루틴은 저렴하다. 그래서 우리는 그들을 간단히 최대 허용 수만큼 시작할 수 있다.</p>
<p>우리가 어떻게 크롤러를 종료시킬 것인지를 아는 것은 중요하다.<br>
join기능이 해결될 때, worker tasks들은, 살아있지만 종료된 상태 일 것이다.:<br>
그들은 더 많은 URL들을 기다리고 있지만 오지 않은 것이다.</p>
<p>따라서 메인 코루틴은 그들을 종료시키기 전에, 취소 시킬것이다.<br>
그렇지 않으면, 파이썬 인터프리터가 종료되고,<br>
모든 PyObject의 <code>destructors</code>를 호출할 때, 살아있는 tasks들은 외칠것이다.</p>
<p><code>ERROR:asyncio:Task was destroyed but it is pending!</code></p>
<p>그러면 어떻게 <code>cancel</code>은 동작하는가?:<br>
제너레이터들은 당신이 모르는 기능을 가지고 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gen = gen_fn()</span><br><span class="line">gen.send(<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">gen.throw(Exception(<span class="string">"error"</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">Exception: error</span></span><br></pre></td></tr></table></figure>
<p>제너레이터들은 <code>throw</code>를 통해서 재진입 되지만, 예외를 발생하고 있다.<br>
만약 제너레이터의 콜스택의 코드에서 그것을 감지하지 못한다면,<br>
exception은 불어나서, 맨 위로 올라올 것이다.<br>
그래서 task의 코루틴을 취소하기 위해서</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>from asycio import Task</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>worker = Task(self.work())</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>worker.cancel()</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># method of Task class</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cancel</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.coro.throw(CacelledError)</span><br></pre></td></tr></table></figure>
<p>어떤 <code>yield from</code>진술들에서 제너레이터가 정지하면, 이것은 재진입하고 예외를 던진다.<br>
우리는 취소를 task의 <code>step</code>메서드를 통해서 핸들링 할 것이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method of Task class</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(self, future)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        next_future = self.coro.send(future.result)</span><br><span class="line">    <span class="keyword">except</span> CancelledError:</span><br><span class="line">        self.cancelled = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    next_future.add_done_callback(self.step)</span><br></pre></td></tr></table></figure>
<p>이제 task는 그것이 최소 되었는지 알 수 있다. 그래서 이것이 소멸될 때, 소리지르지 않을 것이다.<br>
<code>crawl</code>이 한번 워커를 중지 시키면, 그것은 종료한다.<br>
이벤트루프는 그것을 보면 코루틴이 종료되었다고 코루틴이 프로그램이 종료되기를 기다린다고 본다.</p>
<p><code>loop.run_until_complete(crawler.crawl())</code></p>
<p><code>crwal</code>메서드는 모든 메인 코루틴이 해야하는 것을 해낸다.<br>
이것이 queue에서 URL을 가져오고, 그들을 fetch하고, 새로운 링크를 파싱하는 워커 코루틴이다.</p>
<p>각 워커들은 <code>work</code>코루틴을 개별적으로 실행한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crwaler</span>:</span></span><br><span class="line"><span class="meta">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            url, max_redirect = <span class="keyword">yield</span> <span class="keyword">from</span> self.q.get()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># download page and add new links to self.q</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> self.fetch(url, max_redirect)</span><br><span class="line">            self.q.task_done()</span><br></pre></td></tr></table></figure>
<p>파이썬은 이 코드가 <code>yield from</code>진술을 포함하는 것을 보고, 제너레이터 함수로 컴파일 한다.<br>
따라서 <code>crawl</code>안에, 메인 코루틴이 <code>self.work</code>를 10번 호출할 때,<br>
이것은 실제로 이 함수를 호출 하지 않는다.</p>
<p>그것은 오직 이 코드블록을 바라보는 10개의 제너레이터 객체를 생성할 것이다.</p>
<p>이것은 개별 Task안에 래핑되고, Task는 개별적인 future 제너레이터가 yield하는 것을 받는다.<br>
그리고 <strong>future가 resolve될 때,</strong> 제너레이터를 <code>send</code>에 개별적인 future의 result를 매개변수로 콜하면서 진행할 것이다.<br>
왜냐하면 제너레이터는 개별적인 스텍프레임을 가지고 있고,<br>
개별적으로 동작하고, 개별적인 지역변수와 인스트럭션 포인터를 가졌기 때문이다.</p>
<p>워커는 queue를 통해서 그의 친구들과 정렬된다. 그것은 아래처럼 새로운 URL을 기다릴 것이다.</p>
<p><code>url, max_redirect = yield from self.q.get()</code></p>
<p>queue의 get메서드는 그 자체로 코루틴이다.: 그것은 누군가 queue에 item을 넣을때 까지 정지하고,<br>
이후 돌아와서 들어온 아이템을 리턴한다.</p>
<p>우연히 아곳은 워커가 crwal의 끝부분에서 메인 코루틴이 그것을 중지할때 멈추는 부분이다.<br>
코루틴의 관점에서 보았을 때, 이 루프의 마지막 실행은 <code>yield from</code> 이 <code>CancelledError</code>을 raise할때 일어난다.</p>
<p>워커가 페이지에서 링크들을 파싱하고, 새로운 링크를 큐에 집어 넣을 때, <code>task_done</code>을 통해 counter를 줄인다.<br>
결국 워커는 워커가 모든 URL들이 fetched된 페이지를 fetch하면, 큐에는 더이상 할 일이 남아있지 않다.<br>
그러므로 이 워커가 <code>task_done</code>을 호출하는 것은 카운터를 0으로 줄인다.<br>
그러면 queue의 <code>join</code>메서드를 기다리고 있는 <code>crawl</code>은 다시 재개되고, 마무리한다.</p>
<p><code>aiohttp</code> 패키지는 기본적으로 redirects를 따르고, 우리에게 최종 response를 가져다 준다.<br>
우리가 구분할 수 있건없건, redirects를 크롤러 내에서 핸들링 하고,<br>
결국 이것은 모든 한 목적지로 가는 redirect path들을 coalesce할 수 있다.:</p>
<ul>
<li>COALESCE: SQL함수로, NULL이 아닌 첫 값을 반환하는 기능<br>
만약 해당 URL을 이미 보았다면, 이것은 <code>self.seen_urls</code>에 있을 것이고,<br>
우리는 이미 이 path에 대해새 다른 엔트리 포인트에서 시도해본적 있는 것이다.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">first entry point</th>
<th style="text-align:center">redirects</th>
<th style="text-align:center">destination</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/foo</td>
<td style="text-align:center">/baz</td>
<td style="text-align:center">/quux</td>
</tr>
<tr>
<td style="text-align:center">/bar</td>
<td style="text-align:center">/baz</td>
<td style="text-align:center">/quux</td>
</tr>
</tbody>
</table>
<ol>
<li>/foo에 접근한 워커가 baz를 리디렉트하고, quux로 진행하였다면, baz를 <code>seen_urls</code>로 이동시킨다.</li>
<li>/bar에 접근한 워커가, baz로 리디렉트 한다는 것을 알면, Fetcher은 baz를 이미 <code>seen_urls</code>에 있는 것으로 감안하여 enqueue하지 않는다.</li>
<li>만약 응답이 리디렉션이 아니라 페이지문서였다면, <code>fetch</code>는 이것의 링크를 파싱하고, 새로울 것을 enqueue한다.</li>
</ol>
<blockquote>
<p>STATUS CODE 301 Moved Permanently</p>
<p>301의 HTTP응답은 location헤더가 포함되는 것이 일반적인데,<br>
location헤더에 해당 엔드포인트의 새로운 주소가 포함되어 나온다.<br>
클라이언트는 location헤더의 엔트포인트의 새로운 주소에 해당 요청을 다시 보내게 된다.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Location: http://www.example.org/index.asp</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span></span><br><span class="line"><span class="meta">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(self, url, max_redirect)</span>:</span></span><br><span class="line">        response = <span class="keyword">yield</span> <span class="keyword">from</span> self.session.get(</span><br><span class="line">            url, allow_redirects = <span class="literal">False</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> is_redirect(response):</span><br><span class="line">                <span class="keyword">if</span> max_redirect &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># response가 최초 리디렉션 301 MOVED PERMANENTLY 일때,</span></span><br><span class="line">                    next_url = response.headers[<span class="string">"location"</span>]</span><br><span class="line">                    <span class="comment"># header에 일반적으로 포함되는 location헤더.</span></span><br><span class="line">                    <span class="keyword">if</span> next_url <span class="keyword">in</span> self.seen_urls:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    self.q.put_nowait((next_url, max_redirect - <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                links = <span class="keyword">yield</span> <span class="keyword">from</span> self.parse_links(response)</span><br><span class="line">                <span class="keyword">for</span> link <span class="keyword">in</span> links.difference(self.seen_urls):</span><br><span class="line">                    self.q.put_nowait((link, self.max_redirect))</span><br><span class="line">                self.seen_urls.update(links)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> response.release()</span><br></pre></td></tr></table></figure>
<p>만약 이게 멀티스레딩 코드 였다면, race컨디션이 넘쳐났을 것이다.<br>
예를 들어, 워커가 fetch한 링크가 seen_urls에 있는지 확인하려 한다면,<br>
그리고 그 워커가 그것을 queue에 넣고 seen_urls로 더하지 않는다면.</p>
<p>만약 이것이 다른 두 operation에 사이에서 interrupt되었다면, 다른 워커들은,<br>
같은 링크를 다른페이지에서 파싱할 것이고, 또한 그것이 <code>seen_urls</code>에 존재하지 않는다고 볼 것이다.<br>
그리고 그것을 Queue에 더할 것이다.<br>
그러면 동일한 링크가 Queue에 두번 있는 것이고, 중복된 일과 잘못된 통계를 수집할 것이다.</p>
<p>그러나 코루틴은 오직 <code>yield from</code> 인터럽션에만 취약하다.<br>
이것이 코루틴 코드를 races에 멀티스레딩 코드보다 덜 발생하도록 만드는 주요 차이점이다.:<br>
멀티스레딩 코드는 lock을 취득하는 것을 통해서 명시적으로 공유자원에 접근해야한다. 그렇지 않으면 방해 받을 수 있다.<br>
파이썬 코루틴은 기본적으로 방해 받지 않으며, 명시적으로 <code>yield</code> 할때만, 컨트롤을 양보한다.</p>
<p>우리는 우리가 Callback기반 프로그램에서 그랬던 것처럼 fetcher클래스가 필요하지 않다.<br>
그 클래스는 콜백이 결여된 것이었다.:<br>
그들의 지역변수가 call들 사이에서 유지되지 않았기 때문에, 그들은 I\O를 기다리는 동안 상태를 저장할 장소가 필요하다.</p>
<p>그러나 <code>fetch</code>코루틴은 그것의 상태를 일반적인 서브루틴처럼 저장할 수 있기 때문에, class는 더이상 필요하지 않다.</p>
<p><code>fetch</code>가 <code>work</code>콜러에게 response를 돌려주는 마무리를 할 때,<br>
<code>work</code>메서드는 <code>task_done</code>을 queue에서 호출하여, 다음 URL을 queue에서 가져온다.</p>
<p><code>fetch</code>가 새로운 링크를 큐에 넣을 때, 완료되지 않은 tasks의 count를 증가시키고, <code>q.join</code>을 기다리고 있는 메인 코루틴을 정지된 상태로 유지 시킨다.<br>
그러나, 거기에 unseen링크가 없고, 그것이 queue에서 마지막 URL이었을 때,<br>
<code>work</code>는 <code>task_done</code>을 호출하고, 완료되지 않은 tasks의 count는 0으로 떨어진다.<br>
이벤트는 <code>join</code>을 재개시키고, 메인 코루틴은 종료된다.</p>
<p>워커들과 메인 코루틴은 정렬하는 Queue코드는 아래와 같다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._join_future = Future()</span><br><span class="line">        self._unfinished_tasks = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put_nowait</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self._unfinished_tasks = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">task_done</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._unfinished_tasks -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> !(self._unfinished_tasks):</span><br><span class="line">            self._join_future.set_result(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._unfinished_tasks:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> self._join_future</span><br></pre></td></tr></table></figure>
<p>메인 코루틴, crawl은 <code>join</code>에서 <code>yield from</code>된다.<br>
따라서 마지막 워커가 unfinished_tasks를 0으로 처리하면, 예약한 시그널이 발생해서 crawl로 재진입하고, 종료한다.</p>
<p><code>loop.run_until_complete(self.crawler.crawl())</code></p>
<p>어떻게 프로그램이 종료 되는가? <code>crawl</code>이 제너레이터 함수 이기 때문에, 이것을 호출하는 것은 제너레이터를 리턴한다.<br>
제너레이터를 진행시키기 위해서, asyncio는 이것을 task안에 래핑한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopError</span><span class="params">(BaseException)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop_callback</span><span class="params">(future)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> StopError</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(self, coro)</span>:</span></span><br><span class="line">        task = Task(coro)</span><br><span class="line">        task.add_done_callback(stop_callback)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run_forever()</span><br><span class="line">        <span class="keyword">except</span> StopError:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>Task가 종료될 떄, 그것을 StopError을 raise하고, 루프는 그것을 시그널로 간주한다.</p>
<p>그러면 이것은 무엇인가? Task는 <code>add_done_callback</code>과 <code>result</code>라 불리는 메서드가 있다?<br>
당신은 task가 future를 닮았다고 생각할 수 있다. 당신의 직감을 옳다.<br>
우리는 당신에게 숨긴 Task class에 대한 세부 디테일을 가져와야 한다. task는 future이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">(Future)</span>:</span></span><br><span class="line">    <span class="string">"""A coroutine wrapped in a Future."""</span></span><br></pre></td></tr></table></figure>
<p>일반적으로 future은 누군가가 set_result를 할때 해제된다.<br>
그러나 task는 그것의 코루틴이 멈출 때, 자신을 해제시킨다.<br>
generator가 값을 리턴할 때, 그것을 특별한 <code>StopIteration</code>예외를 발생시켰던 것을 기억하라.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">(Future)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, coro)</span>:</span></span><br><span class="line">        self.coro = coro</span><br><span class="line">        f = Future()</span><br><span class="line">        f.set_result(<span class="literal">None</span>)</span><br><span class="line">        self.step(f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(self, future)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            next_future = self.coro.send(future.result)</span><br><span class="line">        <span class="keyword">except</span> CancelledError:</span><br><span class="line">            self.cancelled =<span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line">            self.set_result(exc.value)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        next_future.add_done_callback(self.step)</span><br></pre></td></tr></table></figure>
<p>따라서 이벤트 루프가 <code>task.add_done_callback(stop_callback)</code>을 호출할 때,<br>
콜백은 <code>StopError</code>를 루프내에서 발생시킨다.<br>
루프는 멈추고 콜 스택은, <code>run_util_complete</code>로 복귀(Unwound to)한다.<br>
우리 프로그램은 종료 되었다.</p>
<h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2>
<p>꽤 자주, 현대적인 프로그램은 CPU-bound하기 보다 I/O-bound한 일이 잦다.<br>
그러한 프로그램에서 파이썬의 쓰레드들은, 두 곳에서 전부 최악의 경우이다.:<br>
GIL에 의해서 락을 가진 쓰레드만을 인터프리터가 실행하기 때문에, 병행-컴퓨팅을 방지하고,<br>
선점형 스위칭은 레이스컨디션을 매우 줄여버린다.<br>
Async는 가끔 정답인 패턴이다. 하지만 콜백기반 비동기 코드가 커질수록, 이것은 종잡을 수 없이 난잡해지는 경항이 있다.<br>
코루틴들은 쌍당한 대처법이라 할 수 있다.<br>
그들은 자신들을 제대로 된 에러 핸들링과, 스택트레이싱을 통해서, 서브코루틴으로 자연스럽게 구성해낸다.</p>
<p>우리가 <code>yield from</code>문을 슬쩍 애매하게 본다면, 코루틴은 마치 기존의 blocking-io인 쓰레드가 하는 것처럼 보인다.<br>
우리는 멀티쓰레딩-프로그래밍처럼 코루틴들을 정렬해서, 고전적인 패턴처럼 보이게 할 수도 있다.<br>
그러므로, 콜백들에 비교해서 코루틴은 멀티쓰레딩으로 익숙한 코더들에게 익숙한 관용구이다.</p>
<p>그러나 우리가, <code>yield from</code>문을 제대로 인식하려 할 때,<br>
우리는 코루틴이 실행 컨텍스트를 넘겨주는 시기 같이, 유심히 체크해야할 포인트 들이 있다.<br>
쓰레드와 달리 코루틴들은 우리의 코드를 interrupted될 수 있는 것으로 보여준다.<br>
Glyph Lefkowitz가 적었듯이,</p>
<blockquote>
<p>“쓰레드들은 지역적인 추리를 어렵게 한다. 그리고 지역적인 이해는 소프트웨어 개발에서 가장 중요한 것중 하나이다.”</p>
</blockquote>
<p>명시적으로 <code>yielding</code>하는 것은 반면에 모든 시스템을 시험하는 것이 아닌 루틴으로써,<br>
루틴을 시험하는 것으로 루틴의 행동을 이해할 수 있도록 한다.</p>
<p>(중략…간편하게 사용할 수 있는 인터페이스가 버전업이 되면서 제공되었다 라는 등의 이야기, <code>async def</code>, <code>await</code>)</p>
<p>이런 발전들에 불구하고, 기존의 코어 개념은 그대로 있다. 파이썬의 새로운 내장 코루틴들은,<br>
통상적으로, 제너레이터와 구분되지만, 매우 유사하게 동작한다.<br>
게다가, 그들은 파이썬 인터프리터 내에서, 그 실행부를 공유한다.<br>
<code>Task</code>, <code>Future</code>, <code>event loop</code>같은 것들은 <code>asyncio</code>에서 계속 그들의 역할을 맞을 것이다.</p>
<p>이제 당신은 어떻게 <code>asyncio</code> 코루틴이 동작하는지 알았으니, 세부적인 것은 조금 잊어도 좋다.<br>
기계공은 매끈한 인터페이스 뒤에 dlTek.<br>
그러나 당신이 구조를 이해한다면, 너의 코드를 요즘 비동기 환경에서 더욱 효과적이고 올바르게 강화해줄 것이다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/09/05/python/post/async_coroutine_5/" data-id="ckkdb52hl002h1pqkbnrjllsr" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/pointer_in_python" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/30/python/post/pointer_in_python/" class="article-date">
  <time datetime="2019-08-30T11:21:27.000Z" itemprop="datePublished">2019-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/30/python/post/pointer_in_python/">pointer in python 번역</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="pointer-in-python-whats-the-point"><a class="markdownIt-Anchor" href="#pointer-in-python-whats-the-point"></a> <a href="https://realpython.com/pointers-in-python/" target="_blank" rel="noopener">Pointer in python: What’s the point</a></h2>
<blockquote>
<p>번역, 정리글입니다.</p>
</blockquote>
<h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> index</h2>
<ol>
<li><a href="#%EC%99%9C_%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90%EB%8A%94_%ED%8F%AC%EC%9D%B8%ED%84%B0%EA%B0%80_%EC%97%86%EB%8A%94%EA%B0%80"><strong>Why Doesn’t Python have Pointers?</strong></a></li>
<li><a href="#object_in_python"><strong>Objects in Python</strong></a></li>
<li><a href="#mutable_vs_immutable"><strong>Immutables vs Mutable objects</strong></a></li>
<li><a href="#understanding_variables"><strong>Understading Variables</strong></a>
<ol>
<li><strong>Variables in C</strong></li>
<li><strong>Names in Python</strong></li>
<li><strong>A Note on Intern Objects in Python</strong></li>
</ol>
</li>
<li><a href="#simulating_pointers_in_python"><strong>Simulating Pointers in Python</strong></a>
<ol>
<li>[<strong>Using Mutable Types as Pointers</strong>]</li>
<li>[<strong>Using Python Objects</strong>]</li>
</ol>
</li>
<li><a href="#real_pointers_with_ctypes"><strong>Real Pointers With ctypes</strong></a></li>
</ol>
<h2 id="왜_파이썬에는_포인터가_없는가"><a class="markdownIt-Anchor" href="#왜_파이썬에는_포인터가_없는가"></a> 왜_파이썬에는_포인터가_없는가</h2>
<p>포인터가 파이썬에서 네이티브하게 존재할 수 는 없을까? 잘은 모르지만 아마 가능할 것이다.<br>
그러나 파이썬의 포인터는 <strong>Zen of Python</strong>에 위배되는 것처럼 보인다.</p>
<blockquote>
<p><strong>Zen of python</strong> / Cpython의 구현의 주요 기여자인 Tim peters의 20개 명언</p>
<p>Beautiful is better than ugly.<br>
Explicit is better than implicit.<br>
Simple is better than complex.<br>
Complex is better than complicated.<br>
Flat is better than nested.<br>
Sparse is better than dense.<br>
Readability counts.<br>
Special cases aren’t special enough to break the rules.<br>
Although practicality beats purity.<br>
Errors should never pass silently.<br>
Unless explicitly silenced.<br>
In the face of ambiguity, refuse the temptation to guess.<br>
There should be one-- and preferably only one --obvious way to do it.<br>
Although that way may not be obvious at first unless you’re Dutch.<br>
Now is better than never.<br>
Although never is often better than <em>right</em> now.<br>
If the implementation is hard to explain, it’s a bad idea.<br>
If the implementation is easy to explain, it may be a good idea.<br>
Namespaces are one honking great idea – let’s do more of those!</p>
</blockquote>
<p>포인터는 명시적인 변화보다 내재적인 변화를 촉구한다.<br>
때로, 그들은 단순하기보다 복잡하고(특히 초보자들에게,) 더욱 나쁜것은,<br>
그들은 당신이 직접 하기를 원하고, 또는 메모리에 접근하기 때문에 매우 위험할 수 있다.</p>
<p>파이썬은 메모리 주소 같은 디테일의 구현을 추상화하려한다.<br>
파이썬은 때로 속도보다 사용감에 집중한다.<br>
결과적으로 파이썬에서 포인터는 말이 되지 않는다.<br>
그러나 파이썬은 결과적으로 포인터를 사용하는데 있어서의 이점을 준다.</p>
<p>파이썬의 포인터를 이해하는 것은 파이썬 구현부의 디테일을 돌아볼 필요가 있다.</p>
<ol>
<li>Immutable vs Mutable objects</li>
<li>Python variables/names<br>
를 이해할 필요가 있다.</li>
</ol>
<h2 id="object_in_python"><a class="markdownIt-Anchor" href="#object_in_python"></a> Object_in_Python</h2>
<p>파이썬의 모든 자료구조는 기본 object를 상속받는 인스턴스 클래스들이다.<br>
각 객체는 3개의 데이터를 최소한 포함한다.</p>
<ul>
<li>Reference count</li>
<li>Type</li>
<li>Value<br>
레퍼런스 카운트는 메모리 관리를 위한 것이고, 파이썬의 메모리 관리를 이해하고 싶다면,<br>
<a href="https://realpython.com/python-memory-management/" target="_blank" rel="noopener">Memory Management in Python</a>를 읽어보면 좋다.</li>
</ul>
<hr>
<blockquote>
<p><strong>Python object</strong></p>
<p><code>PyObject</code>라고 불리는 구조체가 있다. 모든 Cpython의 객체가 사용하는 것이다.<br>
<code>PyObject</code>는 모든 객체의 부모이며, 아래의 2요소를 포함한다.</p>
<ul>
<li><code>ob_refcnt</code>: 레퍼런스 카운트</li>
<li><code>ob_type</code>: 어떤 타입에 관한 포인터</li>
</ul>
<p>각 객체는 그들 각자의 object-specific memory allocator을 가지고 있다.<br>
그것은 그들 객체를 위한 메모리를 가져온다.<br>
각 객체는 또한 object-specific memory deallocator을 가지고 있다.<br>
그것은 그들의 객체들이 refcount에 따라 메모리를 <code>free</code>한다.</p>
<p>그러나 메모리를 할당하고 해제하는 것에 있어서, 중요한 요소가 있다.<br>
메모리는 컴퓨터의 공유자원이며, 두 개의 프로세스가 동시 접근하려고 하면 문제가 생긴다는 것이다.</p>
<p>GIL은 공유자원 Race Condition에 대한 해결책중 하나이다.</p>
<hr>
<blockquote>
<p><a href="https://realpython.com/python-gil/" target="_blank" rel="noopener"><strong>GIL</strong></a></p>
<p>GIL은 짧게 말해서 mutex이며, 하나의 쓰래드 만이 파이썬 인터프리터를 제어할 수 있도록 한다.</p>
<p>이 말은, 하나의 쓰레드만이 실행부의 상태에 있을 수 있다는 것이다.<br>
GIL의 부하는 싱글쓰레드 프로그램을 하는 사람들에게는 나타나지 않는다.<br>
이것은 CPU-bound한 문제, 멀티쓰레딩 코드 에서 bottleneck이 될 수 있는 것이다.</p>
<p><strong>GIL이 파이썬의 어떤 문제를 해결해 주는가?</strong></p>
<p>파이썬은 메모리 관리를 위해 refcount를 사용한다. 그것은 파이썬에서 생성된 objects 구조체가 refcount변수를 가지고 있고 추적되고 있다는 것을 의미한다.<br>
이것이 0이 되었을 때, 해당 객체가 점유하는 메모리는 해제된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="keyword">import</span> sys</span><br><span class="line">&gt; &gt; a = []</span><br><span class="line">&gt; &gt; b = a</span><br><span class="line">&gt; &gt; sys.getrefcount(a)</span><br><span class="line">&gt; &gt; <span class="comment">#3</span></span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>a에 처음 할당된 메모리 주소에 대해서 a,b가 참조하고, sys.getrefcount에 전달된 argument가 순간적으로 참조하고 해제된다. 그래서 3이 나온다.<br>
GIL로 돌아가서,</p>
<p>문제는 Refcount변수가 race-condition에서 보호받아야 한다는 것이다.<br>
만약 2개의 쓰레드가 동시에 그 수치를 늘리거나 줄이면,<br>
메모리 누수를 초래해서, 절때 해제되지 않거나, 원치 않게 해제된다는 것이다.</p>
<p>이 refcount변수는 locks를 더함으로 안전하게 보관되어,<br>
쓰레드에 의해 공유되는 모든 자료구조가 일관적이지 않게 수정되는 것을 막는다.<br>
하지만 각 객체에 lock을 더하는 것은 너무 많은 lock이 존재하여 다른 문제를 발생 시킬 수 있다는 것을 의미한다.</p>
<p><code>Deadlocks</code> (데드락은 하나이상의 락이 있을 때 생길 수 있다.)<br>
특정 자원에 2쓰레드 혹은 프로세스가 순차적으로 접근하려고 하면, 두번째 쓰레드는 첫번째 쓰레드가 락을 해제할 때까지 끝없이 기다리게 된다.</p>
<p>다른 문제로는 락을 반복적으로 생성하고 해제하는 것으로 인한 퍼포먼스 저하가 있다.<br>
GIL은 인터프리터에 대한 단일 lock을 의미하며,<br>
GIL은 바이트코드를 실행하려면 인터프리터 잠금을 획득해야 한다는 규칙을 추가한다.<br>
이것이 deadlocks를 방지하고, 그렇게 많은 퍼포먼스를 요구하지 않도록 한다.(성능적 오버헤드를 방지)<br>
하지만 Cpu-bound한 파이썬 프로그램을 싱글쓰레드로 효과적으로 만들어 버린다.</p>
<p>하지만 Refcount와 GC를 이용한 GIL을 사용하지 않는 경우도 있다<br>
반면에 그것을 그러한 언어들이 때로 GIL이 효과적으로 싱글 쓰레드에 대해서 퍼포먼스 이점을 주는 것을<br>
다른 보상으로 채워야 한다는 것을 의마한다, 예를 들면 JIT컴파일러 같은 것을 통해서.</p>
<hr>
<p><strong>왜 GIL이 해결책으로 선택 되었는가?</strong></p>
<p><a href="https://www.youtube.com/watch?v=KVKufdTphKs&amp;feature=youtu.be&amp;t=12m11s" target="_blank" rel="noopener"><strong>Larry Hastings</strong></a>의 말에 따르면, GIL을 선택한 것은 파이썬을 오늘날 만큼 유명하게 만든 하나의 이유라고 한다.<br>
파이썬은 OS가 쓰레드의 개념이 없을때 생겨 났다.<br>
파이썬은 쉽게 사용될 수 있고 빠르게 개발할 수 있도록 만들어 졌다.</p>
<p>이후 파이썬의 일관적이지 않은 변화를 예방하기 위해서, 이 파이썬을 지탱하는 C라이브러리는,<br>
Thread-safe 메모리 관리를 필요로 했고, 그래서 GIL이 생겨 났다.<br>
GIL은 실행하기 쉽고 파이썬에 쉽게 더해졌다.<br>
이것은 싱글 쓰레드 상에서 하나의 락만이 관리되야한다는 점에 의해 퍼포먼스 향상을 가져왔다.<br>
쓰레드세이프 하지 않은 C라이브러리 들은 더욱 통합하기 쉬워졌다.<br>
그렇게 통합된 C라이브러리들이 파이썬이 여러 커뮤니티에서 손쉽게 적용될 수 있었던 이유이기도 하다.</p>
<p>니가 볼 수 있듯이, GIL은 Cpython개발자들이 초기 파이썬에서 복잡한 문제를 빠르게 해결할 수 있는 방법이었다.</p>
<hr>
<p><strong>왜 GIL은 아직 사라지 않았는가?</strong></p>
<p>GIL은 명백하게 사라질 수 있고, 그런 시도들이 많았으나, 그러한 시도들은 GIL이 주는 해결책에 의존하는 C-extensions를 망가뜨렸다.<br>
물론, GIL을 대체하는 해결책도 있지만, 하지만 그들의 일부는 싱글쓰레드, 멀티쓰레드/IO바운드 프로그램에 성능을 떨어뜨렸고,<br>
일부는 너무 어려웠다.<br>
어찌됐든, 지금 존재하는 파이썬 프로그램이 새로운 버전이 나옴으로 더 느려지는 바라는 사람은 없지 않은가?</p>
<p>귀도 반 로썸이 <a href="https://www.artima.com/weblogs/viewpost.jsp?thread=214235" target="_blank" rel="noopener">It isn’t Easy to Remove the GIL</a>의 포스트로 2007년에 해명을 했다.</p>
<blockquote>
<p>“나는 Py3k에 대한 패치들을 환영할 것이다. 만약! <strong>퍼포먼스가 떨어지지 않는다면.</strong>”</p>
</blockquote>
</blockquote>
<hr>
<p><strong>Garbage Collection</strong></p>
<p>파이썬의 모든 구조체에는 Refcount라는 것이 있고 아래와 같은 경우들에 증가한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt; more_numbers = numbers</span><br><span class="line">&gt; <span class="comment"># refcount = 2</span></span><br><span class="line">&gt; total = sum(numbers) <span class="comment"># refcount = 3</span></span><br><span class="line">&gt; <span class="comment"># refcount = 2</span></span><br><span class="line">&gt; matrix = [numbers, numbers]</span><br><span class="line">&gt; <span class="comment"># refcount = 4</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>파이썬은 현재 오브젝트의 러퍼런스 카운트를 sys모듈을 통해서 확인 할 수 있게 해준다. <code>sys.getrefcount(object)</code><br>
그렇지만 deallocate기능을 사용하게 되면, 어떻게 메모리가 <code>free</code>되는가? 어떻게 객체가 그 과정을 거치는가?</p>
<hr>
<p><strong>Cpython의 메모리 관리자</strong></p>
<p>위에서 말했듯, 하드웨어에서 Cpython으로 이어지는 추상화 계층이 있다.<br>
OS는 실제 물리메모리를 추상화 하고 가상메모리 계층을 만들어 어플리케이션이 접촉할 수 있도록 한다.</p>
<p>OS에 따른 메모리 관리자들은 파이썬 프로세스를 위한 메모리 청크를 조각해낸다.<br>
파이썬은 일단 운영체제에 malloc함수로 메모리할당을 요구한 다는 것을 알아야한다.</p>
<p>파이썬 프로세스는 내부적인 사용을 위한 메모리공간과 비객체적인 메모리를 위한 공간을 사용한다.<br>
마지막 공간은 object storage를 위해 사용된다.(<code>int, dict, and elses</code>)<br>
메모리 관리의 구현부인 <a href="https://github.com/python/cpython/blob/7d6ddb96b34b94c1cbdf95baa94492c48426404e/Objects/obmalloc.c" target="_blank" rel="noopener">Cpython source</a>를 참고해도 좋다.</p>
<p>객체 메모리 공간에 파이썬은 object allocator을 두고 있다. 그것이 대부분의 기능이 이루어 지는 곳이다.<br>
흔한 경우로, <code>list</code>나 <code>int</code>같은 파이썬 객체를 생성하거나 삭제하는 것은 그렇게 많은 데이터를 필요로 하지 않는다.<br>
따라서, 메모리 할당자는 작은 양의 데이터 많으로 잘 작동하도록 되어 있다.<br>
그리고 그것은 실제로 그 객체가 필요해지기 전까지 메모리에 할당하지 않으려고 한다.</p>
<p>위에 <code>Cpython source</code>구현부에서는, 객체 할당자를<br>
“작은 블록을 위한 빠르고, 특별한 용도를 위한 메모리 할당자이다. 그리고 일반적인 목적의 <code>malloc</code>위에서 실행된다.”<br>
라고 설명한다.</p>
<p>이제 Cpython의 메모리 할당 전략에 대해 살펴볼 것 이다.<br>
<code>Arenas</code>는 페이지 범위내에서 가장 크고 정렬된 단위이다.<br>
페이지 영역은 고정된 길이의 연속적인 메모리 청크라고 할 수 있다.(실제 주소가 달라도, 가상주소상으론 연속적인 주소 그리고 실제주소는 랜덤 엑세스가 가능하기 때문에,)<br>
파이썬은 시스템의 페이지 사이즈를 256kb정도 라고 가정한다.(내 컴퓨터 페이지 사이즈는 4kb이다)</p>
<p><code>Arenas</code>내부에는 <code>pools</code>가 있고, 그것은 하나의 가상 메모리 페이지이다.<br>
그리고 풀은 실제로 동적 할당으로서 작은 메모리 사이즈로 조각난다.<br>
풀 내부에 모든 블록은 동일한 <code>size class</code>이다.<br>
<code>size class</code>는 특정 블록 사이즈를 정의하고, 요청한 정보가 들어간다.<br>
아래 차트는 소스코드에서 직접 가져온 커멘트이다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Request in bytes</th>
<th style="text-align:center">Size of allocated block</th>
<th style="text-align:center">Size class Index</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1-8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">9-16</td>
<td style="text-align:center">16</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">17-24</td>
<td style="text-align:center">24</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">25-32</td>
<td style="text-align:center">32</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">505-512</td>
<td style="text-align:center">512</td>
<td style="text-align:center">63</td>
</tr>
</tbody>
</table>
<p>예를 들어 42바이트의 데이터가 요청되었다면, 데이터는 48-byte블록까지 차지하게 될 것이다.</p>
<hr>
<p><strong>Pools</strong></p>
<p>Pools는 단일 size class로부터 조합된 블록들로 구성된다.<br>
각 풀은 double-linked list로 같은 size class로 구성된 다른 풀들로 연결되어 있다. 그런 방식에서 볼 때,<br>
더블링크드리스트를 통한 알고리즘은 쉽게 블록사이즈 만큼 요구된 공간을 다른 풀들 사이에서 찾을 수 있는 것이다.</p>
<p>사용된 Pool들의 리스트는 할당가능한 블록들이 남아있는 모든 풀들을 추적한다.<br>
어떤 블록 사이즈가 요구되면, 알고리즘이 <code>usedpools</code>리스트를 확인하여, 블록사이즈가 할당 가능한 pool list를 반환한다.<br>
Pool들은 각자 3가지 상태가 존재한다.</p>
<ul>
<li>used: 저장가능한 <code>avaliable blocks</code>를 지님.</li>
<li>full: 모든 블록들에 데이터가 할당되었음.</li>
<li>empty: 아무런 데이터가 없고, 언제든 어떤 사이즈의 블록들도 할당 할 수 있다.</li>
</ul>
<p><code>freepools</code>리스트가 비어있는 상태의 풀들의 리스트를 추적한다. 그러면 언제 비어있는 풀은 사용되는 가?<br>
네가 8byte의 청크 메모리를 할당해야 한다고 치자.<br>
만약 거기에 8바이트를 할당 할 수 있는 <code>usedpools</code>가 없다면, 새로운 <code>empty pool</code>애 8바이트가 초기화 될 것이다.<br>
이 새로운 <code>pool</code>은 <code>usedpools</code>리스트로 더해지고, 이것은 이후에 올 요청의 첫 대상이 된다.<br>
마찬가지로 <code>full</code>상태인 <code>pool</code>이 일부 블록을 해제한다면, <code>usedpools</code>리스트로 옮겨진다.</p>
<hr>
<p><strong>Blocks</strong></p>
<p>아까 블록에 실제로 데이터가 할당 되는 것은 해당 블록의 데이터가 실제로 필요해질 떄 그럴 것이라고 했었다.<br>
그러한 이유로 blocks도 3가지 상태를 가진다.</p>
<ul>
<li>untoched: 아직 할당 되지 않은 메모리블록.</li>
<li>free: 데이터가 할당된 블록이나, Cpython에 의해서 <code>free</code>되어서 현재 유효한 데이터가 들어있지 않은 블록.</li>
<li>allocatd: 실제로 데이터를 가지고 있는 블록.</li>
</ul>
<p><code>freeblock</code> 포인터는 single linked list인 비어있는 메모리 블록의 list를 가르킨다.<br>
더 많은 길이의 블록이 필요하면, 메모리 할당자는 해당 풀 안에 <code>untouched</code>블록을 더해서 돌려줄 것이다.<br>
할당되어 있던 블록(allocated)가 해제되어 free상태가 되면,<br>
single linked list인 Free block list의 head로 오게 된다.</p>
<hr>
<p><strong>Arenas</strong></p>
<p>아레나들은 pools를 포함한다. pools와 blocks는 3가지 상태가 있었던 반면, 아레나들은 명시적인 상태가 없다.<br>
아레나들은 반면에 <code>usable_arenas</code>라 불리는 Double linked list로 구성 및 조직된다.<br>
이 리스트는 freepools를 얼마 가지고 있냐에 따라 정렬된다.<br>
freepools가 적을수록 해당 아레나는 리스트의 head쪽으로 오게 된다.</p>
<p>그런데 왜 가장 사용가능한 데이터가 많은 arena가 아니라 그 반대인가? 그곳에 메모리해제의 개념이 있다.<br>
block이 free하게 전환되면, 그 메모리는 실제로 OS에게로 돌아가는 게 아니라,<br>
파이썬 프로세스가 그 공간을 계속 점유하고, 다음 데이터를 위해 사용할 것이다.<br>
실제로 메모리를 해제한다면 OS에게 돌려주는 것을 의미한다.</p>
<p>아레나야 말로 유일하게 정말 해제될 수 있는 메모리이다.<br>
따라서, 가장 많이 비어있는 데이터가 가장 쉽게 empty arena가 될 수 있도록 그러한 것이다.<br>
그 방식에서 메모리의 청크는 실제로 해제되고, 파이썬 프로세스의 점유나 감시에서 벗어날 수 있도록 돕는 것이다.</p>
</blockquote>
<p>type은 Cpython계층에서 타입안전성을 런타임에서 보장할 때 사용된다.<br>
마지막으로 value가 실제로 object와 관련된 페이로드를 말한다.</p>
<p>모든 객체가 동일한 객체는 아니나, 그런 단순한 사실 외에도 당신이 꼭 알아야할 더 중요할 구분이 있다.<br>
<strong>mutable vs immutable</strong>객체 이다. 이 두 타입의 객체의 차이를 이해하는 것은, 파이썬의 포인터의 초반부를 이해하는데 굉장히 도움이 된다.</p>
<hr>
<h2 id="mutable_vs_immutable"><a class="markdownIt-Anchor" href="#mutable_vs_immutable"></a> mutable_vs_immutable</h2>
<table>
<thead>
<tr>
<th style="text-align:center">type</th>
<th style="text-align:center">immutable?</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">bool</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">complex</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">tuple</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">frozenset</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">str</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">set</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">dict</td>
<td style="text-align:center">No</td>
</tr>
</tbody>
</table>
<p>위에 보이듯 대부분 사용되는 원시타입들은 immutable하다. 아래 기능을 사용하여 그것을 검증할 수 있다.</p>
<ol>
<li><code>id()</code>: object’s memory address를 반환</li>
<li><code>is</code>: 두 개체가 동일한 메모리 주소를 가지고 있다면 True를 반환.</li>
</ol>
<h2 id="understanding_variables"><a class="markdownIt-Anchor" href="#understanding_variables"></a> Understanding_Variables</h2>
<p>파이썬의 변수는 구조적으로 C, C++과 다르다. 사실, 파이썬은 변수가 존재 하지 않고, <code>names</code>가 존재한다.<br>
이것은 현학적으로 보일 수 있다. 대부분의 경우에 파이썬의 names를 변수로 이해하는 경우가 많다. 그러나 차이를 아는 것은 중요하다.<br>
C에서 변수와 파이썬의 name을 대조하는 것으로 이해하자.</p>
<ul>
<li>C</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">2337</span>;</span><br><span class="line"><span class="comment">// x.Location = 0x7f1</span></span><br><span class="line"><span class="comment">// x.value = 2337</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">2338</span>;</span><br><span class="line"><span class="comment">// x.Location = 0x7f1</span></span><br><span class="line"><span class="comment">// x.value = 2338</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y = x;</span><br><span class="line"><span class="comment">// y.Location = 0x7f5</span></span><br><span class="line"><span class="comment">// y.value = 2338</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Python</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">2337</span></span><br><span class="line">x = <span class="number">2338</span></span><br><span class="line">y = x</span><br></pre></td></tr></table></figure>
<ol>
<li>Create PyObject</li>
<li>set The typecode to integer to PyObject</li>
<li>Set the value to 2337 for the PyObject</li>
<li>Create a name called x</li>
<li>Point x to the new PyObject</li>
<li>Increase the refcount of the PyObject by 1</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">PyObject-Type</th>
<th style="text-align:center">PyObject-Value</th>
<th style="text-align:center">PyObject_RefCount</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">integer</td>
<td style="text-align:center">2337</td>
<td style="text-align:center">1-&gt;0()</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">integer</td>
<td style="text-align:center">2338</td>
<td style="text-align:center">0-&gt;1</td>
</tr>
<tr>
<td style="text-align:center">y</td>
<td style="text-align:center">integer</td>
<td style="text-align:center">2338</td>
<td style="text-align:center">1-&gt;2</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>y is x</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>파이썬에서 너는 변수에 값을 할당하는 것이 아니라, 이름을 Pyobject_레퍼런스에 할당하는 것이다.</p>
</blockquote>
<h3 id="a_note_on_intern_objects_in_python"><a class="markdownIt-Anchor" href="#a_note_on_intern_objects_in_python"></a> A_Note_on_Intern_objects_in_python</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>x = 1000</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>y = 1000</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>x is y</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>x = 1000</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>y = 499 + 501</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>x is y</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<ol>
<li>Create PyObject(1000)</li>
<li>Assign the name <code>x</code> to that object</li>
<li>Create PyObject(499)</li>
<li>Create PyObject(501)</li>
<li>Add these two Objects</li>
<li>Create new PyObject(1000)</li>
<li>Assign the name <code>y</code> to that object</li>
</ol>
<blockquote>
<p>위에 과정은 REPL에서만 위처럼 동작한다.<br>
만약 파일로서 만들고 실행하면, <code>x is y</code>라는 것은 True가 나올 것이다.</p>
<p>이것은 CPython컴파일러가 영리하게 처리하기 때문에 그렇다.<br>
Cpython컴파일러의 Optimizations를 <code>peephole optimizations</code>으로 수행하려 하는데,<br>
실행부를 최대한 줄이려고 하는 것이다.<br>
<a href="https://github.com/python/cpython/blob/master/Python/peephole.c" target="_blank" rel="noopener">SourceCode on peephole.c</a>를 확인가능하다.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>x = 20</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>y = 19 + 1</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>x is y</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>위의 결과가 위의 결과가 다른 이유는 파이썬의 이미 존재하는 객체를 재사용 하는 특성 때문이다.(interned object)<br>
파이썬은 일부의 셋의 객체를 실행할 떄 미리 만들고, global namespace에 저장해놓고 사용한다.</p>
<p>CPython 3.7에 따르면 Interned Object는 아래를 따른다.</p>
<ol>
<li>integer numbers between -5 and 256</li>
<li>String taht contains ASCII letters , digits, or underscores only</li>
</ol>
<p>위의 범위에 포함되는 값들의 타입을 생성하면, 내제되있는 미리 생성된 global namespace에 존재하는 것을 레퍼런싱 하도록 한다.<br>
그것은 물론 Cpython based 3.7이상이라면, 프로세스가 종료될 때까지 유효하다.<br>
이를 통해서 작은 값들은 미리 존재하는 것들을 사용해서(자주 사용될 것으로 예상되는 범위의 것들을) 메모리 할당을 줄인다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>s1 = "realpython"</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>s2 = "realpython"</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>s1 is s2</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>s1 = "Real Python!"</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>s2 = "Real Python!"</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>s1 is s2</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>import sys</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>sys.intern(s2)</span></span><br><span class="line"><span class="string">"Real Python"</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>위의경우는 <code>!</code>(exclumation mark)때문에 생기는 현상이다.<br>
이 문자열은 내부 저장된 값이 아닌 것을 사용하기 때문에, 완전히 새로운 Pyobject를 생성하는 것이다.</p>
<hr>
<h2 id="simulating_pointers_in_python"><a class="markdownIt-Anchor" href="#simulating_pointers_in_python"></a> simulating_pointers_in_python</h2>
<p>파이썬에 포인터가 구현되어 있지 않다고 해서, 포인터를 사용하는 것에서 이점을 얻을 수 없다는 것은 아니다.<br>
사실 포인터를 흉내낼 수 있는 여러 방법이 있다.</p>
<ol>
<li>Using mutable types as pointers</li>
<li>Using custom Python objects</li>
</ol>
<h3 id="using_mutable_types_as_pointers"><a class="markdownIt-Anchor" href="#using_mutable_types_as_pointers"></a> using_mutable_types_as_pointers</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mutable인 List 사용해서 흉내</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>def add_one(x):</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>    x[0] += 1</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>#</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>y = [2337]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>add_one(y)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>y[0]</span></span><br><span class="line"><span class="string">2338</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># mutable인 dict 사용해서 흉내</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>counters = &#123;"func_calls": 0&#125;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>def bar():</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>    counters["func_calls"] += 1</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>#</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>def foo():</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>    counters["func_calls"] += 1</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>    bar()</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>#</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>foo()</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>counters["func_calls"]</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>이것은 C나 C<ins>의 실제 포인터가 아니라, 흉내내는 것이기 때문에,<br>
논법적으로 봤을때, 이 행동으로 조정하는 것은<br>
C나 C</ins>의 포인터를 다루는 것보다 훨씬 비용이 비싸다.</p>
</blockquote>
<h3 id="using_python_objects"><a class="markdownIt-Anchor" href="#using_python_objects"></a> using_python_objects</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Metrics</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._metrics = &#123;</span><br><span class="line">            <span class="string">"func_calls"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">"cat_pictures_served"</span>: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_calls</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._metrics[<span class="string">"func_calls"</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cat_pictures_served</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._metrics[<span class="string">"cat_pictures_served"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inc_func_calls</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._metrics[<span class="string">"func_calls"</span>] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inc_cat_pics</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._metrics[<span class="string">"cat_pictures_served"</span>] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>func_calls</code>나 <code>cat_pictures_served</code>속성자를 통해서 포인터처럼 접근 할 수 있지만,<br>
이것 또한 그저 흉내이고, 이것은 자주 변경되는 것을 처리할 때 유용한 방식이다.</p>
</blockquote>
<hr>
<h2 id="real_pointers_with_ctypes"><a class="markdownIt-Anchor" href="#real_pointers_with_ctypes"></a> real_pointers_with_ctypes</h2>
<p><code>ctypes</code>모듈을 사용하면 Cpython에서 포인터를 사용할 수 있다.<br>
<a href="https://dbader.org/blog/python-ctypes-tutorial" target="_blank" rel="noopener">ctypes</a>에 대해서 사용법이 궁금하다면 이 포스트가 도움이 될 것이다.</p>
<ol>
<li>
<p>c함수 파일</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_one</span><span class="params">(<span class="keyword">int</span> *x)</span> </span>&#123;</span><br><span class="line">    *x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>컴파일</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -Wall -Werror -fpic add.c</span><br><span class="line">gcc -shared -o libadd1.so add.o</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>python에서 사용</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">add_lib = ctypes.CDLL(<span class="string">"..libadd1.so"</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>add_lib.add_one</span></span><br><span class="line"><span class="string">&lt;_FuncPtr object at 0x7f9f3b8852a0&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">add_one = add_lib.add_one</span><br><span class="line">add_one.argtypes = [ctypes.POINTER(ctypes.c_int)]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>add_one(1)</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">ctypes.ArgumentError: argument 1: &lt;class 'TypeError'&gt;: \</span></span><br><span class="line"><span class="string">expected LP_c_int instance instead of int</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">x = ctypes.c_int()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>x</span></span><br><span class="line"><span class="string">c_int(0)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>add_one(ctypes.byref(x))</span></span><br><span class="line"><span class="string">998793640</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>x</span></span><br><span class="line"><span class="string">c_int(1)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/08/30/python/post/pointer_in_python/" data-id="ckkdb52hv002u1pqks99nb6fb" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c/io_functions_advanced" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/27/c/io_functions_advanced/" class="article-date">
  <time datetime="2019-08-27T08:23:28.000Z" itemprop="datePublished">2019-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/27/c/io_functions_advanced/">소켓과 스트림을 이해하기 위한 고급 IO함수</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> index</h2>
<ol>
<li><a href="#%EB%B2%84%ED%8D%BC%EB%A7%81_%EC%A0%9C%EC%96%B4%ED%95%98%EA%B8%B0"><strong>버퍼링 제어하기(linux_gcc buffer)</strong></a></li>
<li><a href="#%EC%8A%A4%EB%A0%88%EB%93%9C_%EC%84%B8%EC%9D%B4%ED%94%84thread_safe"><strong>스레드 세이프(thread safe)</strong></a></li>
<li><a href="#%EB%B2%A1%ED%84%B0_%EC%9E%85%EC%B6%9C%EB%A0%A5vector_io"><strong>벡터 입출력(Vector IO)</strong></a></li>
</ol>
<hr>
<h2 id="버퍼링_제어하기"><a class="markdownIt-Anchor" href="#버퍼링_제어하기"></a> 버퍼링_제어하기</h2>
<p>표준 입출력은 세가지 유형으로 사용자 버퍼링을 구현하고,<br>
버퍼의 유형과 크기를 다룰 수 있는 인터페이스를 제공한다.<br>
각각의 버퍼링 타입은 저마다의 목적이 있으니 상황에 맞게 사용해야 한다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">type</th>
<th style="text-align:center">desc</th>
<th style="text-align:center">ie</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">버퍼 미사용</td>
<td style="text-align:center">사용자 버퍼를 사용하지않고 바로 커널로 데이터를 보낸다. 딱히 이점이 없다.</td>
<td style="text-align:center"><strong>표준에러<code>stderr</code></strong> 외에 거의 사용하지 않음</td>
</tr>
<tr>
<td style="text-align:center">행 버퍼</td>
<td style="text-align:center">행 단위 버퍼링 수행. 개행문자가 나타나면 버퍼 내용을 커널로 보낸다. 화면출력을 위한 스트림일 경우 유용, 화면출력 메세지는 개행문자로 구분되기 때문이다.</td>
<td style="text-align:center"><strong>표준 출력<code>stdin</code></strong> 처럼 터미널에 연결된 스트림에서 기본적으로 사용하는 버퍼링 방식</td>
</tr>
<tr>
<td style="text-align:center">블록 버퍼</td>
<td style="text-align:center">고정된 바이트수로 표현되는 블록단위로 버퍼링을 수행. 파일에 적합하여 기본적으로 파일과 관련된 모든 스트림은 블록버퍼를 사용한다.</td>
<td style="text-align:center"><strong>파일 스트림(FILE)</strong>. 표준입출력 에서는 블록버퍼링을 <code>full</code>버퍼링이라고 한다.</td>
</tr>
</tbody>
</table>
<p>대부분 기본유형의 버퍼링을 사용하는 편이 올바르고 최선이나, 표준입출력은 버퍼링 방식을 제어할 수 있는 인터페이스를 제공한다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>stream</code>의 <strong>버퍼링 유형</strong>을 <code>mode</code>로 설정한다.
<ul>
<li>mode
<ol>
<li><code>IONF</code>: 버퍼 미사용</li>
<li><code>IOLBF</code>: 행 버퍼</li>
<li><code>IOFBF</code>: 블록 버퍼</li>
</ol>
</li>
</ul>
</li>
<li><code>buf</code>와 <code>size</code>를 무시하는 <code>IONF</code>를 제외하고,</li>
<li>나머지는 <code>size</code>바이트 크기의 버퍼를 가리키는 <code>buf</code>를 주어진 <code>stream</code>을 위한 버퍼로 사용한다.</li>
<li>만약 <code>buf</code>가 <code>NULL</code>이면, <strong>glibc</strong>가 자동적으로 지정된 크기만큼 메모리를 할당한다. (파일 저장을 생각하면 아마 1024이상 4kb, 8kb 정도가 아닐까?)</li>
<li><code>setvbuf</code>함수는 스트림을 연다음, 다른 연산(읽기 쓰기 등.)수행하기 전에 호출해야 한다.</li>
<li>성공시 0을 반환, 실패시 그 외의 값을 반환.</li>
</ol>
<p>제공된 버퍼는 스트림이 닫힐 때까지 반드시 존재해야한다.<br>
흔히 스트림을 받기 전에 끝나는 스코프 내부의 자동변수로 버퍼를 선언하는 실수를 한다.<br>
특히 <code>main()</code>에서 지역변수로 버퍼를 만든 후, 스트림을 명시적을 닫지 않는 경우.</p>
<p>아래 코드에는 버그가 있다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="comment">// stdout을 bufsize크게에 맞춰 블록 버퍼로 설정한다.</span></span><br><span class="line"></span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, buf, _IOFBF, BUFSIZ);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARRR!\n"</span>); <span class="comment">// stdout에 버퍼에 들어가고 개행문자를 확인함과 stdout buf에서 fflush되서 화면에 출력된다.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// buf는 스코프를 벗어나고 해제된다. 하지만 stdout을 닫지 않았다!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>일반적으로 개발자들은 스트림을 다룰 때 버퍼링에 대해 고민할 필요가 없다.<br>
표준 에러를 제외하고, 터미널은 행 버퍼링으로 동작하는게 맞고 파일은 블록버퍼링을 사용하는게 맞다. 그게 전부다.</p>
<p>블록 버퍼링에서 버퍼의 기본크기는 <code>BUFSIZ</code>이며 <code>&lt;stdio.h&gt;</code>에 정의되어 있다.<br>
이 값은 일반적인 블록크기의 정수배인 최적의 값이다.<br>
<strong>(64비트 운영체제인 내 컴퓨터에서는 <code>8192bytes</code>)</strong></p>
<hr>
<h2 id="스레드_세이프thread_safe"><a class="markdownIt-Anchor" href="#스레드_세이프thread_safe"></a> 스레드_세이프:Thread_safe</h2>
<p>pass</p>
<hr>
<h2 id="벡터_입출력vector_io"><a class="markdownIt-Anchor" href="#벡터_입출력vector_io"></a> 벡터_입출력Vector_io</h2>
<blockquote>
<p>버퍼세그먼트의 집합을 벡터라 한다.</p>
</blockquote>
<p>한번의 시스템콜을 사용해서, 여러개의 버퍼벡터(세그먼트)에 쓰거나, 읽어들일 때 사용.<br>
백터입출력은 선형입출력 메서드에 비해 다음과 같은 장점을 가지고 있다.</p>
<ol>
<li>자연스러운 코딩 패턴
<ul>
<li>미리 정의된 구조체가 여러 필드에 걸쳐 데이터가 분리되어 있는 경우,<br>
벡터입출력을 사용하면 직관적인 방법으로 조작할 수 있다.</li>
</ul>
</li>
<li>효율
<ul>
<li>하나의 벡터 입출력 연산은 여러번의 선형 입출력 연산을 대체할 수 있다.</li>
</ul>
</li>
<li>성능
<ul>
<li>시스템콜의 횟수를 줄일 뿐 아니라, 내부적으로 선현 입출력 구현에 비해 좀 더 최적화된 구현을 제공.</li>
</ul>
</li>
</ol>
<h3 id="readv_writev"><a class="markdownIt-Anchor" href="#readv_writev"></a> readv_writev</h3>
<p><code>read()</code>, <code>write()</code>와 동일하게 동작하지만, 여러 개의 버퍼를 사용한다는 점에서 구분된다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *iov_base; <span class="comment">// 버퍼의 시작 포인터</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len; <span class="comment">// 버퍼의 바이트 수</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>readv()</code></li>
</ul>
<p>파일디스크립터 <code>fd</code>에서 데이터를 읽어 count개수만큼 <code>iov</code>버퍼에 저장.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> count);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>writev()</code></li>
</ul>
<p>count개수만큼의 <code>iov</code>버퍼에 있는 데이터를 파일디스크립터<code>fd</code>에 저장.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> count);</span><br></pre></td></tr></table></figure>
<p>둘 다 성공시 읽거나 쓴 바이트 개수를 반환한다.<br>
즉, <code>count * iov_len</code>과 같아야 하며, 에러가 발생하면 -1을 반환하고 errno를 설정한다.</p>
<p>표준에러에서 추가로 2가지 에러의 상황이 있다.</p>
<ol>
<li>반환값의 자료형이 <code>ssize_t</code>이기 때문에 <code>SSZIE_MAX</code>보다 큰 값을 전달했다고 리턴하면 데이터는 전송되지 않고,<br>
-1을 반환하며 errno는 EINVAL로 설정한다.<br>
(<code>2**32-1</code>을 바이트 취급하면 <code>4gb</code>)</li>
<li>POSIX는 count가 반드시 0보다 크고 <code>IOV_MAX</code>와 같거나 작아야한다.<br>
리눅스에서  IOV_MAX값은 1024로 정의.<br>
만약 count가 0이면 0을 반환하고(0회 실행했으니 데이터전송량 0바이트),<br>
IOV_MAX보다 크다면, 데이터는 전송되지 않고 -1을 반환하며 errno는 EINVAL로 설정한다.</li>
</ol>
<p>버프의 기본사이즈 인 블록사이즈(메모리 접근 최소 단위)가 내 운영체제에서는 8kb 이기 때문에,<br>
<code>1024bytes</code>(를 부분 버퍼로)*<code>8</code>(개)이면 데이터가 딱 맞게 <strong>한번의 시스템 콜로</strong> <code>1kb 8개 버퍼</code>를 처리하는 것이다.</p>
<h3 id="writev_예시"><a class="markdownIt-Anchor" href="#writev_예시"></a> writev_예시</h3>
<ul>
<li>Code</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">char</span> *buf[] = &#123;</span><br><span class="line">        <span class="string">"The term buccaneer comes from the word boucan.\n"</span>,</span><br><span class="line">        <span class="string">"A boucan is a wooden frame used for cooking meat.\n"</span>,</span><br><span class="line">        <span class="string">"Buccaneer is the West Indies name for a pirate.\n"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">"buccaneer.txt"</span>, O_WRONLY | O_CREAT | O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        iov[i].iov_base = buf[i];</span><br><span class="line">        iov[i].iov_len = <span class="built_in">strlen</span>(buf[i]) + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"len: %li\n"</span>, <span class="built_in">strlen</span>(buf[i]));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    nr = writev(fd, iov, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (nr == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"writev"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wrote %ld bytes\n"</span>, nr);</span><br><span class="line">    res = close(fd);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"close"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>output</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">len: 47</span><br><span class="line">len: 50</span><br><span class="line">len: 48</span><br><span class="line">wrote 148 bytes</span><br></pre></td></tr></table></figure>
<ul>
<li>strace</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">"./writev.out"</span>, [<span class="string">"./writev.out"</span>], 0x7ffecf1aa940 /* 27 vars */) = 0</span><br><span class="line">brk(NULL)                               = 0x55bf90861000</span><br><span class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">access(<span class="string">"/etc/ld.so.preload"</span>, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=90249, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 90249, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fe81dace000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line"><span class="built_in">read</span>(3, <span class="string">"\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\260\34\2\0\0\0\0\0"</span>..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2030544, ...&#125;) = 0 <span class="comment"># fd에 대한 정보 갱신</span></span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe81dacc000 <span class="comment"># 가상 메모리의 데이터 매핑 (메모리를 map하다.)</span></span><br><span class="line">mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fe81d4cd000</span><br><span class="line">mprotect(0x7fe81d6b4000, 2097152, PROT_NONE) = 0</span><br><span class="line">mmap(0x7fe81d8b4000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7fe81d8b4000</span><br><span class="line">mmap(0x7fe81d8ba000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fe81d8ba000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x7fe81dacd4c0) = 0 <span class="comment"># 아키텍쳐의 특수 프로세스나 쓰레드 상태를 설정함(성립시킴) 프로세스에 할당되는 쓰레드에 실행중인 코드블록의 주소를 전달하는?</span></span><br><span class="line">mprotect(0x7fe81d8b4000, 16384, PROT_READ) = 0</span><br><span class="line">mprotect(0x55bf90670000, 4096, PROT_READ) = 0</span><br><span class="line">mprotect(0x7fe81dae5000, 4096, PROT_READ) = 0 <span class="comment"># 메모리 주소에 대한 권한 변경</span></span><br><span class="line">munmap(0x7fe81dace000, 90249)           = 0 <span class="comment"># 메모리 해제</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">"buccaneer.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, 0100750) = 3</span><br><span class="line">fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...&#125;) = 0</span><br><span class="line">brk(NULL)                               = 0x55bf90861000 <span class="comment"># 실행하는 프로세스에 대해 메모리 세그먼트 변경, 추가 등.</span></span><br><span class="line">brk(0x55bf90882000)                     = 0x55bf90882000</span><br><span class="line">write(1, <span class="string">"len: 47\n"</span>, 8)                = 8</span><br><span class="line">write(1, <span class="string">"len: 50\n"</span>, 8)                = 8</span><br><span class="line">write(1, <span class="string">"len: 48\n"</span>, 8)                = 8</span><br><span class="line">writev(3, [&#123;iov_base=<span class="string">"The term buccaneer comes from th"</span>..., iov_len=48&#125;, &#123;iov_base=<span class="string">"A boucan is a wooden frame used "</span>..., iov_len=51&#125;, &#123;iov_base=<span class="string">"Buccaneer is the West Indies nam"</span>..., iov_len=49&#125;], 3) = 148</span><br><span class="line">write(1, <span class="string">"wrote 148 bytes\n"</span>, 16)       = 16</span><br><span class="line">close(3)                                = 0</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="readv_예시"><a class="markdownIt-Anchor" href="#readv_예시"></a> readv_예시</h3>
<ul>
<li>code</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> foo[<span class="number">48</span>], bar[<span class="number">51</span>], baz[<span class="number">49</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nr;</span><br><span class="line">    <span class="keyword">int</span> fd, i;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">"buccaneer.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = foo;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(foo);</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">1</span>].iov_base = bar;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(bar);</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">2</span>].iov_base = baz;</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = <span class="keyword">sizeof</span>(baz);</span><br><span class="line"></span><br><span class="line">    nr = readv(fd, iov, <span class="number">3</span>); <span class="comment">// 블럭 단위 버퍼로 저장한다. BUF_SIZ(8kb)</span></span><br><span class="line">    <span class="comment">// 파일을 읽는 물리 블록 단위는 4096bytes? 그 단위로 읽으면 재정렬이 필요없어.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nr == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"readv"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %s"</span>, i, (<span class="keyword">char</span> *)iov[i].iov_base);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (close(fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"close"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>output</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: The term buccaneer comes from the word boucan.</span><br><span class="line">1: A boucan is a wooden frame used <span class="keyword">for</span> cooking meat.</span><br><span class="line">2: Buccaneer is the West Indies name <span class="keyword">for</span> a pirate.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>사실 리눅스 커널 내부에 모든 입출력은 벡터 입출력이다.<br>
<code>read()</code>와 <code>write()</code>구현 역시 하나짜리 세그먼트를 가지는 벡터 입출력으로 되어있다.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/08/27/c/io_functions_advanced/" data-id="ckkdb52f900041pqkefwekbxn" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux/select_poll" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/22/linux/select_poll/" class="article-date">
  <time datetime="2019-08-22T06:27:08.000Z" itemprop="datePublished">2019-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/22/linux/select_poll/">multiple io, select() and poll()</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> index</h2>
<ol>
<li><a href="#%EB%8B%A4%EC%A4%91_%EC%9E%85%EC%B6%9C%EB%A0%A5"><strong>다중 입출력</strong></a></li>
<li><a href="#select"><strong>select</strong></a></li>
<li><a href="#poll"><strong>poll</strong></a></li>
<li><a href="#poll%EA%B3%BC_select%EB%B9%84%EA%B5%90"><strong>poll vs select</strong></a></li>
<li><a href="#epoll"><strong>epoll</strong></a></li>
</ol>
<hr>
<h2 id="다중_입출력"><a class="markdownIt-Anchor" href="#다중_입출력"></a> 다중_입출력</h2>
<p>종종 키보드입력(stdin)과 IPC, 그리고 여러 파일 사이에서 일어나는 입출력을 처리하면서, 하나 이상의 파일디스크립터를 블록할 필요가 있다.</p>
<p>다중 입출력은 어플리케이션이 여러개의 파일 디스크립터를 동시에 블록하고,<br>
그 중 하나라도 블록되지 않고, 읽고 쓸 준비가 되면, 알려주는 기능을 제공한다.<br>
따라서 다음과 같은 설계방식을 따르는 어플리케이션을 위한 중심점이 된다.</p>
<ol>
<li>다중 입출력: 파일디스크립터중 하나가 입출력이 가능할때, 알려준다.</li>
<li>준비가 됐나? 준비된 파일 디스크립터가 없다면, 하나 이상의 파일 디스크립터가 준비될 때까지 잠든다.</li>
<li>꺠어나기. 어떤 파일 디스크립터가 준비됐나?</li>
<li>블록하지 않고, 모든 파일 디스크립터가 입출력을 준비하도록 관리한다.</li>
<li>1 로 돌아가서 다시 시작한다.</li>
</ol>
<p>리눅스는 <code>select, poll, epoll</code>인터페이스 라는 세가지를 제공한다.</p>
<h2 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *execptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line">FD_ZERO(fd_set *<span class="built_in">set</span>);</span><br></pre></td></tr></table></figure>
<p><code>select()</code>호출은 파일 디스크립터가 입출력을 수행할 준비가 되거나 옵션으로 정해진 시간이 경과할 때 까지만 블록된다.</p>
<p>감시 대상 파일 디스크립터는 세가지 집합으로 나뉘어 각각 다른 이벤트를 기다린다.</p>
<ul>
<li><code>readfds</code>: 블록되지 않고 데이터 읽기가 가능한지 (데이터가 없으면 block, read()작업이 가능한지) 감시한다.</li>
<li><code>wrtiefds</code>: 블록되지 않고 <code>write()</code>가 가능한지 감시한다.</li>
<li><code>exceptfds</code>: 예외가 발생했거나, 대역을 넘어서는 데이터(소켓에만 적용)가 존재하는지 감시.</li>
</ul>
<p>호출이 성공하면, 각 집합은 요청받은 입출력 유형을 대상으로 입출력이 준비된 파일 디스크립터만 포함되도록 변경된다.<br>
예를 들어 7, 9두개의 파일디스크립터가 <code>readfds</code>에 들어있다고 한다면 호출이 반환될 때, 7이 집합에 남아있을 경우,<br>
7번은 블록없이 읽기가 가능하다.</p>
<p>첫번째 인자인 n은 파일 디스크립터 집합에서 가장 큰 파일 디스크립터 숫자에 1을 더한 값이다.<br>
따라서 select()를 호출하려면 파일 디스크립터에서 가장 큰 값이 무엇인지 알아내서 이 값에 1을 더해 첫 인자에 넘겨야 한다.<br>
<code>timeout</code> 인자는 <code>timeval구조체</code>를 가르키는 포인터이며 이 구조체는 다음과 같이 정의되어 있다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec; <span class="comment">// 초</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec; <span class="comment">// 마이크로 초</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 인자가 NULL이 아니면 select()호출은 입력이 준비된 파일 디스크립터가 없을 경우에도 tv_sec초와 tv_usec 마이크로 초 이후에 반환된다.</p>
<p>고전적인 유닉스 시스템에서는 select()호출이 반환된 다음에 이 구조체가 정의되지 않은 상태로 남아 있으므로, 매번 호출전에<br>
파일 디스트립터 집합과 더불어 다시 초기화를 해줘야 한다. 실제로 최근 리눅스 버전은 이 인자를 자동으로 수정해서 남아있는 시각으로 값을 설정한다.</p>
<p>따라서 Timeout이 5초고 파일 디스트립터가 준비되기 까지 3초가 경과했다면, <code>tv.tv_sec</code>은 반환될때 2를 담고 있을 것이다.<br>
timeout에 설정된 두 값이 모두 0이면, 호출은 즉시 반환되며 호출하는 시점에서 대기중인 이벤트를 알려주지만, 그 다음 이벤트를 기다리지 않는다.</p>
<p><code>select</code>에서 사용하는 fds(집합)은 직접 조작하지 않고 매크로를 사용해서 관리한다.</p>
<p>대다수의 시스템에서는 fds를 비트 배열처럼 간단한 방식으로 구현하고 있다.</p>
<h3 id="매크로"><a class="markdownIt-Anchor" href="#매크로"></a> 매크로</h3>
<ul>
<li>FD_ZERO: <code>FD_ZERO(&amp;writefds);</code><br>
FD_ZERO는 지정한 집합내 모든 파일 디스크립터를 제거한다. 이 매크로는 항상 select()를 호출하기 전에 사용해야 한다.</li>
<li>FD_SET: <code>FD_SET(fd, &amp;writefds);</code><br>
주어진 집합에 파일 디스크립터를 추가한다.</li>
<li>FD_CLR: <code>FD_CLR(fd, &amp;writefds);</code><br>
주어진 집합에서 파일디스크립터 하나를 제거한다.</li>
<li>FD_ISSET: <code>FD_ISSET(fd, &amp;readfds);</code><br>
주어진 집합에 파일디스크립터가 존재하는지 확인한다. 존재하면 0이 아닌 정수를 반환한다.<br>
<code>select()</code>호출이 반환된 다음에 파일디스크립터가 입출력이 가능한 상태인지 확인하기 위해 사용된다.</li>
</ul>
<h3 id="예제"><a class="markdownIt-Anchor" href="#예제"></a> 예제</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMEOUT 5</span></span><br><span class="line"><span class="comment">// 타입 아웃 초</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN 1024</span></span><br><span class="line"><span class="comment">// 읽기 버퍼 크기</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 표준 입력에서 입력을 기다리기 위한 준비</span></span><br><span class="line">    FD_ZERO(&amp;readfds); <span class="comment">// select 호출 전 반드시 사용 해줘야.</span></span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;readfds); <span class="comment">// IN은 데이터가 들어오면 읽을 수 있는 FD</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// select가 5초 동안 기다리도록 timeval구조체 설정</span></span><br><span class="line">    tv.tv_sec = TIMEOUT;</span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 입력 대기 시작</span></span><br><span class="line">    ret = select(STDIN_FILENO + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">    <span class="comment">//  Readable한 STDIN_FILENO에 대해서 대기, 감시하는 select 선언</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"select"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d seconds elapesd.\n"</span>, TIMEOUT);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 이 아래부터는 select가 0이 아닌 양수를 반환했다는 의미</span></span><br><span class="line">    <span class="comment">// 대기중인 집합 중 하나라도 돌아왔다</span></span><br><span class="line">    <span class="comment">// 그것을 FD_ISSET으로 선별해서, 그것을 READ혹은 WRITE한다.</span></span><br><span class="line">    <span class="comment">// 바로 실행할 수 있으니 빠르게 블록되고 해제된다.</span></span><br><span class="line">    <span class="comment">// 그 전까지는 FD를 감시하며 LOOPING하는 쓰레드가 동작</span></span><br><span class="line">    <span class="comment">// 파일 디스크립터에서 즉시 읽기가 가능하다.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;readfds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUF_LEN + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read not block</span></span><br><span class="line">        len = read(STDIN_FILENO, buf, BUF_LEN);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"READ"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read %s\n"</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This should not happen!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poll"><a class="markdownIt-Anchor" href="#poll"></a> POLL</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">// 파일 디스크립터</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">// 대기 이벤트</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">// 발생이벤트</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>비트마스크 기반의 세가지 파일디스크립터 집합을 사용하는 <code>Select</code>와 달리,<br>
<code>poll</code>은 fds가 가리키는 단일 pollfd구조체 배열을 nfds개수 만큼 사용한다.</p>
<p>각 구조체의 <code>events</code>필드는, 그 파일 디스크립터에서 감시할 이벤트의 비트마스크 이다.</p>
<p>설정 가능한 이벤트는 아래와 같다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:left">desc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">POLLIN</td>
<td style="text-align:left">읽을 데이터가 존재</td>
</tr>
<tr>
<td style="text-align:center">POLLRDNORM</td>
<td style="text-align:left">일반 데이터를 읽을 수 있다.</td>
</tr>
<tr>
<td style="text-align:center">POLLRDBAND</td>
<td style="text-align:left">우선권이 있는 데이터를 읽을 수 있다.</td>
</tr>
<tr>
<td style="text-align:center">POLLPRI</td>
<td style="text-align:left">시급히 읽을 데이터가 존재한다.</td>
</tr>
<tr>
<td style="text-align:center">POLLOUT</td>
<td style="text-align:left">쓰기가 블록되지 않을 것이다.</td>
</tr>
<tr>
<td style="text-align:center">POLLWRNORM</td>
<td style="text-align:left">일반 데이터 쓰기가 블록되지 않을 것이다.</td>
</tr>
<tr>
<td style="text-align:center">POLLWRBAND</td>
<td style="text-align:left">우선권이 있는 데이터쓰기가 블록되지 않을 것이다.</td>
</tr>
<tr>
<td style="text-align:center">POLLMSG</td>
<td style="text-align:left">SIGPOLL메세지가 사용가능하다.</td>
</tr>
</tbody>
</table>
<p>그리고 <code>revents</code>필드에는 아래 이벤트가 추가로 설정될 수 있다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:left">desc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">POLLER</td>
<td style="text-align:left">주어진 파일 디스크립터에 에러가 있다.</td>
</tr>
<tr>
<td style="text-align:center">POLLHUP</td>
<td style="text-align:left">주어진 파일 디스크립터에서 이벤트가 지체되고 있다.</td>
</tr>
<tr>
<td style="text-align:center">POLLNVAL</td>
<td style="text-align:left">주어진 파일 디스크립터가 유효하지 않다.</td>
</tr>
</tbody>
</table>
<p>예를 들어 FD에서 읽가와 쓰기를 감시하려면, events를 <code>POLLIN | POLLOUT</code>으로 설정한다.<br>
호출이 반환되면, <code>pollfd</code>구조체 배열에서 원하는 파일 디스크립터가 들어있는 항목을 찾아<br>
<code>revents</code>에 해당 플래그가 켜져있는지 확인한다.</p>
<h3 id="반환과-에러코드"><a class="markdownIt-Anchor" href="#반환과-에러코드"></a> 반환과 에러코드</h3>
<p><code>poll()</code>호출이 성공하면, <code>revents</code>필드가 0이 아닌 구조체의 개수를 반환한다.<br>
이벤트가 발생하기 전에 타입아웃이 발생한다면 0을 반환한다.<br>
에러가 발생하면 -1을 반환하며, errno를 아래중 하나로 설정한다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:left">desc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">EBADF</td>
<td style="text-align:left">주어진 구조체의 파일디스크립터가 유효하지 않다.</td>
</tr>
<tr>
<td style="text-align:center">EFAULT</td>
<td style="text-align:left">fds를 가리키는 포인터가 프로세스 주소공간을 벗어난다.</td>
</tr>
<tr>
<td style="text-align:center">EINTR</td>
<td style="text-align:left">이벤트를 기다리는중 시그널이 발생했다. 다시 호출이 필요하다.</td>
</tr>
<tr>
<td style="text-align:center">EINVAL</td>
<td style="text-align:left">nfds인자가 RLIMIT_NOFILE값을 초과했다.</td>
</tr>
<tr>
<td style="text-align:center">ENOMEM</td>
<td style="text-align:left">요청을 완료하기위한 메모리가 부족하다.</td>
</tr>
</tbody>
</table>
<h3 id="예시"><a class="markdownIt-Anchor" href="#예시"></a> 예시</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMEOUT 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 표준 입력에 대한 이벤트 감지를 위한 세팅</span></span><br><span class="line">    fds[<span class="number">0</span>].fd = STDIN_FILENO;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 표준 출력에 쓰기가 가능한지 감지하기 위한 준비</span></span><br><span class="line">    fds[<span class="number">1</span>].fd = STDOUT_FILENO;</span><br><span class="line">    fds[<span class="number">1</span>].events = POLLOUT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 블록 시작</span></span><br><span class="line">    ret = poll(fds, <span class="number">2</span>, TIMEOUT * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"poll"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d seconds elapsed.\n"</span>, TIMEOUT);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stdin is readable\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stdout is writable\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poll과_select비교"><a class="markdownIt-Anchor" href="#poll과_select비교"></a> POLL과_SELECT비교</h2>
<ul>
<li><code>poll()</code>은 가장 높은 파일디스크립터 값에 1을 더해서 인자로 전달할 필요가 없다.</li>
<li><code>poll()</code>은 파일 디스크립터 숫자가 큰 경우에 좀 더 효율적을 동작한다.<br>
<code>select()</code>로 값이 900인 단일파일 디스크립터를 감시한다고 할 때,<br>
커널은 매번 전달된 파일디스크립터 집합에서 900번째 비트까지 일일이 검사해야한다.</li>
<li><code>select()</code>의 파일 디스크립터 집합은 크기가 정해져 있으므로, trade-off 발생.<br>
집합은 크기가 작으면, <code>select()</code>가 감시할 최대 디스크립터 개수를 제약하며, 집합의 크기가 크면 비효율적이다.<br>
큰 비트마스크에 대한 연산은 비효율적이며, 파일 디스크립터가 연속적이지 않을경우 특히 심각하다.<br>
<code>poll()</code>을 사용하면, 딱 맞는 키기의 배열 하나만 사용하면 된다.</li>
<li><code>select()</code>를 사용하면, 디스크립터 집합을 반환하는 시점에 재구성되므로<br>
잇다라 호출하게 되면, 파일디스크립터 집합 재초기화 필요함.<br>
<code>poll()</code>시스템 콜은 입력과 출력을 분리하므로, 변경없이 배열을 재사용 가능하다.</li>
<li><code>select()</code>의 timeout반환하게 되면 미정의 상태가 된다.<br>
따라서 코드의 이식성을 높이려면, timeout인자를 재초기화 해야한다.<br>
<code>pselect()</code>를 사용할 경우에는 이런 문제가 없다.</li>
</ul>
<p>select()시스템 콜에도 몇가지 장점이 있다.</p>
<ul>
<li><code>select()</code>는 상대적으로 이식성이 높아 거의 모든 유닉스에서 지원한다.</li>
<li><code>select()</code>는 타입아웃 값으로 마이크로초까지 지정할 수 있다. <code>poll()</code>은 milie-sec단위로 지정할 수 있다.</li>
</ul>
<blockquote>
<p><code>epoll()</code>은 <code>poll</code> <code>select</code>보다 훨씬 뛰어난 리눅스 입출력 멀티플렉싱 인터페이스이다. 추후에 정리한다.</p>
</blockquote>
<hr>
<h2 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h2>
<p><code>poll</code>과 <code>select</code>는 실행할 때 마다, 전체 파일 디스크립터를 요구한다.  그러면 커널은 검사해야할 파일 리스트를 다 살펴본다.p</p>
<h3 id="epoll_사용법"><a class="markdownIt-Anchor" href="#epoll_사용법"></a> epoll_사용법</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> epfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(epfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">"epoll_create1);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>epoll_create1()</code>에서 반환하는 fd는 폴링이 끝난뒤 반드시 <code>close()</code>해줘야 한다.  에러 발생시,</p>
<ul>
<li>EINVAL: 잘못된 flags인자</li>
<li>EMFILE: 사용자가 열 수 있는 최대 파일 초과</li>
<li>ENFILE: 시스템에서 열 수 있는 최대파일을 초과</li>
<li>ENOMEM: 작업을 수행하기 위한 메모리 부족</li>
</ul>
<p>-1 을 반환하고 errno를 위 중 하나로 설정한다.</p>
<hr>
<h3 id="epoll_create에서-epoll_create1으로"><a class="markdownIt-Anchor" href="#epoll_create에서-epoll_create1으로"></a> epoll_create에서 epoll_create1으로</h3>
<p><code>epoll_create()</code>는 구식 메서드며, epoll_create1()으로 대체됐다.<br>
epoll_create()는 아무런 인자를 받지 않으며 그대신 size인자를 받는데, 이는 사용되지 않음.</p>
<p>size는 감시할 파일 디스크립터 개수에 대한 힌트로 사용되는데,  <strong>최신 커널에서는 동적으로 요청된 자료구조로 크기를 정하며, 이 인자는 단지 0보다 크기만 하면 된다.</strong></p>
<p>만약에 size값이 0이거나 0보다 작다면 <code>EINVAL</code>을 반환한다.</p>
<hr>
<h3 id="epoll_제어"><a class="markdownIt-Anchor" href="#epoll_제어"></a> epoll_제어</h3>
<p><code>epoll_ctl()</code>시스템 콜은 주어진 epoll컨텍스트에 파일 디스크립터를 추가하거나 삭제할 때 사용한다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys/epoll.h에 정의된 epoll_event 구조체.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">    __u32 events; <span class="comment">// events</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *ptr;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        __u32 u32;</span><br><span class="line">        __u64 u64;</span><br><span class="line">    &#125;</span><br><span class="line">    data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>epoll_ctl()</code>호출이 성공하면 해당 epoll인스턴스는 <code>epfd</code>파일 디스크립터와 연결된다.<br>
op인자는 fd가 가리키는 파일에 대한 작업을 명시한다.</p>
<ul>
<li>op의 값
<ul>
<li>EPOLL_CTL_ADD: edfd와 연관된 epoll인스턴스에 fd와 연관된 파일을 감시하도록 추가하며, 각 이벤트는 event인자로 정의한다.</li>
<li>EPOLL_CTL_DEL: edfd와 연관된 epoll인스턴스에 fd를 감시하지 않도록 삭제한다.</li>
<li>EPOLL_CTL_MOD: 기존에 감시하고 있는 fd에 대한 이벤트를 event에 명시된 내용으로 갱신한다</li>
</ul>
</li>
</ul>
<p>event인자는 그 작업동작에 대한 설명을 담고 있다.</p>
<ul>
<li>epoll_event.events의 값(OR연산으로 여러 이벤트를 묶을 수 있음)
<ul>
<li>EPOLLERR: 해당 파일에서 발생하는 에러 상황. 이 이벤트는 따로 지정하지 않아도 항상 감시한다.</li>
<li>EPOLLET: 파일을 감시할 때, <code>edge-trigger</code>를 사용한다. 기본 동작은 레벨트리거 방식.</li>
<li>EPOLLHUP: 파일에서 발생하는 행업을 감시한다. 이 이벤트도 따로 지정하지 않아도 항상 감시한다.</li>
<li>EPOLLIN: 파일 읽기가 지연되지 않고 바로 가능한지 감시.</li>
<li>EPOLLONESHOT: 이벤트 발생 후 파일을 한번 읽고 나면 더 이상 감시하지 않는다. 이를 다시 활성화 하려면, <code>EPOLL_CTL_MOD</code>를 통해서 새로운 이벤트 값을 설정해야 한다.</li>
<li>EPOLLOUT: 파일 쓰기가 지연되지 않고 바로 가능한지 감시.</li>
<li>EPOLLPRI: 즉 시 읽어야한 OOB(TCP에서 말하는 OUT OF BAND데이터로, 전송순으로 받는 데이터의 순서를 무시하고 보내는 메세지. 잘 사용 안됨)데이터가 있는지 감시.</li>
</ul>
</li>
</ul>
<p>epoll_event구조체의 data필드는 사용자 데이터를 위한 필드다.<br>
이 필드에 담긴 내용은 이벤트 발생 후 사용자에게 반환될 때 함께 반환된다.<br>
주로 <code>event.data.fd</code>를 fd로 채워서 이벤트가 발생 했을 때,<br>
어떤 파일 디스크립터를 들여다 봐야 하는지 확인하는 용도로 사용한다.</p>
<p><code>epoll_ctl()</code>호출이 성공하면 0을 반환, 실패시 -1반환.<br>
errno를 다음 중 한 가지로 설정.</p>
<ul>
<li>EBADF: epdf가 유효한 epoll인스턴스가 아니거나, fd가 유효한 파일 디스크립터가 아니다.</li>
<li>EEXIST: op가 EPOLL_CTL_ADD인데, fd가 이미 epfd와 연결되어 있다.</li>
<li>EINVAL: epfd가 epoll인스턴스가 아니거나, epfd가 fd와 같다. 또는 잘못된 op값이 사용.</li>
<li>ENOENT: op가 EPOLL_CTL_MOD, 혹은 EPOLL_CTL_DEL인데, fd가 epfd와 연결되지 않았다.</li>
<li>ENOMEM: 해당 요청을 처리하기에는 메모리가 부족하다.</li>
<li>EPERM: fd가 epoll을 지원하지 않는다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *stream;</span><br><span class="line"><span class="keyword">int</span> fd, epfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">stream = fopen(<span class="string">"sample"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span> (!stream)&#123;</span><br><span class="line">    perror(<span class="string">"fopen"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd = fileno(stream);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">    perror(<span class="string">"fileno"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (epfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">"epoll_create1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이벤트 epfd에 추가</span></span><br><span class="line">ret = epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"><span class="comment">// 기존 이벤트 변경</span></span><br><span class="line">ret = epoll_ctl(epfd, EPOLL_CTL_MOD, fd, &amp;event);</span><br><span class="line"><span class="comment">// 기존 이벤트 삭제</span></span><br><span class="line">ret = epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret)&#123;</span><br><span class="line">    perror(<span class="string">"epoll_ctl"</span>);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(epfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="epoll로_이벤트_대기하기"><a class="markdownIt-Anchor" href="#epoll로_이벤트_대기하기"></a> epoll로_이벤트_대기하기</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 64</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span> <span class="comment">// event를 포인터를 담을 수 있는 공간으로</span></span><br><span class="line"><span class="keyword">int</span> nr_events, i, epfd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">events = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct epoll_event)* MAX_EVENTS);</span><br><span class="line"><span class="keyword">if</span> (!events)&#123;</span><br><span class="line">    perror(<span class="string">"malloc"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nr_events = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (nr_events &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">"epoll_wait"</span>);</span><br><span class="line">    <span class="built_in">free</span>(events);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_events; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"event=%ld on fd=%d\n"</span>, events[i].events, events[i].data.fd);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    이제 events[i].data.fd에 대한 events[i].events를</span></span><br><span class="line"><span class="comment">    블록하지 않고 처리할 수 있다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(events);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>epoll_wait()</code>를 호출</li>
<li>timeout밀리 초 동안 epoll인스턴스인 epfd에 등록한 파일의 이벤트를 기다린다.</li>
<li>성공시 events에는 해당 이벤트, 파일이 일기나 쓰기가 가능한 상태인지 나타내는<br>
<code>epoll_event</code>구조체에 대한 포인터가 기록.<br>
최대 maxevents만큼의 이벤트가 기록된다.<br>
발생한 이벤트 개수를 반환하며 에러시 -1, errno를 다음중 하나로 기록한다.</li>
<li><code>epoll_wait()</code>가 결과를 반환하면, epoll_event구조체의 evens필드에는 발생 이벤트가 기록된다.<br>
data필드에는 사용자가 <code>epoll_ctl()</code>을 호출하기 전에 설정한 값이 담겨있다.</li>
</ol>
<ul>
<li>EBADF: epfd가 유효한 fd가 아니다.</li>
<li>EFAULT: events가 가리키는 메모리에 대한 쓰기 권한이 없다.</li>
<li>EINTR: 시스템 콜이 완료되거나 타임아웃 전에 시그널이 발생해서 동작을 멈추었다.</li>
<li>EINVAL: epfd가 유효한 epoll인스턴스가 아니거나 maxevents값이 0이하이다.</li>
</ul>
<p>timeout이 0이면 즉히 반환 반환값은 0이다.<br>
timeout이 -1이면 이벤트가 발생 할 때까지 해당 호출은 반환되지 않는다.(블로킹 상태)</p>
<hr>
<h3 id="에지트리거와_레벨트리거"><a class="markdownIt-Anchor" href="#에지트리거와_레벨트리거"></a> 에지트리거와_레벨트리거</h3>
<p><code>epoll_ctl()</code>로 전달되는 event인자의 events필드를 EPOLLET로 설정하면,<br>
fd에 대한이벤트 모니터가 레벨 트리거가 아닌 엣지 트리거로 동작한다.</p>
<p>유닉스 파이프로 통신하는 입출력에 대한 사례는 아래와 같다.</p>
<ol>
<li>출력하는 측에서 파이프에 1kb만큼 데이터를 쓴다.</li>
<li>입력 받는 쪽에서는 파이프에 대해서 <code>epoll_wait()</code>를 수행하고</li>
<li>파이프에 데이터가 들어와서 읽을 수 있는 상태가 되기를 기다린다.</li>
</ol>
<ul>
<li>레벨 트리거로 이벤트를 모니터링하면, 2의 <code>epoll_wait()</code>호출은 즉시 반환하며,<br>
파이프가 읽을 준비가 되었음을 알려준다.</li>
<li>엣지 트리거로 모니터링하면 1단계가 완료될 때까지, 호출은 반환되지 않는다.</li>
</ul>
<p>기본 동작방식은 <strong>레벨트리거</strong>방식이다. **<code>poll()</code>**과 **<code>select()</code>**가 동작하는 방식이 레벨트리거 방식인데,<br>
대부분 개발자들이 생각하는 방식 이기도 하다.</p>
<p><strong>엣지 트리거</strong>방식은 일반적으로 <strong>논블로킹 입출력</strong>을 활용하는 접근방식을 <strong>요구</strong>하며, <code>EAGAIN</code>을 주의깊게 확인해야 한다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/08/22/linux/select_poll/" data-id="ckkdb52fm000f1pqkz5ms7l1v" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c/IO_functions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/19/c/IO_functions/" class="article-date">
  <time datetime="2019-08-19T09:34:26.000Z" itemprop="datePublished">2019-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/19/c/IO_functions/">소켓과 스트림을 이해하기 위한 C의 IO함수들</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> Index</h2>
<ol>
<li><a href="#%EA%B0%9C%EC%9A%94"><strong>개요</strong></a></li>
<li><a href="#%EC%9E%85%EC%B6%9C%EB%A0%A5_%ED%95%A8%EC%88%98"><strong>입출력 함수</strong></a></li>
<li><a href="#%ED%91%9C%EC%A4%80_%EC%9E%85%EC%B6%9C%EB%A0%A5%EA%B3%BC_%EB%B2%84%ED%8D%BC"><strong>표준 입출력과 버퍼</strong></a></li>
<li><a href="#FILE%EA%B3%BC_STREAM_%EA%B7%B8%EB%A6%AC%EA%B3%A0_%EC%9D%BC%EB%B0%98%ED%8C%8C%EC%9D%BC%EC%9D%98_%EC%9E%85%EC%B6%9C%EB%A0%A5"><strong>File과 Stream, 그리고 일반파일 입출력</strong></a></li>
<li><a href="#%EB%B0%94%EC%9D%B4%EB%84%88%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%9D%BD%EA%B8%B0"><strong>바이너리 데이터 읽기</strong></a></li>
<li><a href="#%EB%B2%84%ED%8D%BC%EC%9E%85%EC%B6%9C%EB%A0%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8"><strong>버퍼 입출력 예제 프로그램</strong></a></li>
<li><a href="#%EC%B6%94%EA%B0%80_%EC%9C%A0%EC%9A%A9%ED%95%9C_%EA%B8%B0%EB%8A%A5%EB%93%A4"><strong>추가 유용한 기능</strong></a></li>
</ol>
<h2 id="개요"><a class="markdownIt-Anchor" href="#개요"></a> 개요</h2>
<p>콘솔 입출력을 위한 입력 스트림과 출력 스트림은 프로그램이 실행되면 자동으로 생성되고, 프로그램이 종료되면 자동으로 소멸되는 스트림이다.</p>
<ul>
<li>표준 스트림</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">name</th>
<th style="text-align:left">desc</th>
<th style="text-align:left">target</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">stdin</td>
<td style="text-align:left">표준 입력 스트림</td>
<td style="text-align:left">키보드 대상</td>
</tr>
<tr>
<td style="text-align:left">stdout</td>
<td style="text-align:left">표준 출력 스트림</td>
<td style="text-align:left">모니터 대상</td>
</tr>
<tr>
<td style="text-align:left">stderr</td>
<td style="text-align:left">표준 에러 스트림</td>
<td style="text-align:left">모니터 대상</td>
</tr>
</tbody>
</table>
<p>stdin이 <strong>입출력 리디렉션</strong>을 통해서 stdout의 파일로 전송되고 해당 바이트 만큼 stdin을 fflush하여 stdin은 비워진 상태로 인터럽션을 일으키지 않는다.</p>
<ul>
<li><a href="https://codenamenadja.github.io/2019/08/12/linux/basic_concept/#%ED%8A%B9%EC%88%98_%ED%8C%8C%EC%9D%BC">basic concept of Linux / about file 링크</a></li>
</ul>
<p>하드웨어 장치를 추상화하는 디바이스 파일로서 커널이 파일로서 관리하는 기본적인 2분류에 대해서 설명했었다.</p>
<p>키보드 디바이스 파일은,</p>
<ol>
<li>캐릭터 디바이스 파일로서 해당 파일에 캐릭터가 들어오면 바로 인터럽션을 일으키고,</li>
<li>영어의 경우 1바이트를 읽어내고 언어 설정에 따라 해당 키보드 입력 값을 UNICODE캐릭터로 변환</li>
<li>모니터 출력 디바이스파일로 전송한다.</li>
<li>브라우저프로세스를 예를 들면, Keyup이라하는 이벤트는, 키보드 인터럽션에 대해서, output스트림을 stdout이 아닌 브라우저 프로세스 메모리에 대해 연결해 놓은 것이다.</li>
<li>프로세스에서 처리가 끝나면, 부분적인 렌더링을 개시한다. 내가 입력한 것이 모니터로 전달한 것이 아니라, 내가 입력한 값이 속성으로 전달되고, 프로세스가 그것을 모니터 출력으로 연결하는 것이다.</li>
<li>그래서 프로세스에서 value를 조정해서 객체의 속성을 브라우저에 인식시키면, 해당 프로세스의 로직이 바로 모니터 out에 전달하게 하는지 아닌지는 로직에 달려있다.</li>
<li>stdin은 전달하고 나면 바로 fflush되어 해당 디바이스 파일은 비워지게 된다.</li>
</ol>
<p>만약 fflush되어 해당 피일이 비워지지 않는다면, 뭔가 에러가 날 가능 성이 있는데,<br>
가장 확실한 에러는 다음에 값을 입력해서 키보드 디바이스파일에 캐릭터가 들어왔다는 인터럽션이 일어났을 때,<br>
읽어야할 바이트가 1바이트인데, 앞에서 부터 1바이트를 읽는다하면, 이번에 입력된 값과 추후 들어올 값들은 모두 누적되기만 하는 것이다.</p>
<hr>
<h2 id="입출력_함수"><a class="markdownIt-Anchor" href="#입출력_함수"></a> 입출력_함수</h2>
<h3 id="문자-단위-입출력-함수"><a class="markdownIt-Anchor" href="#문자-단위-입출력-함수"></a> 문자 단위 입출력 함수</h3>
<ul>
<li>문자 출력 함수</li>
</ul>
<p><strong>함수 호출 성공시 쓰여진 문자정보, 실패 시 <code>EOF</code> 반환</strong></p>
<ol>
<li>
<p>putchar</p>
<p><code>int putchar(int c);</code></p>
<p>인자로 전달된 문자 정보를 <code>stdout</code>으로 전송하는 함수</p>
</li>
<li>
<p>fputc</p>
<p><code>int fputc(int c, FILE *stream);</code></p>
<p>위와 동일하지만, <code>FILE *stream</code>의 파일객체를 지정할 수 있다. 출력 스트림이 모니터 디바이스파일이 아닌, 일반 파일로 전송하는 것이 가능하다.</p>
<p>따라서 <code>stdout</code>을 2번째 매개변수로 전달하면 <code>putchar</code>과 동일한 함수가 된다.</p>
</li>
</ol>
<ul>
<li>문자 입력 함수</li>
</ul>
<p><strong>파일 끝에 도달하거나, 함수호출 실패 시 <code>EOF</code> 반환</strong></p>
<ol>
<li>
<p>getchar</p>
<p><code>int getchar(void);</code></p>
<p>모니터 출력 대응용으로 하나의 문자를 받아서 반환한다.</p>
</li>
<li>
<p>fgetc</p>
<p><code>int fgetc(FILE *stream)</code></p>
<p><code>fgetc</code>와 달리 입력 받을 스트림을 지정할 수 있다.</p>
</li>
</ol>
<h3 id="예제_1"><a class="markdownIt-Anchor" href="#예제_1"></a> 예제_1</h3>
<ul>
<li>단순 입출력 사용</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch1, ch2;</span><br><span class="line"></span><br><span class="line">    ch1 = getchar(); <span class="comment">// 문자 키 입력</span></span><br><span class="line">    ch2 = fgetc(<span class="built_in">stdin</span>); <span class="comment">// 엔터 키 입력</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(ch1) <span class="comment">// 문자 출력</span></span><br><span class="line">    fputc(ch2, <span class="built_in">stdout</span>) <span class="comment">// 엔터 키 출력</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">console-&gt;</span></span><br><span class="line"><span class="comment">p (p 누르고 엔터)</span></span><br><span class="line"><span class="comment">p (p출력, 엔터\n 으로 ascii 10인 값으로 출력)</span></span><br><span class="line"><span class="comment">(엔터로 인한 줄바꿈)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>문자 입출력에서의 <code>EOF</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">        <span class="keyword">if</span>(ch==EOF)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">console -&gt;</span></span><br><span class="line"><span class="comment">Hi~ (사용자 입력+엔터)</span></span><br><span class="line"><span class="comment">Hi~ ()</span></span><br><span class="line"><span class="comment">I like C lang. (사용자 입력+엔터)</span></span><br><span class="line"><span class="comment">I like C lang.</span></span><br><span class="line"><span class="comment">^Z (EOF를 반환시키는 CTRL+Z , CTRL+D)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>getchar()함수는 문자 하나를 입력 받기 위한 함수 이지만, 만약 키보드 디바이스파일에 문자 하나이상 입력되었다면,<br>
그 값이 비워질 만큼, getchar()을 누적해서 실행하여 해당 변수에 더한다.<br>
getchar()자체는 하나만을 리턴하는게 맞지만 만약 입력값이 남아있다면 파일이 빌 때 까지 계속 실행하는 것이다.</p>
<ul>
<li>문자 반환형이 int 인 이유는?</li>
</ul>
<p>반환되는 것은 1바이트 크기의 문자인데, 반환형이 int인 이유는<br>
반환하는 값 중 하나인 <code>EOF</code> 는 -1로 정의된 상수이다.</p>
<p>따라서 char형 이라면, 그리고 char을 unsigned char로 처리하는 컴파일러에 의해 컴파일이 되었다면, EOF는 반환의 과정에서</p>
<p>엉뚱하게도 양의 정수로 형변환이 되어버리고 만다.<br>
그래서 어떤 상황에서도 -1을 인식 할 수 있는 int형으로 반환형을 정의해 놓은 것이다.</p>
<hr>
<h3 id="문자열-단위-입출력-함수"><a class="markdownIt-Anchor" href="#문자열-단위-입출력-함수"></a> 문자열 단위 입출력 함수</h3>
<ul>
<li>문자열 출력 함수</li>
</ul>
<p><strong>성공시 음수가 아닌 값을, 실패 시 <code>EOF</code>반환</strong></p>
<p><strong>문자 열의 끝에는 항상 <code>Null</code>이 1바이트 사이즈로 있다.</strong></p>
<ol>
<li>
<p>puts<br>
<code>int puts(const char *s);</code></p>
<p>출력 후 자동 개행</p>
</li>
<li>
<p>fputs</p>
<p><code>int fputs(conts char *s, FILE *stream);</code></p>
<p>출력 후 개행 없음</p>
</li>
</ol>
<h3 id="예제_2"><a class="markdownIt-Anchor" href="#예제_2"></a> 예제_2</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> text[] = <span class="string">"Simple String"</span> <span class="comment">// 문자열은 이미 배열 포인터</span></span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    str = text <span class="comment">// str에는 주소가 들어올 수 있고 text는 이미 배열 포인터이다.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1. puts tests ---- \n"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"So Simple string!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2. fputs tests ---- \n"</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(str, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"So Simple String2!"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3. end of main ----"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">console --&gt;</span></span><br><span class="line"><span class="comment">1. puts tests ----</span></span><br><span class="line"><span class="comment">Simple String</span></span><br><span class="line"><span class="comment">So Simple string!</span></span><br><span class="line"><span class="comment">2. fputs tests ----</span></span><br><span class="line"><span class="comment">Simple String</span></span><br><span class="line"><span class="comment">So Simple String2!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>문자열 입력 함수</p>
</li>
<li>
<p>gets</p>
<p><code>char *gets(char *s);</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">7</span>]; <span class="comment">// 7바이트 메모리 문자배열 할당</span></span><br><span class="line">    gets(str); <span class="comment">// 입력 받은 문자열을 배열 str에 저장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>미리 마련해 놓은 배열을 넘어서 문자열이 입력되면, 할당 받지 않은 할당 받지 않은 메모리 공간을 침범하여 오류가 발생.</p>
<p>따라서 가급적이면 아래의 형태로 <code>fgets</code>함수를 호출 하는 것이 좋다.</p>
<ul>
<li>
<p>fgets</p>
<p><code>char *fgets(char *s, int n, FILE *stream);</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">7</span>];</span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>); <span class="comment">// stdin으로부터 문자열 받아 str에 저장.</span></span><br></pre></td></tr></table></figure>
<p>stdin으로부터 문자열을 받아 배열 <code>str</code>함수에 저장화되, sizeof(str)의 길이 만큼만 저장해라.</p>
<p>이럴 경우 stdin에 10바이트가 들어왔으면,<br>
앞에서부터 7바이트만 끊어서 저장하게 된다.</p>
<ol>
<li><code>&quot;123456789&quot;</code>를 입력.</li>
<li><code>&quot;123456&quot;</code>이 저장. 마지막 1바이트는 NULL문자.</li>
</ol>
</li>
<li>
<p>한 줄씩 읽기</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limit.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[LINE_MAX];</span><br><span class="line"><span class="keyword">if</span> (!fgets(buf, LINE_MAX, stream))&#123;</span><br><span class="line">    &lt;!-- 에러 --&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>POSIX는 <code>&lt;limit.h&gt;</code>에서 LINE_MAX를 정의하고 있는데,<br>
이는 POSIX의 행처리 인터페이스가 다룰 수 있는 입력행의 최대 길이이다.</p>
</li>
<li>
<p>원하는 만큼 문자열 읽기</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stream = fopen(<span class="string">"/etc/manifest"</span>, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *s;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">s = str;</span><br><span class="line"><span class="keyword">while</span> (--n &gt; <span class="number">0</span> &amp;&amp; (c = fgetc(stream)) != EOF &amp;&amp; (*s++ = c) != d)&#123;</span><br><span class="line">    <span class="comment">// str에 n-1바이트를 읽어 str에 저장하고, \0을 추가한다.</span></span><br><span class="line">    <span class="comment">// *s의 다음 주소에 c(n-1바이트를 읽은 것)를 넣고 그것이 d(같은 바이트)와 같지않은 동안 계속 stream에서 읽고 저장한다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c == d)&#123;</span><br><span class="line">    *--s = <span class="string">"/0"</span>;</span><br><span class="line">    &lt;!-- 키워드 매치가 되면서<span class="keyword">break</span>했을떄 --&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    *s = <span class="string">"/0"</span>;</span><br><span class="line">    &lt;!-- n<span class="number">-1</span> 바이트가 <span class="number">0</span>이거나, 파일을 전부 읽었을 때,--&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>d를 &quot;\n&quot;으로 설정하면 <code>fgets</code>와 유사하게 동작한다. 단 버퍼에 개행문자를 저장하지 않는다.</p>
</li>
</ul>
<hr>
<h2 id="표준_입출력과_버퍼"><a class="markdownIt-Anchor" href="#표준_입출력과_버퍼"></a> 표준_입출력과_버퍼</h2>
<p>ANSI C의 표준에서 정의된 함수들을 표준 입출력 함수라 한다.</p>
<p><code>printf</code>, <code>scanf</code>, <code>fputc</code>, <code>fgetc</code>, <code>fputs</code>, <code>fgets</code> 모두 표준 입출력 함수이다.</p>
<p>이 표준 입출력 함수를 통해서 입출력 하는 경우, 해당 데이터들은 운영체제가 제공 하는 **<code>메모리 버퍼</code>**를 중간에 통과하게 된다.</p>
<p><code>메모리 버퍼</code>는 디바이스 드라이버에 있으며, 커널과 연계된 데이터를 임시로 모아두는 메모리 공간이다.</p>
<h3 id="버퍼링을-하는-이유는-무엇-인가"><a class="markdownIt-Anchor" href="#버퍼링을-하는-이유는-무엇-인가"></a> 버퍼링을 하는 이유는 무엇 인가?</h3>
<ol>
<li>물론, 키보드 디바이스는 캐릭터 디바이스로서 단일 문자가 입력되면, 바로 인터럽션이 일어나지만,</li>
<li>버퍼링을 통해서 그것을 저장해놓는 등으로 해당 인터럽션을 중요도가 낮은 인터럽션으로 처리하는 행동을 한다.</li>
<li>그리고 엔터키가 입력되었을떄. 읽어들인다는 행동으로 연결지어,</li>
<li>저장해놓았던 버퍼를 소모하고 메모리를 비운다.</li>
</ol>
<p>이 버퍼링의 가장 큰 이유는 <strong>데이터 전송의 효율성</strong>과 관련이 있다.</p>
<p>키보드나 모니터 같은 외부장치의 데이터 입출력은 생각보다 시간이 오래 걸리는 작업이다.<br>
따라서 버퍼링 없이 키보드가 눌릴때마다, 바로 목적지 프로세스로 이동시키는 것보다.<br>
중간에 메모리 버퍼를 둬서 데이터를 한데 묶어 이동시키는 것이 효율적이고 빠르다.</p>
<h3 id="출력-버퍼를-비우는-fflush함수"><a class="markdownIt-Anchor" href="#출력-버퍼를-비우는-fflush함수"></a> 출력 버퍼를 비우는 <code>fflush</code>함수</h3>
<p><strong>함수호출 성공 시 0, 실패시 EOF 반환</strong></p>
<p><code>int fflush(FILE *stream)</code></p>
<p><code>fflush(stdout)</code>으로 호출하면, 표준 출력버퍼를 비워라 라는 명령이다.</p>
<hr>
<h3 id="입력버퍼-비우기"><a class="markdownIt-Anchor" href="#입력버퍼-비우기"></a> 입력버퍼 비우기</h3>
<p>출력버퍼를 비우는 것이 데이터가 목적지(프로세스)로 전송됨을 의미한다면,<br>
입력버퍼를 비우는 것은 <strong>데이터의 소멸</strong>을 의미한다.</p>
<ul>
<li>예제_1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> perID[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"주민번호 앞 6자리 입력: "</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    fgets(perID, <span class="keyword">sizeof</span>(perID), <span class="built_in">stdin</span>); <span class="comment">// block IOWAIT</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"이름 입력: "</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    fgets(name, <span class="keyword">sizeof</span>(name), <span class="built_in">stdin</span>); <span class="comment">// block_IOWAIT</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"주민번호: %s\n"</span>, perID);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"이름: %s\n"</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">console --&gt;</span></span><br><span class="line"><span class="comment">주민번호 앞 6자리 입력: 231423</span></span><br><span class="line"><span class="comment">이름 입력: 주민번호: 231423</span></span><br><span class="line"><span class="comment">이름: </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol>
<li>첫 <code>fgets()</code> 에서 7바이트를 읽어들이라고 했지만, \n을 만나는 순간 읽지 못하고 6바이트만 읽어들임.</li>
<li>2번째 <code>fputs()</code>에서 \n이 버퍼에 있기 떄문에, 바로 이스케이프.</li>
</ol>
<ul>
<li>예제_1 개선</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearLineFromReadBuffer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(getchar()!= <span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> perID[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"번호 앞 6자리 입력: "</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    fgets(perID, <span class="keyword">sizeof</span>(perID), <span class="built_in">stdin</span>); <span class="comment">// block IOWAIT</span></span><br><span class="line">    <span class="comment">// buffer = '\n'</span></span><br><span class="line">    ClearLineFromReadBuffer(); <span class="comment">// 입력버퍼 비우기</span></span><br><span class="line">    <span class="comment">// buffer = ''</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"이름 입력: "</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    fgets(name, <span class="keyword">sizeof</span>(name), <span class="built_in">stdin</span>); <span class="comment">// block_IOWAIT</span></span><br><span class="line">    ClearLineFromReadBuffer(); <span class="comment">// 입력버퍼 비우기</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"주민번호: %s\n"</span>, perID);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"이름: %s\n"</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ClearLineFromReadBuffer</code>에서 한문자로 취급되는 <code>\n</code> null이 읽혀지면 while문을 더 이상 수행하지 않는다.</p>
<p>따라서 그 시점에 버퍼에서 \n이라는 문자가 읽혀짐으로써 버퍼의 첫 \n이 사라짐.</p>
<hr>
<h2 id="file과_stream_그리고_일반파일의_입출력"><a class="markdownIt-Anchor" href="#file과_stream_그리고_일반파일의_입출력"></a> FILE과_STREAM_그리고_일반파일의_입출력</h2>
<h3 id="fopen함수-호출을-통한-파일과-스트림-형성-file구조체"><a class="markdownIt-Anchor" href="#fopen함수-호출을-통한-파일과-스트림-형성-file구조체"></a> fopen함수 호출을 통한 파일과 스트림 형성, FILE구조체</h3>
<p><strong>성공 시 해당파일의 FILE구조체 변수의 주소 값, 실패시 NULL포인터 반환</strong></p>
<p><code>FILE fopen(const char *filename, const char *mode);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE * fp=fopen(<span class="string">"simple.txt"</span>, <span class="string">"wt"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"file open fails!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fputc(<span class="string">'A'</span>, fp);</span><br><span class="line">    fputc(<span class="string">'B'</span>, fp);</span><br><span class="line">    fputc(<span class="string">'C'</span>, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"sample!\n"</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>wt</code>모드로 inode를 가르키고 close하는 순간 실행중인 프로세스 메모리가 해제된다.</p>
<p>fputc를 실행한다고, 바로 저장되는 것이 아니라,<br>
운영체제 단에서는 어느정도 버퍼메모리에 저장해놓고, 모든 변경된 버퍼를 수집해서 최적수준으로 정려한 후에 디스크에 쓴다.<br>
이러한 과정을 <code>writeback</code>이라 한다.</p>
<p>이런 방식은 쓰기호출을 빠르게 수행해서 거의 즉시 반환하도록 만든다.</p>
<p>그래서 버퍼메모리에 있지만 아직 파일 HDD로 저장하겠다는 시스템콜로 전달되지 않았다면.<br>
중간에 있던 커널쪽에 프로세스별로 디바이스 드라이버를 통해 관리하던 버퍼가 소멸되면서, 저장되지 못한채로 끝나게 된다.</p>
<p>그런 문제를 방지 하기 위해서, 커널은 최대 버퍼나이를 만들어 나이가 꽉찬 변경된 버퍼를 빠짐없이 기록한다.<br>
물론 HDD에 전달하였으나, HDD에서 또한 버퍼메모리로 잡아놓고 실제 물리적으로 저장하는 것은 좀 더딘 일이 되기도 한다.</p>
<hr>
<h2 id="바이너리데이터_읽기"><a class="markdownIt-Anchor" href="#바이너리데이터_읽기"></a> 바이너리데이터_읽기</h2>
<p>어떤 어플리케이션에서는 개별 문자나 행을 읽어서 버퍼에 입력하는 기능만으로는 부족한 경우가 있다.<br>
종종 C구조체같은 복잡한 바이너리데이터를 읽고 써야 하는 경우가 생긴다.<br>
이를 위해 표준입출력 라이브러리는 <code>fread()</code>함수를 제공한다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nr, FILE *stream);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>stream</code>에서 크기가 <code>size</code>바이트인 엘리먼트를 <code>nr</code>개 읽어서 buf가 가리키는 버퍼에 저장한다.</li>
<li>파일 포인터가 읽은 바이트에 숫자만큼 증가한다.</li>
<li>읽어들인 엘리먼트 개수가 반환된다.</li>
<li><code>nr</code>보다 적은 값을 반환하여 실패나 EOF를 알려준다.</li>
<li><code>ferror()</code>, <code>feof()</code>를 사용해야 두 조건중 어디에 해당하는지 확인 가능하다.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">size_t</span> nr;</span><br><span class="line">nr = fread(buf, <span class="keyword">sizeof</span>(buf), <span class="number">1</span>, stream);</span><br><span class="line"><span class="keyword">if</span> (nr == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="바이너리데이터_쓰기"><a class="markdownIt-Anchor" href="#바이너리데이터_쓰기"></a> 바이너리데이터_쓰기</h3>
<p>C변수처럼 바이너리 데이터를 직접 저장하려면 표준 입출력에서 제공하는 <code>fwrite()</code>를 사용한다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nr, FILE *stream);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>buf</code>가 가리키는 데이터에서 <code>size</code>크기의 엘리먼트 nr개를 stream에 쓴다.</li>
<li>파일 포인터는 기록한 바이트 개수만큼 전진한다.</li>
<li>성공시 엘리먼트 개수를 반환하고,</li>
<li><code>nr</code>보다 받은 반환값은 실패를 나타낸다.</li>
</ol>
<hr>
<h2 id="버퍼입출력_프로그램"><a class="markdownIt-Anchor" href="#버퍼입출력_프로그램"></a> 버퍼입출력_프로그램</h2>
<ol>
<li><code>struct pirate</code>를 정의 하고 이 타입의 변수 2개 선언.</li>
<li>변수 값중 하나를 초기화,</li>
<li>출력 스트림을 통해 data파일에 이 내용을 기록.</li>
<li>data에 대한 입력스트림을 열고 이를 통해 내용을 읽은 다음,</li>
<li>다른 <code>struct pirate</code>인스턴스를 그대로 복구.</li>
<li>마지막으로 그 구조체의 내용을 표준 출력에 전달.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *in, *out;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pirate</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> booty;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> beard_len;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pirate</span> <span class="title">blackbeard</span> = &#123;</span><span class="string">"Edward Teach"</span>, <span class="number">950</span>, **<span class="number">48</span>**&#125;; <span class="comment">// data FILE에 저장할(초기화정보)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pirate</span> <span class="title">p</span>;</span> <span class="comment">// data FILE을 읽어서 저장할.</span></span><br><span class="line"></span><br><span class="line">    out = fopen(<span class="string">"data"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!out)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fwrite(&amp;blackbeard, <span class="keyword">sizeof</span>(struct pirate), <span class="number">1</span>, out))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fwrite"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fclose(out))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fclose"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    in = fopen(<span class="string">"data"</span>, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fread(&amp;p, <span class="keyword">sizeof</span>(struct pirate), <span class="number">1</span>, in))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fread"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fclose(in))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fclose"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name=\"%s\" booty=%lu beard_len=%u\n"</span>,</span><br><span class="line">           p.name, p.booty, p.beard_len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total=%li\np.name=%li\np.booty=%li\np.bread_len=%li"</span>, <span class="keyword">sizeof</span>(p),<span class="keyword">sizeof</span>(p.name), <span class="keyword">sizeof</span>(p.booty), <span class="keyword">sizeof</span>(p.beard_len));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">"Edward Teach"</span> booty=950 beard_len=48</span><br><span class="line">total=120</span><br><span class="line">p.name=100</span><br><span class="line">p.booty=8</span><br><span class="line">p.bread_len=4</span><br></pre></td></tr></table></figure>
<p>변수 크기, 정렬등에서 차이가 있기 때문에, 특정 어플리케이션에서 쓴 바이너리 데이터를<br>
다른 어플리케이션에서 읽지 못할 수 있다.</p>
<blockquote>
<p>아키텍쳐와 ABI가 동일한 경우에만, 바이너리 데이터를 일관적으로 읽고 쓸 수 있다.</p>
</blockquote>
<h2 id="추가_유용한_기능들"><a class="markdownIt-Anchor" href="#추가_유용한_기능들"></a> 추가_유용한_기능들</h2>
<h3 id="스트림-비우기"><a class="markdownIt-Anchor" href="#스트림-비우기"></a> 스트림 비우기</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<p>스트림을 비우는 것은 이해해야할 것이 많다. 일단 이것은 사용자 영역에서 일어나는 함수이고,</p>
<p>스트림을 비우면 <code>프로세스 stream</code>에 있고 <code>아직 커널 파일버퍼로</code> 전달되지 않은 <code>데이터를 커널로</code> 비운다.</p>
<p><code>stream이 NULL이면</code> 프로세스에 할당된 <code>모든 파일 디스크립터의 입력스트림이</code> 비워진다.</p>
<p>데이터를 커널메모리로 내리고 프로세스 메모리에서 해제한다.<br>
만약 동기식 입출력처럼 물리적인 기록을 어느정도 보장 받고 싶다면, <code>fsync()</code>를 사용한다.</p>
<p><code>fflush()</code>를 호출한 다음 바로 <code>fsync()</code>를 호출한다.</p>
<h3 id="fd스트림_에러체크"><a class="markdownIt-Anchor" href="#fd스트림_에러체크"></a> fd스트림_에러체크</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ferror(f))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error on f!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (feof(f))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"EOF on f!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">clearerr(f); <span class="comment">// void 타입, 항시 성공. 에러를 비운다.</span></span><br></pre></td></tr></table></figure>
<h3 id="파일-디스크립터-얻어오기"><a class="markdownIt-Anchor" href="#파일-디스크립터-얻어오기"></a> 파일 디스크립터 얻어오기</h3>
<ul>
<li>파일 디스크립터 생성
<ol>
<li><code>open</code></li>
<li><code>creat</code></li>
</ol>
</li>
<li>파일을 추상화하는 스트림 생성
<ol>
<li><code>fopen</code></li>
</ol>
</li>
<li>디스크립터로부터 추상화된 스트림으로 변환
<ol>
<li><code>fdopen</code></li>
</ol>
</li>
</ul>
<p>종종 스트림에서부터 디스크립터를 구해야하는 경우가 있다.<br>
예를 들어. 표준 입출력함수가 없을 때, 그 파일 디스크립터를 통해서 시스템콜을 수행할 수 있다면 유용할 것이다.</p>
<p>스트림에서 파일디스크립터를 구하려면 <code>fileno()</code>를 사용한다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<p>성공하면 stream과 관련된 파일 디스크립터를 반환하고, 실패하면 -1을 반환한다.</p>
<p>주어진 스트림이 유효하지 않는 경우에만 실패하며 이 경우 <code>errorno</code>는 <code>EBADF</code>로 설정</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/08/19/c/IO_functions/" data-id="ckkdb52f300011pqk3mnqplcx" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux/memory_of_process" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/16/linux/memory_of_process/" class="article-date">
  <time datetime="2019-08-16T01:09:52.000Z" itemprop="datePublished">2019-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/16/linux/memory_of_process/">basic concept of linux / about memory</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> Index</h2>
<ol>
<li>BIOS, UEFI등(메인보드 임베디드 소프트웨어)으로 인해 OS가 메모리 레벨(커널메모리)로 이동. (프로세스지만 일반프로세와는 다른취급)</li>
<li>OS가 구동, 커널(실행자)과 사용자영역(프로세스)을 관리함.</li>
<li>Hdd에서 ELF같은 실행파일을 읽어오면서, 코드영역블록을 <code>TEXT세그먼트-메모리</code>로 할당함과 동시에 커널 메모리에 프로세스 PID 매핑.(선점형 스케쥴링-OS가 강력하게 관제)</li>
<li>커널 내부에 보관되어 있는 페이지 테이블을 사용하여, 프로세스에 할당할 물리주소를 가상주소로 변환하여, 페이지 테이블을 마찬가지로 제공</li>
<li>페이지 테이블(프로세스의)에서 한페이지에 대한 데이터를 <code>페이지 테이블 엔트리</code>라 칭함. 가상주소와 물리주소 대응정보.</li>
<li>프로세스의 가상 메모리 페이지에 최초 실행과 동시에 매핑되는 것은 아래와 같다.
<ul>
<li>커널 메모리주소</li>
<li>프로세스 코드영역 데이터(실행부, 프로세스의 실행으로서의 정체)</li>
<li>프로세스 데이터영역 데이터(초기 실행에 필요한 자원, C라이브러리 등 라이브러리 오브젝트 파일)</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li><a href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%A3%BC%EC%86%8C_%EA%B3%B5%EA%B0%84"><strong>프로세스 주소 공간</strong></a></li>
<li><a href="#%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%98%81%EC%97%AD"><strong>메모리 영역</strong></a></li>
</ol>
<hr>
<h2 id="프로세스_주소_공간"><a class="markdownIt-Anchor" href="#프로세스_주소_공간"></a> 프로세스_주소_공간</h2>
<p>프로세스에서 직접 물리메모리 주소에 접근하지 않고,<br>
커널이 개별프로세스에 독자적인 가상 주소 테이블을 제공한다.<br>
(이 주소 공간은 0에서 시작 연속적으로 늘어난다.)</p>
<h3 id="페이지와_페이징"><a class="markdownIt-Anchor" href="#페이지와_페이징"></a> 페이지와_페이징</h3>
<p>워드는 바이트로 구성되고, 페이지는 워드로 구성된다.<br>
페이지는 <code>메모리 관리 유닛(MMU)</code>에서 관리할 수 있는 최소 단위다.</p>
<p>페이지 크기는 아키텍쳐에서 결정</p>
<ul>
<li>32비트 시스템: 4KB</li>
<li>64비트 시스템: 8KB</li>
</ul>
<ol>
<li>프로세스가 <code>mmap()</code>을 통해 메모리 풀(8KB)을 단위로 확보 하는 것을 <strong>가상메모리를 확보 했음</strong>이라 하며 페이지 단위 메모리 확보,(프로세스당 4gb정도씩 가상주소 선 할당)</li>
<li>최초로 해당 페이지들에 <code>malloc()</code>(바이트 단위 메모리 확보)을 통해서 데이터를 매핑하려 시도하면, 최초에 물리메모리 주소가 매핑되어 있지 않기 때문에, <code>세그먼테이션 폴트</code>를 일으킨다.</li>
<li>그러면 커널메모리의 MMU에서 해당 가상주소를 물리주소로 변환하고, 데이터를 실제로 메모리에 저장한다.</li>
<li>어떤 변수가 사용된지 오래되었고, 다른 프로세스를 활성하다가 해당 변수를 이 별도 프로세스에서 <code>페이징 아웃</code> 하였을 경우.</li>
<li>다시 해당 변수에 접근하면 해당 페이지의 매핑된 실제 주소가 HDD레벨로 내려가있을 것이고 그것을 <code>페이지 폴트</code>라 한다.</li>
<li>페이지 폴트가 났다는 건 다시 메모리 레벨로 페이지를 끌어올리겠다는 것이기 떄문에, 어딘가 쓸모없다고 판단되는 페이지를 커널이 <code>free()</code>한다.</li>
</ol>
<blockquote>
<p>커널은 페이징에 따른 성능 부하(HDD접근수 증가에 따른)를 줄이기 위해, 가까운 미래에 덜 쓰일 것으로 예상되는 데이터를 페이징 아웃한다.</p>
</blockquote>
<h3 id="공유와_copy-on-write"><a class="markdownIt-Anchor" href="#공유와_copy-on-write"></a> 공유와_copy-on-write</h3>
<ul>
<li>
<p>공유 메모리란?<br>
가상 메모리에 존재하는 여러 페이지는 프로세스별로 유일하지만,<br>
여러 가상 페이지의 엔드포인트가 특정 물리 페이지로 매핑될 수 있다.<br>
이런 방식으로 물리 메모리에 있는 데이터를 여러 프로세스에서 공유한다.</p>
</li>
<li>
<ul>
<li>예를 들어 여러 프로세스가 표준 C라이브러리를 사용할 때,<br>
각 프로세스는 표준 C라이브러리를 저마다의 가상 주소공간으로 매핑<br>
실제 메모리에는 HDD에서 복사해서 올라온 하나의 페이지만이 존재한다.</li>
</ul>
</li>
<li>
<p>공유 데이터를 특정 프로세스에서 수정하였을 때,<br>
공유 데이터는 읽기전용, 쓰기전용, 혹은 모두 가능한 형태로 존재.<br>
쓰기가 가능한 공유 데이터를 어떤 프로세스에서 OVERWRITE하였을 때,</p>
<ol>
<li>프로세스간 일정 수준의 조정과 동기화가 필요하지만, 반영된 페이지를 공유하거나,</li>
<li><code>COW방식</code>, MMU가 쓰기 요청을 가로체서 예외를 던진다.<br>
그러면 커널은 쓰기 요청한 프로세스를 위해 해당 페이지의 복사본을 생성,<br>
새로 만들어진 페이지에 대해 쓰기요청을 계속 진행</li>
</ol>
</li>
</ul>
<p>실제로 실 메모리 공간을 절약하기 위해, 여러 프로세스는 공유된 페이지에 대해서 읽기작업을 수행한다.</p>
<h2 id="메모리_영역"><a class="markdownIt-Anchor" href="#메모리_영역"></a> 메모리_영역</h2>
<p>커널은 접근 권한과 같은 특정 속성을 공유하는 블록 내부에, 페이지를 배열한다. 이런 블록을 맵핑, 메모리 영역이라고 한다.<br>
모든 프로세스에는 다음과 같은 메모리 영역이 존재한다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">segement</th>
<th style="text-align:center">types</th>
<th style="text-align:left">adds</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Text</td>
<td style="text-align:center">프로세스의 코드영역, 문자열 상수, 상수변수, 읽기전용 데이터</td>
<td style="text-align:left">리눅스에서 이 세그먼트는 읽기전용. 실행파일과 라이브러리 오브젝트파일에서 직접 맵핑</td>
</tr>
<tr>
<td style="text-align:left">Stack</td>
<td style="text-align:center">프로세스의 실행 스텍(지역변수, 함수의 반환데이터)</td>
<td style="text-align:left">실행 스텍은 스택 깊이가 깊어지고 얕아짐에 따라, 동적으로 크기 변경된다. 멀티스레드의 경우 스레드당 하나의 스텍이 존재</td>
</tr>
<tr>
<td style="text-align:left">Heap(DATA)</td>
<td style="text-align:center">프로세스의 동적 메모리</td>
<td style="text-align:left">이 세그먼트는 쓰기가 가능하고, 크기변경이 가능하다. <code>malloc()</code>은 이 영역을 할당한다.</td>
</tr>
<tr>
<td style="text-align:left">BSS</td>
<td style="text-align:center">초기화 되지 않은 전역변수</td>
<td style="text-align:left">이 변수는 C표준에 따라(기본값 0) 특수한 값을 담고 있다.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>대부분의 주소공간은 매핑된 실행파일 혹은 C나 공유 라이브러리, 데이터파일을 포함.<br>
<code>/proc/self/maps</code>파일을 열어 보거나 <code>pmap</code>명령어를 사용하여, 프로세스 맵핑파일을 살펴 볼 수 있다.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/08/16/linux/memory_of_process/" data-id="ckkdb52fj000c1pqkj347tr3z" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">다음 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/custom-module/">custom module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fabric/">fabric</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/functional-programming/">functional programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-deploy/">hexo-deploy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pipenv/">pipenv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgresql/">postgresql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-module/">python module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-post/">python post</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/testing/">testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travel-note/">travel_note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tutorial/">tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그 클라우드</h3>
    <div class="widget tagcloud">
      <a href="/tags/c/" style="font-size: 11.43px;">c</a> <a href="/tags/custom-module/" style="font-size: 12.86px;">custom module</a> <a href="/tags/django/" style="font-size: 14.29px;">django</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/fabric/" style="font-size: 10px;">fabric</a> <a href="/tags/functional-programming/" style="font-size: 11.43px;">functional programming</a> <a href="/tags/hexo-deploy/" style="font-size: 10px;">hexo-deploy</a> <a href="/tags/http/" style="font-size: 11.43px;">http</a> <a href="/tags/linux/" style="font-size: 15.71px;">linux</a> <a href="/tags/network/" style="font-size: 11.43px;">network</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/pipenv/" style="font-size: 10px;">pipenv</a> <a href="/tags/postgresql/" style="font-size: 10px;">postgresql</a> <a href="/tags/project/" style="font-size: 10px;">project</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/python-module/" style="font-size: 17.14px;">python module</a> <a href="/tags/python-post/" style="font-size: 18.57px;">python post</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/testing/" style="font-size: 10px;">testing</a> <a href="/tags/travel-note/" style="font-size: 10px;">travel_note</a> <a href="/tags/tutorial/" style="font-size: 10px;">tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">아카이브</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">1월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">9월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">8월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">7월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">6월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">5월 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">최근 포스트</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/26/fastcamp/my_post/">test_post</a>
          </li>
        
          <li>
            <a href="/2019/09/17/http/2_http_sementics/">http_1.0_sementics</a>
          </li>
        
          <li>
            <a href="/2019/09/09/project/travel_note/">travel_note 서비스 고찰</a>
          </li>
        
          <li>
            <a href="/2019/09/06/http/1_http_1.0_basic_four_feature/">http/1.0의 신택스: 기본이 되는 네가지 요소</a>
          </li>
        
          <li>
            <a href="/2019/09/05/python/post/async_coroutine_5/">비동기 코루틴 번역-5-End</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 junehan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>