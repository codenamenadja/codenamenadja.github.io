<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Junehan&#39;s workbook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="with python and javascript, could be some descriptions or workflow writtens for project">
<meta name="keywords" content="python django">
<meta property="og:type" content="website">
<meta property="og:title" content="Junehan&#39;s workbook">
<meta property="og:url" content="https://codenamenadja.github.io/page/4/index.html">
<meta property="og:site_name" content="Junehan&#39;s workbook">
<meta property="og:description" content="with python and javascript, could be some descriptions or workflow writtens for project">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Junehan&#39;s workbook">
<meta name="twitter:description" content="with python and javascript, could be some descriptions or workflow writtens for project">
  
    <link rel="alternate" href="/atom.xml" title="Junehan&#39;s workbook" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junehan&#39;s workbook</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">work flow and descriptions</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="검색"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://codenamenadja.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-python/post/socket_programing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/post/socket_programing/" class="article-date">
  <time datetime="2019-06-19T09:27:36.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/post/socket_programing/">소켓프로그래밍 python C nodejs</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>소켓프로그래밍을 이해할때, 객체 지향적인 언어의 API를 이용해 왔다. nodeJS의 경우와 파이썬의 경우를 먼저 짧게 보여주기로 한다.</p>
</blockquote>
<hr>
<h2 id="1-nodejs-socket-programing"><a class="markdownIt-Anchor" href="#1-nodejs-socket-programing"></a> 1. nodeJS socket Programing</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># typescript로 작성했던 서버사이드 TCP소켓 어플리케이션</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> net <span class="keyword">from</span> <span class="string">"net"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    public app: net.Server;</span><br><span class="line">    public clientSockets: net.Socket[] = [];</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.app = net.createServer();</span><br><span class="line">        <span class="keyword">this</span>.serverConfigs();</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">static</span> bootstrap() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TCPServer();</span><br><span class="line">    &#125;</span><br><span class="line">    private socketConfigs(clientSocket: net.Socket): <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.clientSockets.push(clientSocket);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`server :client connected to server, all  </span></span><br><span class="line"><span class="string">         users:<span class="subst">$&#123;<span class="keyword">this</span>.clientSockets.length&#125;</span>`</span>);</span><br><span class="line">        clientSocket.on(<span class="string">"data"</span>,(data)=&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`recevied msg:<span class="subst">$&#123;data.toString()&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">if</span>(data.toString().trim().toLowerCase() == <span class="string">"quit"</span>)&#123;</span><br><span class="line">                clientSocket.write(<span class="string">"&gt;&gt;&gt; disconnect order requested!"</span>);</span><br><span class="line">                <span class="keyword">return</span> clientSocket.end();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.clientSockets.forEach(<span class="function">(<span class="params">otherSocket</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(otherSocket !== clientSocket)&#123;</span><br><span class="line">                    otherSocket.write(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        clientSocket.on(<span class="string">"close"</span>,(isError)=&gt;&#123;</span><br><span class="line">            <span class="keyword">const</span> index =<span class="keyword">this</span>.clientSockets.indexOf(clientSocket);</span><br><span class="line">            <span class="keyword">if</span>(index !== <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.clientSockets.splice(index, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    private serverConfigs() &#123;</span><br><span class="line">        <span class="keyword">this</span>.app.on(<span class="string">"connection"</span>, (socket) =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.socketConfigs(socket);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.app.on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`error Message from server : <span class="subst">$&#123;err.message&#125;</span>`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.app.on(<span class="string">"close"</span>, () =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"close server"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> singleServer = TCPServer.bootstrap();</span><br><span class="line">singleServer.app.listen(<span class="number">8000</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"server opende at port 8000"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-python으로-작성된-크롤링-tcp소켓-어플리케이션"><a class="markdownIt-Anchor" href="#2-python으로-작성된-크롤링-tcp소켓-어플리케이션"></a> 2. python으로 작성된 크롤링 Tcp소켓 어플리케이션</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetcher</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.sock = socket.socket()</span><br><span class="line">    self.sock.setblocking(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.sock.connect((<span class="string">'xkcd.com'</span>,<span class="number">80</span>))</span><br><span class="line">    <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    selector.register(</span><br><span class="line">        self.sock.fileno(),</span><br><span class="line">        EVENT_WRITE,</span><br><span class="line">        self.connected,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(self, key, mask)</span>:</span></span><br><span class="line">    print(<span class="string">'connected'</span>)</span><br><span class="line">    selector.unregister(key.fd)</span><br><span class="line">    req = <span class="string">'GET &#123;&#125; HTTP/1.0\r\nHOST: xkcd.com\r\n\r\n'</span>.format(self.url)</span><br><span class="line">    self.sock.send(req.encode(<span class="string">'ascii'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#register next callback</span></span><br><span class="line">    selector.register(</span><br><span class="line">        key.fd,</span><br><span class="line">        EVENT_READ,</span><br><span class="line">        self.read_response</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<ul>
<li>공통점은 추상화가 매우 잘되어 있다는 점이다.<br>
그 중에서도 노드JS의 추상화는 정말 말도 안되는 수준이라,<br>
우리는 그저 소켓모듈에서 소켓객체를 불러와 callable하거나 한 그것을 생성하고, 전달해주고,<br>
한번 들어온 소켓은 캐쉬에 저장되어 다시 주소를 로드할 필요 없이 연결을 보장하는 스트림인 TCP이기 때문에,<br>
그것을 <figure class="highlight plain"><figcaption><span>callback) clientsock.on("exit",callback)``` 로 이벤트를 바인딩 해주어, 클래스 내부에 생성해놓은 static리스트에 넣어놓기만 하면, 알아서 처리해주니,  </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"> 정확한 과정에 대해서 정말 전혀 몰라도, 아무런 문제없이 돌아가는 것만 같다.</span><br><span class="line"></span><br><span class="line"> - 반면 파이썬은 C를 그대로 가져온 인터프리터여서 그런지, 네이밍등 모양새가 절차적인 특성을 가지고 있다.  </span><br><span class="line"> 그렇다고 해도, 축약되는 부분은 있다. 하지만 이 정도는 박수 받아야 할 정도라는 것은 안다.</span><br><span class="line"></span><br><span class="line">&gt; 하지만 정확한 절차에 대해서 어떤 과정이 필요한지, 자세히 알아볼 필요가 있다. C의 코드를 기술한다.</span><br><span class="line">____</span><br><span class="line">## 3. C로 작성된 TCP소켓 어플리케이션</span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">void error_handling(char *message);</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int serv_sock;</span><br><span class="line">    int clnt_sock;</span><br><span class="line">    struct sockaddr_in serv_addr;</span><br><span class="line">    struct sockaddr_in clnt_addr;</span><br><span class="line">    int clnt_addr_size</span><br><span class="line"></span><br><span class="line">    char message[]=&quot;Hello World!\n&quot;;</span><br><span class="line"></span><br><span class="line">    if(argc != 2)&#123;</span><br><span class="line">        printf(&quot;Usage : %s &lt;port&gt; \n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STRAM, 0); /*서버 소켓 생성*/</span><br><span class="line">    if(serv_sock == -1)</span><br><span class="line">        error_handling(&quot;socket() error&quot;);</span><br><span class="line">    </span><br><span class="line">    memset(&amp;serv_addr, 0, sizeof(serv_addr))</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port=htons(atoi(argv[1]));</span><br><span class="line"></span><br><span class="line">    if(bind(serv_sock, (struct sockaddr*) &amp;serv_addr, sizeof(serv_addr)==-1))</span><br><span class="line">    /*소켓에 주소 할당*/</span><br><span class="line">        error_handling(&quot;bind() error&quot;);</span><br><span class="line">    </span><br><span class="line">    if(listen(serv_sock, 5) == -1) /*연결 요청 대기상태로 진입*/</span><br><span class="line">        error_handling(&quot;listen() error&quot;);</span><br><span class="line">    </span><br><span class="line">    clnt_addr_size = sizeof(clnt_addr);</span><br><span class="line"></span><br><span class="line">    clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line">    /*연결요청 수락 함수accept*/</span><br><span class="line"></span><br><span class="line">    if(clnt_sock==-1)</span><br><span class="line">        error_handling(&quot;accept() error&quot;);</span><br><span class="line">    </span><br><span class="line">    write(clnt_sock, message, sizeof(message)); /*데이터 전송*/</span><br><span class="line">    close(clnt_sock); /*연결 종료*/</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void error_handling(char *message)</span><br><span class="line">&#123;</span><br><span class="line">    fputs(message,stderr);</span><br><span class="line">    fputc(&apos;\n&apos;,stderr);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>서버소켓을 생성한다.(PF_INET:인터넷프로토콜, SOCK_STREAM:TCP방식, 0)</li>
<li>서버소켓에 주소 할당 35~38 줄에서 주소정보 구조체 변수를 초기화해주고,<br>
145에서 서버 소켓에 bind</li>
<li>서버가 주소를 가졌으니, 연결오청 대기상태로 들어가야함.<br>
149에서 listen(서버소켓, 연결대기 시퀸스 길이)</li>
<li>대기 큐에서 대기하고 있는 클라이언트의 연결 요청에 대해서, 수락.<br>
154에서 accept를 통해 대기큐에 첫번째로 기다리고 있는 클라이언트의 연결요청을 수락하고 있다.</li>
<li>accept 함수 호출 시 리턴된 파일 디스크립터를 가지고 클라이언트와 데이터를 주고받을 차례.<br>
일반적으로 파일을 가지고 입출력하던 방식과 동일하게 데이터 주고받음.<br>
write(클라이언트소켓, message, sizeof)는 시스템이 제공해주는 low Level I/O 이다.<br>
이를 통해 데이터를 전송한다. I/O-bound하다는 것은 여기서 시작된다.</li>
<li>이제 클라이언트에게 전송할 소켓을 닫아주면서  연결을 종료한다.</li>
</ol>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/post/socket_programing/" data-id="ckkdb52hz002y1pqk6yzrhe36" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/how_python_saves_memory_with_string" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/post/how_python_saves_memory_with_string/" class="article-date">
  <time datetime="2019-06-19T09:25:35.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/post/how_python_saves_memory_with_string/">파이썬이 문자열을 저장할 때 어떻게 데이터를 저장하는가? 번역</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="출처-httpsrushtercomblogpython-strings-and-memory"><a class="markdownIt-Anchor" href="#출처-httpsrushtercomblogpython-strings-and-memory"></a> 출처 : <a href="https://rushter.com/blog/python-strings-and-memory/" target="_blank" rel="noopener">https://rushter.com/blog/python-strings-and-memory</a></h2>
<p>파이썬3 이후로 문자 타입은 유니코드를 사용하기 시작했다. 유니코드 문자열은<br>
4bytes(16bits)의 크기까지 캐릭터를 인코딩에 따라 수용할 수 있다.<br>
메모리적 측면에서는 때로 고비용이라고 느껴질 수 있다.</p>
<p>메모리소모를 줄이고 퍼포먼스를 개선하기위해 파이썬은<br>
유니코드 문자열의 3가지 내부적인(Internal rep…) 추상화를 이용한다.<br>
1byte per char(Latin-1 endcoding)<br>
2bytes per char(UCS-2 endcoding)<br>
4bytes per char(UCS-4 endcoding)<br>
파이썬을 프로그래밍할때 파이썬의 모든 문자열은 동일하게 동작한다.<br>
그리고 대부분의 경우에 우리는 어떤 변화도 눈치채지 못한다.<br>
그러나 변화는 매우 주목할만하고, 때로는 예상치못하다<br>
(많은 양의 문자열을 다룰때,)</p>
<p>내부적인 추상화에서 차이를 확인하려면, 우리는 sys.getsizeof<br>
를 이용할 수 있다.(그것은 객체의 크기를 bytes로환산해준다.)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">string = <span class="string">'hello'</span></span><br><span class="line">sys.getsizeof(string)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">54</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-byte encoding</span></span><br><span class="line">sys.getsizeof(string+<span class="string">'!'</span>)-sys.getsizeof(string)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2-byte encoding</span></span><br><span class="line">string2  = <span class="string">'你'</span></span><br><span class="line">sys.getsizeof(string2+<span class="string">'好'</span>)-sys.getsizeof(string2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4-byte encoding</span></span><br><span class="line">string3 = <span class="string">'🐍'</span></span><br><span class="line">sys.getsizeof(string3+<span class="string">'💻'</span>)-sys.getsizeof(string3)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br><span class="line">sys.getsizeof(string3)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>당신이 보는 것처럼 문자열의 내용에 따라, 파이썬은 다른 인코딩을 사용한다. 그것을 기억하라,<br>
파이썬의 모든 개별 문자열은 49~80bytes의 메모리를 추가적인 정보를 보관하는 지점에 추가로 소모한다.<br>
예를 들면 hash, length in bytes, encoding type, string flags<br>
등이 있다. 그것이 빈 문자객체가 49byte의 메모리를 소모하는 이유이다.</p>
<p>우리는 인코딩을 추론할 수 있다, 직접 객체에 대해 ctypes: 를 사용함으로.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PyUnicodeObject</span><span class="params">(ctypes.Structure)</span>:</span></span><br><span class="line">    <span class="comment"># internal fields of the string object</span></span><br><span class="line">    _fields_ = [(<span class="string">"ob_refcnt"</span>, ctypes.c_long),</span><br><span class="line">                (<span class="string">"ob_type"</span>, ctypes.c_void_p),</span><br><span class="line">                (<span class="string">"length"</span>, ctypes.c_ssize_t),</span><br><span class="line">                (<span class="string">"hash"</span>, ctypes.c_ssize_t),</span><br><span class="line">                (<span class="string">"interned"</span>, ctypes.c_uint, <span class="number">2</span>),</span><br><span class="line">                (<span class="string">"kind"</span>, ctypes.c_uint, <span class="number">3</span>),</span><br><span class="line">                (<span class="string">"compact"</span>, ctypes.c_uint, <span class="number">1</span>),</span><br><span class="line">                (<span class="string">"ascii"</span>, ctypes.c_uint, <span class="number">1</span>),</span><br><span class="line">                (<span class="string">"ready"</span>, ctypes.c_uint, <span class="number">1</span>),</span><br><span class="line">                <span class="comment"># ...</span></span><br><span class="line">                <span class="comment"># ...</span></span><br><span class="line">                ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_string_kind</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> PyUnicodeObject.from_address(id(string)).kind</span><br><span class="line"></span><br><span class="line">get_string_kind(<span class="string">'Hello'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line">get_string_kind(<span class="string">'你好'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line">get_string_kind(<span class="string">'🐍'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>만약 문자열의 모든 글자들이 ASCll 범위안에 맞을 수 있다면,<br>
그들은 1-byte Latin-1 인코딩을 사용한다. 기본적으로,<br>
Latin-1은 최초의 256 유니코드-캐릭터를 추상화한다.<br>
이것은 많은 라틴어를 지원한다. 그러나 라틴어 계열 언어가 아니라면 그럴 수 없다.<br>
아시아, 아프리카등 일대의 언어에 대해서 그러하다. 이것이<br>
그들의 코드포인트(숫자상의 인덱스들)가 1-byte(0-255)범위 밖을 정의하게 된 이유이다.<br>
이모티콘 절때 쓰지마라 문자의 4배 이상 메모리가 소요된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ord(<span class="string">'a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">97</span></span><br><span class="line">ord(<span class="string">'你'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">20320</span></span><br><span class="line">ord(<span class="string">'!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">33</span></span><br></pre></td></tr></table></figure>
<h3 id="왜-파이썬이-내부적으로-utf-8을-사용하지-않는가"><a class="markdownIt-Anchor" href="#왜-파이썬이-내부적으로-utf-8을-사용하지-않는가"></a> 왜 파이썬이 내부적으로 UTF-8을 사용하지 않는가?</h3>
<p>UTF-8인코딩에 문자가 저장되어 있다면, 개별 글자는 자신이 추상화<br>
하는 정보에 따라 1-4bytes의 메모리를 사용하여 encoded된다.<br>
그것은 저장상 효율적인 인코딩이다.<br>
그러나 한가지 큰 단점이 있다!<br>
-개별 문자가 1-4bytes의 메모리에 저장되어 있어서, 문자를 열람하지 않고서, 인덱싱으로 무작위단어에 대해 접근이 불가능하다.<br>
그래서 쉬운 명령인 string[5]의 경우도 UTF-8파이썬은 요구된 문자를 찾을 때 까지 스캔을 해야한다.<br>
고정된 길이의 인코딩은 그런 문제가 없다.<br>
글자를 인덱스에 따라 원본을 찾기위해, 파이썬은 그저 한 캐릭터의 인덱스 번호를 늘리면 그만이다.</p>
<h3 id="string-interning"><a class="markdownIt-Anchor" href="#string-interning"></a> string interning</h3>
<p>빈 문자나 ASC2의 문자열중 특정 문자를 다룰 때, 파이썬은 string interning(문자를 잡아 놓음)을 사용한다.<br>
잡혀있는 문자는 싱글턴 객체처럼 행동해서, 그 말은,<br>
두개의 독립적인 문자객체가 잡혀있다면, 그들은 그들중 하나의 복사본만 메모리에 보관하는 것이다.</p>
<ul>
<li>id()메서드를 통한 다른객체 동일 글자에 대한 동일한 주소에 대한 이야기.<br>
이것은 파이썬의 문자객체는 immutable하기 때문이다.</li>
</ul>
<p>파이썬에서 문자열을 잡아 놓는 것은, 글자나, 빈 문자객체에만 국한되지 않는다.<br>
문자열,(코드를 컴파일하면서 생성된,)은 그들의 길이가 20글자를 초과하지 않는다면,<br>
또한 저장될(잡히다) 수 있다.<br>
이것은 포함한다.<br>
-함수 &amp; 클래스 이름들<br>
-변수명들<br>
-매개변수 이름들<br>
-상수들(코드에 선언된 모든 문자들)<br>
-Dictionary의 키 이름들<br>
-속성의 이름들</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'teststring'</span></span><br><span class="line">b = <span class="string">'teststring'</span></span><br><span class="line">id(a), id(b), a <span class="keyword">is</span> b</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">4569487216</span>, <span class="number">4569487216</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="string">'test'</span>*<span class="number">5</span></span><br><span class="line">b = <span class="string">'test'</span>*<span class="number">5</span></span><br><span class="line">len(a), id(a), id(b), a <span class="keyword">is</span> b</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">20</span>, <span class="number">4569499232</span>, <span class="number">4569499232</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="string">'test'</span>*<span class="number">6</span></span><br><span class="line">b = <span class="string">'test'</span>*<span class="number">6</span></span><br><span class="line">len(a), id(a), id(b), a <span class="keyword">is</span> b</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">24</span>, <span class="number">4569479328</span>, <span class="number">4569479168</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>open(‘aa.txt’,‘r’).read()등을 통한 할당은 적용되지 않는다.<br>
그것은 일종의 외부 스트림에 의존 하는 것이지 상수가 아니기 때문이다.</li>
</ul>
<p>문자를 잡아 놓는 기술은 동일한 내용의 문자선언을 줄여준다.<br>
내부적으로, 문자를 잡아 놓는 것은 global dictionary에 의해<br>
유지된다.(global dictionary, 문자들이 키로서 보관되는 곳이다. 그곳에<br>
이미 특정 문자열이 메모리 안에 있는지 보기 위해<br>
파이썬은 dictionary의 key조회하는 명령을 수행한다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/post/how_python_saves_memory_with_string/" data-id="ckkdb52ho002k1pqki9b6oc0t" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/memory_and_GC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/post/memory_and_GC/" class="article-date">
  <time datetime="2019-06-19T09:22:23.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/post/memory_and_GC/">파이썬의 GC와 메모리 관리자</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>
<h2 id="reference-counting-official-python-doc"><a class="markdownIt-Anchor" href="#reference-counting-official-python-doc"></a> reference counting -official Python doc</h2>
</li>
</ul>
<ol>
<li>
<p>Py_INCEREF(), Py_DECREF()등을 통하여 레버런스 Count를 관리하고,<br>
(파이썬 인터프리터와 메모리관리자가)<br>
refcount가 최초로 0에서 1로 Init되면서, garbage collection의 Generation[0]부터 등록을 시작한다.</p>
</li>
<li>
<p>refcount에 따라서 자연스럽게 Deallocate memory를 시도하는데, 만약 Cyclic Garbage Collector에 최초에 참가한다는 타입이라고 초기화된 객체라면(PyObject_New()를 Exnted 하는 PyObject_init()으로 인한 선언이었을때,<br>
: 추가적으로 타입등의 정보를 추가하여 객체의 Fields를 더해서 선언하는,</p>
</li>
<li>
<p>detector’s Set of observed Objects에 추가된다. 이것이 객체 생성의 최종 마무리 이며 다른 필드에 대한 영향은 없다. 함수 실행과 종료와함께 Deallocate되는 객체에 대해서는 따로 GC에 대한 등록없이 스텍과 함께 사라지도록 구현되어있을것이다.</p>
</li>
<li>
<p>그러나 순환참조가 일어나는 객체라면 초기화 당시, 타입과 함께 Python_init()으로 선언될 때 Garbage collection의 어느 부분에 dictionary의 형태로 관리된다.</p>
</li>
</ol>
<hr>
<ul>
<li>
<h2 id="gc의-라이프사이클에-대해"><a class="markdownIt-Anchor" href="#gc의-라이프사이클에-대해"></a> GC의 라이프사이클에 대해</h2>
</li>
</ul>
<p>gc.get_thredhold()를 통하여 리턴되는 것은 generation[0]~ generation[2] 까지 수용할 수 있는 총 객체의 수다.</p>
<ol>
<li>
<p>최초 객체 선언시 Refcount도 올라가지만, Generation[0]에 등록함으로써</p>
</li>
<li>
<p>generation에 바인딩된 이벤트가 특정 수치에 도달하였을 때</p>
<ol>
<li>generation[0].count=0</li>
<li>gen[1].count++,</li>
</ol>
</li>
<li>
<p>그리고 gen[0]에서 아직 레퍼런스가 남아있거나, cyclic garbage collector의 set of observed object에 등록되어 있고 아직 유효하다면</p>
<ol>
<li>0세대에 등록되어 있는 객체들은 1세대로 등록된다.</li>
</ol>
</li>
<li>
<p>메모리 해제를 위한 검사가 실행되면 gen[2]부터 gen[0]의 순서로 검사가 실행된다.</p>
</li>
</ol>
<hr>
<ul>
<li>
<h2 id="순환참조가-일어나지-않는-객체의-메모리-해제"><a class="markdownIt-Anchor" href="#순환참조가-일어나지-않는-객체의-메모리-해제"></a> 순환참조가 일어나지 않는 객체의 메모리 해제</h2>
</li>
</ul>
<p>기본적으로 객체는 Refcount라는 개념이 내장되어있다, 그 객체가 Gc의 generation에 등록되어 있지 않다고 한다면, 자체적으로 Ref가 0이 되는 스스로의 allocation을 해제한다.</p>
<hr>
<ul>
<li>
<h2 id="인스타그램은-gc를-사용하지-않기로-했다고한다"><a class="markdownIt-Anchor" href="#인스타그램은-gc를-사용하지-않기로-했다고한다"></a> 인스타그램은 GC를 사용하지 않기로 했다고한다.</h2>
</li>
</ul>
<ol>
<li>
<p>인스타그램의 서버는 순환참조를 일으키는 객체의 생성을 최대한 막고 함수지향적인 코드를 작성하여 서버를 운영해 왔다고 한다.</p>
</li>
<li>
<p>그러나 GC가 늘 onloadState이라는 점이나 일부 순환참조가 일어나는 객체들 등에 의해서, cache miss가 적지 않다고 느꼈다.</p>
</li>
<li>
<p>그래서 파이썬 오피셜이 제안했던 것처럼 gc.disable()을 통해 해제 했으나,</p>
<ul>
<li>서드파티에서 gc.enable()을 호출하는 등 결국 효과를 보지 못했기 때문에,</li>
</ul>
</li>
<li>
<p>threshold의 제한수를 없애주어서 Gc가 수행되는 시점을 사라지게 했다.\</p>
<ul>
<li>수행되는 시점에 그 모든 객체에 대해서 순환참조 탐지 알고리즘을 적용하는 것이 기존의 Cache를 가득 메우는 점이 맘에 안들었던 것이다.<br>
그 양이 적지 않아 워낙에 대규모 서비스 이다보니, 다른일로 돌아가야 하는데도 가상메모리상에 pageFault가 일어났다고 한다.</li>
</ul>
</li>
</ol>
<ul>
<li>
<h2 id="결과"><a class="markdownIt-Anchor" href="#결과"></a> 결과</h2>
</li>
</ul>
<ol>
<li>
<p>개별 서버에 8gb 정도의 메모리사용량을 비울 수 있다고 했다.</p>
<blockquote>
<p>이는 더 많은 메모리 소모를 필요로 하는 서버를 생성할 수 있다는 얘기이다.</p>
</blockquote>
</li>
<li>
<p>CPU의 IPC(Cycle 당 instruction 수)가 10% 가까이 증가하였다.</p>
<blockquote>
<p>cache miss가 2~3%가량 이득을 보았던 점이 IPC성능의 관건있다고 한다.</p>
</blockquote>
</li>
<li>
<p>cache miss는 큰 자원소모이다. cache miss -&gt; CPU Pipeline에 Stall발생</p>
<blockquote>
<p>youtube(<a href="https://www.youtube.com/watch?v=twQKAoq2OPE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=twQKAoq2OPE</a>)에 등장하는 것처럼 최대한 많은 공유 라이브러리를 공유 메모리로서 캐쉬안에 보관 될 수 있어서, 많은 page들이 캐싱상태에 존재하고이는 Stall을(CPU와 캐시사이의 새로운 allocation등을 위한 Fetch를 포함한 결과까지) 최대한 막아주기 때문에 Cpu가 빠르게 동작하도록 한다.</p>
</blockquote>
</li>
</ol>
<hr>
<p>OS는 프로세스들이 (코드 혹은 데이터 세그먼트)공유를 통해 최적화를 하기 원하지만, 힙 안에서, 개별적인 세그먼트를 통해 독립적인 네임스페이스를 형성하기 때문에, reference-counted code objects는 이 이점을 가질 수 없다.</p>
<blockquote>
<p>1—&gt; 36-- r <a href="http://libc.so" target="_blank" rel="noopener">libc.so</a> (C 기반-라이브러리를 읽어와서)</p>
<p>0—&gt; 35-- r python.exe (파이썬을 플랫폼으로)</p>
</blockquote>
<p>프레임 워크가 기인하는 라이브러리(C등으로 구성된,)는 stdio를 임포트하는 라인이 있더라도,<br>
해당라인은 명령으로서 미리 힙의 크기만 빈 크기만 할당하고, 실제로 필요해졌을때, 해당요소를 HDD레벨에서 로드하여 가져온다.</p>
<p>동등한 프로세스의 경우 PID가 달라서 프로그램은 그들의 코드레벨 혹은 Data 레벨이 어떤 동일한 데이터를 공유할 수 있는지 알수 없다.</p>
<p>ChildProcess개념에서 childprocess.spawn() as fork까지 개념이 늘어가면, 기존의 프로세스가 spawn한 child process가 자신의 부모프로세스에 대해 코드레벨에서 동일한 프레임을 참조하는 페이지 공유환경이 성립된다. 스텍이 구현된 프레임은 자식프로세스가 새로운 콜스텍 메모리 w해야 하기 때문에 다른 페이지로 매핑된다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/post/memory_and_GC/" data-id="ckkdb52hq002n1pqk57ebbmcx" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/memory_management" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/post/memory_management/" class="article-date">
  <time datetime="2019-06-19T09:20:11.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/post/memory_management/">파이썬의 메모리 관리 번역</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>파이썬 내의 메모리 관리는 사적인 힙을 포함한다, 모든 파이썬 객체와 자료구조를 포함하는.<br>
이 프라이빗한 힙의 관리는 내부적으로 파이썬 메모리 관리자에의해 보장받는다.<br>
파이썬 메모리 관리자는 다른 컴포넌트들을 가지고 있다, 다양한 다이나믹 저장소 관리 측면에서 업무를 하는.<br>
예를 들면 공유 분할, 선할당 혹은 캐싱처럼 말이다.</p>
<p>가장 낮은 레벨에서 본래 메모리 할당자는 보장한다, 프라이빗 힙엔 충분한 방이 있다고, 모든 파이썬 관련 데이터를 보관하기 위해, 운영체제의 메모리 관리자와 소통함으로써.<br>
순수 메모리 할당자 위에, 몆몆 객체-특정 할당자가 동일한 힙에서 작동하고, 개별적인 메모리 관리 정책을 수행한다, specific 모든 객체 타입에 대해 적용되는 정책.<br>
예를 들면 정수객체는 힙안에서 문자객체들, 튜플객체들 혹은 딕셔너리 객체들과 다르게 관리된다 힙 안에서, 왜냐하면, 정수는 다른 저장소 요구사항을 적용받고, 속도와 스페이스에 있어서 트레이드 오프가 있기 때문이다.<br>
파이썬 메모리 관리자는 그러므로 특정-객체 할당자들에게 일부 업무들에 있어서 달라붙는다. 그러나 후에 연산이 실행됨이 프라이빗 힙에서 진행된다는 것을 보장한다.</p>
<p>이것은 중요하다 이해하는 것에 있어서, 파이썬 개인힙의 관리가 인터프리터 그 자체로 의해 진행되고, 유저는 그것에 대한 컨트롤이 없다는 것, 비록 만약 유저들이 주기적으로, 자주 객체들이 힙의 메모리 블락을 가르키도록 다루더라도 말이다. 힙-스페이스에 대한 메모리 할당에 있어서 파이썬 객체들은 그리고 다른 내부적인 버퍼들은 파이썬 메모리 관리자에 의해서 요구되는 것으로 인해 실행된다. Python/C API functions가 그들의 문사에 리스트화 된 것을 통해서.</p>
<p>충돌을 막기 위해, 확장된 작성자들은 절때 파이썬 객체를 C라이브러리에서 송출된 함수들로 조정하려 해서는 안된다.<br>
C라이브러리: malloc(), calloc(), realloc() and free().<br>
이것은 결과로 할것이다, 뒤섞인 호출들, C-할당자와 파이썬 메모리 매니저 사이에, 치명적인 결과와 함께, 왜냐하면 그들은 다른 알고리즘을 수행하고, 다른 힙에서 구동되기 때문이다. 그러나 한가지는 안전하게 할당되고 메모리블럭들을 놓아줄수 있다. 특별한 목적을 위한 c-라이브러리 할당자에 의해서. 그 예시는 아래예시이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PyObject *res;</span><br><span class="line">char *buf = (char *) malloc(BUFSIZ); /*<span class="keyword">for</span> I/O*/</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buf == NULL)</span><br><span class="line">    <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line"><span class="comment">#...Do some I/O operation involving buf...</span></span><br><span class="line">res = PyBytes_FromString(buf);</span><br><span class="line">free(buf)<span class="string">' /*malloc'</span>ed*/</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<p>이 예제에서, 메모리의 I/O버퍼에 대한 요청은 C-라이브러리 할당자에 의해서 이루어진다. 파이썬 메모리 매니저는 오직 문자객체가 결과로서 리턴되는 것의 할당에관해서만 관련된다.</p>
<p>대부분의 상황에서, 그러나, 이것은 추천된다, 메모리를 파이썬 힙으로부터 구체적으로 할당하는 것을. 왜냐하면 나중의 문제는 파이썬 메모리 매니저에 의해서 관리될 수 있기 때문이다. 예를 들어 이것은 요구된다 인터프리터가 C로 작성된 새로운 객체타입으로 확장되었을때. 다른 이유로 파이썬 힙을 사용하는 것은 파이썬 메모리 매니저에게 알리기 위해서 이다. 확장된 모듈에 대한 메모리 요구를.<br>
만약 요구된 메모리가 예외적으로 내부적으로 사용되고, 높은 수준의 특별한 목적에 의해 사용하더라도, 파이썬 메모리 매니저에게 메모리에 관한 모든 요구를 찾아 올려보내는 것은 인터프리터로 하여금 더 많은 이것의 메모리 전체 기록에 관한 정확한 이미지를 요구하도록 야기할 것이다. 결과적으로, 특정 환경 아래에서, 파이썬 메모리 관리자는 적절한 액션을 취할 수 있고 아닐 수 있다. 예를 들면 Garbage-collection 처럼, 메모리 컴팩트화 혹은 다른 예방차원의 과정을. C-라이브러리를 이전 예제처럼 사용하는 것은, I/O버퍼를 위해 할당된 메모리가 파이썬 매니저로부터 도망가도록 한다는 것을 기억하라.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/post/memory_management/" data-id="ckkdb52hr002p1pqko3v9wmj1" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/async_coroutine_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/post/async_coroutine_1/" class="article-date">
  <time datetime="2019-06-19T09:11:02.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/post/async_coroutine_1/">비동기 코루틴 번역-1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="a-web-crawler-with-ayncio-coroutines"><a class="markdownIt-Anchor" href="#a-web-crawler-with-ayncio-coroutines"></a> <a href="https://www.aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html" target="_blank" rel="noopener">A Web crawler with ayncio Coroutines</a></h2>
<h2 id="written-by-ajesse-jiryu-and-guido-van-rossum"><a class="markdownIt-Anchor" href="#written-by-ajesse-jiryu-and-guido-van-rossum"></a> Written by, A.Jesse Jiryu and guido van Rossum</h2>
<h3 id="intoduction"><a class="markdownIt-Anchor" href="#intoduction"></a> intoduction</h3>
<p>고전적인 컴퓨터 과학은 강조한다 효율적인 알고리즘을, 컴퓨테이션을 가능한 빠르게 수행하는 알고리즘.<br>
그러나 많은 네트워크 프로그램은 그들의 시간이 아니라, 많은 연결을 유지하는 곳에, 그것은 느리거나 드문 이벤트를 지닌다.<br>
이 프로그램들은 많은 다른 도전을 과시한다.: 많은 거대한 네트워크 이벤트들을 효과적으로 기다리기를.<br>
이 문제에 대한 동시대의 접근은 비동기적 I/O 혹은 Async이다.</p>
<p>이 챕터는 간단한 웹크롤러를 보여준다. 크롤러는 전형적인 비동기 어플리케이션이다. 왜냐하면 이것은 많은 응답들을 기다리고 있기 떄문이다.<br>
그러나 작은 컴퓨테이션을 수행한다. 많은 페이지를 한번에 송수신 한다면, 더 빠르게 이것은 종료된다.<br>
이것이 만약 쓰레드를 진행중인 각각의 리퀘스트에 힘을 쏟는다면, 그러면 동시성 리퀘스트 수가 느는 것 만큼<br>
이것은, 메모리가 부족해질것 이거나, 다른 쓰레드관련 리소스를 소모하게 될 것이다, 이것이 소켓을 다 소모하기 전에.<br>
이것은 쓰레드에 대한 필요성을 피하게 해준다. 비동기 IO를 사용함으로써.</p>
<p>3가지 스테이지로 나눠서 예를 보여준다.<br>
첫째 스테이지: 우리는 비동기 이벤트루프를 보여주고, 콜백을 사용하는 이벤트루프를 이용하는 크롤러를 그린다.<br>
이것은 매우 효과적일 수 있다.<br>
그러나 이것을 더 복잡한 문제로 끌고 갈수록 그것은 관리할 수 없는 스파게티코드로 인도할 것이다.</p>
<p>둘째 스테이지: 그러므로 우리는 파이썬 코루팅들이 효과적이면서 동시에 확장가능하다는 것을 보여줄 것이다. 우리는 간단한 코루틴을 실행할것이다. 파이썬에서 제네레이터를 사용함으로써.</p>
<p>셋째 스테이지: 우리는 최대로 능력을 끌어올린 파이썬 코루틴을 사용할 것이다. 파이썬의 표준 &quot;asyncIO&quot;라이브러리, 그리고 그들을 async queue를 이용해 조직화 한다.</p>
<h3 id="the-task"><a class="markdownIt-Anchor" href="#the-task"></a> The Task</h3>
<p>웹 크롤러는 모든 페이지를 찾고 다운로드한다, 비록 그들을 기록하거나, 번호를 메기려 할 목적이라도 말이다. 루트 URL로 시작해서, 모든 페이지를 fetch하고, 그것을 보여지지 않은 페이지들의 링크로 파싱한다. 그리고 그들을 queue에 올린다. 이것은 모든페이지에 대해서 Fetch가 완료하고, queue가 비었을 때 멈출 것이다.</p>
<p>우리는 이 프로세스를 많은 페이지를 동시적으로 다운로드 함으로써, 가속할 수 있다. 크롤러가 새로운 링크를 찾으면, 이것은 동시Fetch 명령을 실행한다.(개별소켓위의 새로운 페이지들을 얻어 오기 위한)<br>
이것은 응답이 도착하는 데로 파싱하고, 새로운 링크를 큐에 올린다.<br>
거기엔 그런 리턴을 절감하는 포인트들이 함께 올 수 있다.(어딘가 너무 많은 동시성이 퍼포먼스를 저하시키는 곳에)<br>
그래서 우리는 동시성 리퀘스트의 수의 한도를 정한다. 그리고 큐에 남은 링크들을 그냥 둔다.<br>
일부 진행중인 리퀘스트가 끝날 때까지.</p>
<h3 id="traditional-approach"><a class="markdownIt-Anchor" href="#traditional-approach"></a> Traditional approach</h3>
<p>고전적으로 우리는 쓰레드 풀을 생성해서 크롤러를 동시적으로 만들었다. 각 쓰레드는 소켓을 통해서 한번에 하나의 페이지를 다운받는 역할을 맡고 있었다. 예를 들어 다운로드 xkcd.com을 한다면:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(url)</span>:</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    sock.connect((<span class="string">"xkcd.com"</span>,<span class="number">80</span>))</span><br><span class="line">    req = <span class="string">'GET &#123;&#125; HTTP/1.0\r\nHost: xkcd.com/r/n/r/n'</span>.format(url)</span><br><span class="line">    sock.send(request.encode(<span class="string">'ascii'</span>))</span><br><span class="line">    response = <span class="string">b''</span></span><br><span class="line">    chunk = sock.recv(<span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">while</span> chunk:</span><br><span class="line">        response += chunk</span><br><span class="line">        chunk = scok.recv(<span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Page is now downloaded.</span></span><br><span class="line">    links = parse_links(response)</span><br><span class="line">    q.add(links)</span><br></pre></td></tr></table></figure>
<p>기본적으로 소켓의 수행은 블로킹이다. 쓰레드가 connect, recv등을 수행할때 그러하다. 이것은 수행이 끝날때까지 멈춰있다.<br>
동시적으로 많은 페이지를 한번에 받기위해서, 우리는 많은 쓰레드가 필요하다. 정교한 어플리케이션은 쓰레드를 생성하는 비용을 쓰레드풀에 대기중인 쓰레드를 보관함으로써 분할처리한다. 그리고 그들을 동시적인 일에 재사용 할 수 있게 체크해나간다. 이것은 소켓의 커넥션풀과 동일한 것을 하는 것이다.</p>
<p>그러나 쓰레드는 비싸다, OS는 그들을 프로세스당 쓰레드의 수가 많아지는 것을 강력하게 제어한다. 프로세스나 유저, 혹은 머신이 가질 수 있는 쓰레드말이다.</p>
<p>제시의 시스템에서 파이썬 쓰레드는 50k정도 비용의 메모리를 소모한다. 천개중 열개의 쓰레드를 실행하는 것은 실패를 부른다. 그것을 동시적인 명령으로 동시성 소켓으로 확장한다면, 소켓이 다 떨어지기전에, 쓰레드가 다 떨어진다. 쓰레드당 오버헤드 혹은 시스템의 제한은 굉장히 목을 조른다.</p>
<p>영향력있는 기사인 The C10K problem - Dan kegel 에서는 IO동시성을위한 멀티쓰레딩의 제한을 그린다.<br>
그는 이렇게 시작한다.</p>
<p>이제 웹서버가 만명의 클라이언트를 동시에 처리해야 한다. 그렇지 않은가? 어찌됐든, 웹은 이제 커다란 장소가 되었다.</p>
<p>1999년에 작성된 이것은 만개의 연결이라고하면 다소 앙증맞게 들린다. 그러나 그떄와 달라진건 규모일 뿐이지 같은 이야기를 우리는 하고 있다.<br>
그때는 연결당 쓰레드를 생성하는 것은 실용적이지 않았다. 이제 OS의 쓰레드 생성제한수는 높아졌다.<br>
게다가 우리의 장난감 웹 크롤러는 쓰레드만으로 잘 작동할 것이다. 그러나, 거대한 어플리케이션에서,<br>
10만개의 연결과 함께하는 그런 어플리케이션에서는, 제한 수는 이것을 말한다.:<br>
거기에는 제한수를 뛰어넘게 소켓을 생성할 수 있는 시스템이 많은데, 쓰레드는 부족하다. 이걸 우린 어떻게 극복할 것인가?</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/post/async_coroutine_1/" data-id="ckkdb52hf00291pqknqxfc6zo" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/async_coroutine_2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/post/async_coroutine_2/" class="article-date">
  <time datetime="2019-06-19T09:11:02.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/post/async_coroutine_2/">비동기 코루틴 번역-2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="coroutines"><a class="markdownIt-Anchor" href="#coroutines"></a> Coroutines</h2>
<p>우리는 당신을 Promise로 유도하고 싶다.<br>
비동기처리에 대해서 콜백의 효율성과 조합하여 과거 멀티쓰레딩 프로그래밍의 클래식한 것을 사용해서 작성하는 것이 가능하다.<br>
이 조합은 &quot;Coroutine&quot;이라는 패턴과 함께 얻을 수 있는 것이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@async.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(self,url)</span>:</span></span><br><span class="line">    respnse = <span class="keyword">yield</span> <span class="keyword">from</span> self.session.get(url) <span class="comment"># 콜백의 첫 단계</span></span><br><span class="line">    body = <span class="keyword">yield</span> <span class="keyword">from</span> response.read() <span class="comment"># 연속적 이벤트에 대한 콜백</span></span><br></pre></td></tr></table></figure>
<p>이것은 또한 스케일러블하다. 멀티쓰레딩으로 작업하던 당시, 50Kb의 자원이<br>
하나의 쓰레드를 생성하는데 들어갔었고, OS는 그것에 대해 엄격한 CAPs를 적용하고 있었다.<br>
그러나 파이썬의 코루틴은 거의 3K만을 차지하고 있고,<br>
따라서 매우 쉽게 수십만개의 코루틴한 객체들을 생성하고 실행할 수 있다.</p>
<hr>
<h3 id="코루틴에-대한-컨셉은-아주-쉽다-고전적인-컴퓨터-과학과-비추어-봤을때"><a class="markdownIt-Anchor" href="#코루틴에-대한-컨셉은-아주-쉽다-고전적인-컴퓨터-과학과-비추어-봤을때"></a> 코루틴에 대한 컨셉은 아주 쉽다!!? (고전적인 컴퓨터 과학과 비추어 봤을때…)</h3>
<p>그것은 서브루틴(함수 개념)이며 멈출 수 있고 다시 진입 할 수 있다.</p>
<p>반면에 쓰레드는 우선적으로(OS가 강제력을 가지는 스케쥴링 방식) OS에 의해 멀티테스킹 되어진다.<br>
<code>asyncio</code>라이브러리에 구현되어 있는 코루틴들은 제너레이터를 기반으로 구성 되어 있다.<br>
Future class와 <code>yield from</code>선언자가 그것이다.</p>
<p>그것은 파이썬의 프라이빗 힙 중 스텍프레임에 직속으로 할당되는 프레임들이기에,<br>
기존의 메인 쓰레드를 중심으로 생성된 쓰레드가 스텍프레임으로서 레벨에 존재한다.</p>
<p>개별적으로 이전의 공유자원에 대해 접근할 수 있지만, <strong>Race condition</strong>이 발생할 수 있고,<br>
프로그래머 레벨에서 <strong>MUTEX(Mutual exclusion)</strong> 처리로 핸들링을 해주거나,<br>
세마포어 기법을 통해 멀티프로그래밍 환경에서 실행자들이 임계구역(공유자원)에<br>
접근하기 전에 각각 전처리, 후처리 등을 추가하는 방법이 있다.</p>
<blockquote>
<p>MUTEX는 기본적으로 작동원리의 레벨이나, 그 기저에 위치한 것이 아니라, 업무의 할당이라는 개념으로 로직-코드레벨에서 직접 제어하는 것이다.</p>
</blockquote>
<p>그러나 코루틴은 자신이 서브루틴으로서 직접 언제 멈출지, 이후 어떤 코루틴을 실행할 지 선택할 수 있다.<br>
코루틴에 대한 많은 실행법이 있지만, (“파이썬만 해도 여러가지를 가지고 있다!”)</p>
<ol>
<li>스탠다드 라이브러리 &quot;asyncio&quot;에 있는 코루틴들은 제너레이터를 기반으로 만들어져 있다</li>
<li>Future class</li>
<li><code>yield from CALLBACK_on_Socket_connected()</code></li>
</ol>
<p>yield 하는 싱글 스레드의 주도권은 일시적을 해당 제너레이터로 넘어간다.<br>
yield from 을 통해 외부 Global frame에서 전달받은 것은 자신의 프레임 내부로 가져온다.<br>
routine과 위와 같은 방식으로 소통한다.</p>
<p>python.exe입장에서는 자신의 프로세스가 늘어나는것도, 공식적인 쓰레드가 늘어나는 것도 아니어서, OS에 대해서 영향을 주는 것이 아니다.<br>
그저 자신의 기존 스텍에 대해서 혼란을 주지 않고, 힙에 있는 가스텍을 메인스텍으로 대체한다는 개념에 더욱 가깝다.</p>
<p>파이썬 3.5로 부터, 코루틴은 파이썬 언어의 네이티브한 특성이 되었다.<br>
3.4버전 부터 구현된 코루틴을 기존의 언어의 자원을 이용하여 이해하는 것은<br>
3.5버전의 네이티브 코루틴을 걸고넘어지는 기초가 된다.</p>
<p>3.4버전의 제너레이터 기반의 코루틴을 설명하기 위해서, 우리는 일단 제너레이터를 이해하는 것부터 시작해서,<br>
어떻게 그들이 <code>asyncio</code>에서 코루틴으로 사용되었는지 접근 해야한다.<br>
제너레이터 기반 코루틴을 설명하고 나면, 그것을 기꺼이 비동기적 웹 크롤러에 사용할 것이다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/post/async_coroutine_2/" data-id="ckkdb52hh002b1pqkcxwfu1d3" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/async_coroutine_4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/post/async_coroutine_4/" class="article-date">
  <time datetime="2019-06-19T09:11:02.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/post/async_coroutine_4/">비동기 코루틴 번역-4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="제너레이터로_코루틴_구성하기"><a class="markdownIt-Anchor" href="#제너레이터로_코루틴_구성하기"></a> 제너레이터로_코루틴_구성하기</h2>
<p>우리의 코루틴들은 <code>Asyncio</code>라이브러리 등으로 단순화 될 것이다.<br>
우리는 <code>generator</code>, <code>future</code>, <code>yield from</code>을 사용할 것이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = <span class="literal">None</span></span><br><span class="line">        self._callbacks = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_done_callback</span><span class="params">(self,fn)</span>:</span></span><br><span class="line">        self._callbacks.append(fn)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span><span class="params">(self,result)</span>:</span></span><br><span class="line">        self.result = result</span><br><span class="line">        <span class="keyword">for</span> fn <span class="keyword">in</span> self._callbacks:</span><br><span class="line">            fn(self)</span><br></pre></td></tr></table></figure>
<p>위의 future은 원천적으로 <code>pending</code>상태이다. 그리고 <code>set_result</code>를 통해서 <code>resolved</code>된다.<br>
fetcher에 futures와 코루틴을 적용해 보자.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sock = socket.socket()</span><br><span class="line">        self.sock.setblocking(<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.sock.connect(&#123;<span class="string">"xkcd.com"</span>, <span class="number">80</span>&#125;)</span><br><span class="line">        <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        selector.register(self.sock.fileno(),</span><br><span class="line">        EVENT_WRITE,</span><br><span class="line">        self.connected</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(self, key, mask)</span>:</span></span><br><span class="line">        print(<span class="string">"connected!"</span>)</span><br></pre></td></tr></table></figure>
<p><code>fetch</code> 메서드는 소켓연결을 시도하고, 콜백을 등록한다.<br>
그 콜백은 소켓이 준비되었을때, 실행될 것이다.<br>
우리는 이 두 단계를 하나의 코루틴으로 조합할 것이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(self)</span>:</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    sock.setblocking(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.connect(&#123;<span class="string">"xkcd.com"</span>, <span class="number">80</span>&#125;)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    f = Future()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connected</span><span class="params">()</span>:</span></span><br><span class="line">        f.set_result(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    selector.register(</span><br><span class="line">        sock.fileno(),</span><br><span class="line">        EVENT_WRITE,</span><br><span class="line">        on_connected</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> f</span><br><span class="line">    selector.unregister(</span><br><span class="line">        sock.fileno()</span><br><span class="line">    )</span><br><span class="line">    print(<span class="string">"connected"</span>)</span><br></pre></td></tr></table></figure>
<p>이제 <code>fetch</code>는 제너레이터 함수이다. 우리는 <code>pending</code>중인 future을 생성한다.<br>
그리고 yield를 통해서 이것을 정지시키고, 소켓이 연결되었을 때까지, stop상태로 heap에서 대기한다.<br>
<code>on_connected</code>함수가 등록되어 커널이 소켓에서 예약해놓은 이벤트 시그널을 감지하면,<br>
다시 실행될 것이다. 그 콜백인 내부 on_connected가 future을 진행 시킬 것이다.</p>
<p>그러면 future이 진행될 때, 무엇이 제너레이터로 재진입하게 만드는가?<br>
우리는 코루틴 <code>driver</code>가 필요하다. 이것을 <code>task</code>라 명명하겠다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, coro)</span>:</span></span><br><span class="line">        self.coro = coro</span><br><span class="line">        f = Future()</span><br><span class="line">        f.set_result(<span class="literal">None</span>)</span><br><span class="line">        self.step(f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(self, future)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            next_future = self.coro.send(future.result)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        next_future.add_done_callback(self.step)</span><br><span class="line"></span><br><span class="line"><span class="comment"># begin fetching</span></span><br><span class="line">fetcher = Fetcher(<span class="string">"/353/"</span>)</span><br><span class="line">Task(fetcher.fetch())</span><br><span class="line"></span><br><span class="line">loop()</span><br></pre></td></tr></table></figure>
<p>task는 fetch제너레이터를 <code>None</code>을 <code>send()</code>함으로써 시작시킨다.<br>
fetch는 그것이 future을 <code>yield</code>하기 전까지 동작한다.<br>
그 future은 task가 <code>next_future</code>로써 처리한다.<br>
소켓이 연결되고 나면, 이벤트 루프가 <code>on_connected</code>를 실행시킨다.<br>
그 함수는 future을 진행시키고, <code>step</code>을 호출한다.<br>
그 <code>step</code>함수가 코루틴 함수로 재진입을 실행한다.</p>
<h2 id="코루틴을_yield-from으로_전환하기"><a class="markdownIt-Anchor" href="#코루틴을_yield-from으로_전환하기"></a> 코루틴을_<code>yield from</code>으로_전환하기</h2>
<p>소켓이 연결되고 나면, 우리는 GET에 대한 응답을 받을 것이다.<br>
이러한 과정은 더이상 callback들 사이에 분산될 필요가 없다.<br>
그것을 하나의 제너레이터 함수에 모을 것이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(self)</span>:</span></span><br><span class="line">    sock.send(request.encode(<span class="string">"ascii"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f = Future()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">on_readable</span><span class="params">()</span>:</span></span><br><span class="line">            f.set_result(sock.recv(<span class="number">4096</span>))</span><br><span class="line"></span><br><span class="line">        selector.register(</span><br><span class="line">            sock.fileno(),</span><br><span class="line">            EVENT_READ,</span><br><span class="line">            on_readable</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        chunk = <span class="keyword">yield</span> f</span><br><span class="line">        selector.unregister(sock.fileno())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> chunk:</span><br><span class="line">            self.response += chunk</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Done Reading</span></span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>햔재 코드는 소켓에서 모든 메세지를 읽고 있다.<br>
우리가 이 fetch에서 어떻게 서브루틴으로 전환 할 수 있을까?<br>
<code>yield from</code>을 사용해야 할 때이다, 예시를 보자</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_fn</span><span class="params">()</span>:</span></span><br><span class="line">    result = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">f"result of yield_1 <span class="subst">&#123;result&#125;</span>"</span>)</span><br><span class="line">    result_2 = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    print(<span class="string">f"result of yield_2 <span class="subst">&#123;result_2&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"done"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caller_fn</span><span class="params">()</span>:</span></span><br><span class="line">    gen = gen_fn()</span><br><span class="line">    rv = <span class="keyword">yield</span> <span class="keyword">from</span> gen <span class="comment"># line 10</span></span><br><span class="line">    print(<span class="string">f"return val of yield-from: <span class="subst">&#123;rv&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"all done"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    caller = caller_fn()</span><br><span class="line">    caller.send(<span class="literal">None</span>)</span><br><span class="line">    print(<span class="string">"instruction: "</span>, caller.gi_frame.f_lasti)</span><br><span class="line">    <span class="comment"># intruction: 10</span></span><br><span class="line">    caller.send(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="comment"># result of yield_1 hello</span></span><br><span class="line">    print(<span class="string">"instruction: "</span>, caller.gi_frame.f_lasti)</span><br><span class="line">    <span class="comment"># instruction: 10</span></span><br><span class="line">    caller.send(<span class="string">"goodbye"</span>)</span><br><span class="line">    <span class="comment"># result of yield_2 goodbye</span></span><br><span class="line">    <span class="comment"># return val of yield-from: done</span></span><br><span class="line">    <span class="comment"># Traceback...</span></span><br><span class="line">    <span class="comment"># StopIteration: all done</span></span><br></pre></td></tr></table></figure>
<p><code>caller</code>가 <code>gen</code>으로 부터 <code>yield from</code> 하는동안, <code>caller</code>은 instruction상태를 유지한다.<br>
루틴으로부터 send받은 것을 yield from 으로 컨텍스트를 양도한다.<br>
<code>caller</code>밖의 시점에서 바라볼때, 우리는 그것이 caller에서 오는 것인지, 또 다른 제너레이터에서 오는 것인지 알 수 없다.<br>
그리고 <code>gen</code>내부에서, 우리는 또한, <code>caller</code>에서 온것인지, 루틴에서 온것인지 알 수 없다.</p>
<blockquote>
<p><code>yield from</code>진술은 마찰없는 선언문이다. 값들이 <code>gen</code>이 종료되기 전까지, 안팎으로 이동한다.</p>
</blockquote>
<p>코루틴은 이렇듯 <code>yield from</code>을 통해서, 컨텍스트를 서브-코루틴으로 양도하고, 그 결과를 받을 수 있다.<br>
마지막에 <code>gen</code>에서 돌려받은 값을 &quot;return val of yield-from: done&quot;으로 받은 것을 생각하자.</p>
<p><code>rv = yield from gen</code></p>
<p>우리가 초기에 callback기반 비동기 프로그래밍을 평가 할때, 우리의 주요 불평은, <code>stack ripping</code>에 대한 것이었다.</p>
<ul>
<li><code>stack-ripping</code>: 콜백이 예외를 발생하면, <code>stack trace</code>가 무의미해진다.</li>
</ul>
<p>그러면 우리가 만든 코루틴 기법은 어떤 결과를 보일까?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_fn</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># raise Exception("my error")</span></span><br><span class="line">    result = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">f"result of yield_1 <span class="subst">&#123;result&#125;</span>"</span>)</span><br><span class="line">    result_2 = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    print(<span class="string">f"result of yield_2 <span class="subst">&#123;result_2&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"done"</span></span><br></pre></td></tr></table></figure>
<p>가장 link-depth가 깊은 스텍에 에러를 억지로 발생해 보면, 정확히 에러를 분석할 수 있는 것을 알 수 있다.<br>
<code>caller_fn</code>이  <code>gen_fn</code>을 바라보고 있다는 것을 스텍 트레이싱을 통해서 알 수 있다.<br>
우리는 서브-코루틴을 호출할때, 래핑을 하여 에러 핸들링을 할 수 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caller_fn</span><span class="params">()</span>:</span></span><br><span class="line">    gen = gen_fn()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rv = <span class="keyword">yield</span> <span class="keyword">from</span> gen</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        print(<span class="string">f"caught <span class="subst">&#123;exc&#125;</span>"</span>)</span><br><span class="line">    print(<span class="string">f"return val of yield-from:  <span class="subst">&#123;rv&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"all done"</span></span><br></pre></td></tr></table></figure>
<p>따라서 우리는 서브-코루틴을 마치 일반적인 함수(서브루틴)처럼 로직은 정비하였다.<br>
본론으로 돌아가 우리의 fetcher에서 부터 서브코루틴을 정비하자.<br>
우리는 <code>read</code>코루틴을 작성하고, 하나의 chunk를 받을 것이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(sock)</span>:</span></span><br><span class="line">    f = Future()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_readable</span><span class="params">()</span>:</span></span><br><span class="line">        f.set_result(sock.recv(<span class="number">4096</span>)) <span class="comment"># self.result로 받으면 등록된 콜백을 전부 순회하고 종료한다.</span></span><br><span class="line"></span><br><span class="line">    selector.register(socket.fileno(), EVENT_READ, on_readable)</span><br><span class="line">    chunk = <span class="keyword">yield</span> f <span class="comment"># EVENT_READ가 발생하면 onreadable을 이미 등록하고, 동작하면이 아니라 바로 Future 인스턴스를 돌려준다.</span></span><br><span class="line">    <span class="comment"># 해당 소켓은 논 블로킹 소켓으로 4kb이상 들어오면 그만큼 읽어내고 flush</span></span><br><span class="line">    <span class="comment"># 모든 약속들은 Future인스턴스에 의해 처리된다고 보면 된다.</span></span><br><span class="line">    selector.unregister(sock.fileno())</span><br><span class="line">    <span class="keyword">return</span> chunk <span class="comment"># chunk는 읽은 데이터가 아니라, 루틴에서 전달 받은 것.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_all</span><span class="params">(sock)</span>:</span></span><br><span class="line">    response = []</span><br><span class="line">    chunk = <span class="keyword">yield</span> <span class="keyword">from</span> read(sock) <span class="comment"># yield 1회 하고 종료 바로 돌아온다.</span></span><br><span class="line">    <span class="keyword">while</span> chunk: <span class="comment"># 루틴에서 전달 받은것이 유효한 동안.</span></span><br><span class="line">        response.append(chunk) <span class="comment">#</span></span><br><span class="line">        chunk = <span class="keyword">yield</span> <span class="keyword">from</span> read(sock)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b""</span>.join(response)</span><br><span class="line"></span><br><span class="line"><span class="comment"># reads = read_all(sock)</span></span><br><span class="line"><span class="comment"># reads.send(None) f를 돌려주고, 종료 chunk에는 값이 할당되지 않는다.</span></span><br><span class="line"><span class="comment"># 이후 넌블로킹 소켓에서 데이터를 읽으면 예약한 대로, 4kb 청크 데이터에 대한 Future에 예약된 콜백들을 실행하지만 별도 send를 추가로 진행해야 read가 마저 진행된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reads.send(True) read로 전달, read의 chunk에 처음으로 값이 맺힌다.</span></span><br><span class="line"><span class="comment"># 연달아 read는 1회 종료되고, unregi된다. read_all로 리턴하면서 종료한다.</span></span><br><span class="line"><span class="comment"># read_all의 chunk에 chunk를 리턴한다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Future_set_result를 통한 콜백 순회가 이루어 지고, 그러면 그 콜백의 마지막 요소가</span></span><br><span class="line"><span class="comment"># reads.send(True)로 다시 실행하면,</span></span><br><span class="line"><span class="comment"># 만약 그러다가 읽을 데이터가 이제 없다면, 소켓 selector타입아웃으로 처리해서, chunk를 False로 리턴하는 함수도 예약하면,</span></span><br><span class="line"><span class="comment"># 마지막에 read_all에 send(False)한 것은 b"".join(response)를 통해서 완전한 응답을 받을것이다.</span></span><br><span class="line"><span class="comment"># 요청이 들어온 것에 대한 하나의 처리가 종료되는 것.</span></span><br></pre></td></tr></table></figure>
<p><code>yield from read</code>는 2번의 send를 통해 종료되기 전까지 <code>read all</code>을 진행시키지 않는다.<br>
그리고 1회 실행에서 <code>read_all</code>이 정지되어 있는 동안, asyncio의 EVENTLOOP이 등록되어 있는게 계속 돌아간다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(self)</span>:</span></span><br><span class="line">        sock.send(request.encode(<span class="string">"ascii"</span>))</span><br><span class="line">        self.response = <span class="keyword">yield</span> <span class="keyword">from</span> read_all(sock)</span><br></pre></td></tr></table></figure>
<p>기적적이게도, Task class는 수정이 필요하지 않다.</p>
<p><code>Task(fetcher.fetch())</code><br>
<code>loop()</code></p>
<p><code>read</code>가 future을 yield할 때, task는 이것을 yield from 진술을 통한 연결에서 전달 받는다.<br>
정확하게 future이 fetch에서 직접적으로 yield되는 것처럼 되는 것처럼.<br>
loop가 future을 진행시키면, task는 그것을 결과를 fetch로 보낸다. 그리고 값은 read에서 돌려받는다.<br>
마치 정확히 task가 read를 조종하는 것처럼 보인다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">class name</th>
<th style="text-align:center">method</th>
<th style="text-align:center">return</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Task</td>
<td style="text-align:center">init(self, coro)</td>
<td style="text-align:center">self.coro = coro, f = Future(), f.set_result(None), self.step(f)</td>
</tr>
<tr>
<td style="text-align:center">Task</td>
<td style="text-align:center">step(self, future)</td>
<td style="text-align:center">next_future = self.coro.send(future.result), next_future.add_done_callback(self.step)</td>
</tr>
<tr>
<td style="text-align:center">Fetcher</td>
<td style="text-align:center">init(self, path)</td>
<td style="text-align:center">self.location = path</td>
</tr>
<tr>
<td style="text-align:center">Fetcher</td>
<td style="text-align:center">fetch(self)</td>
<td style="text-align:center">socket setup, socket.connect(path), f = Future, selector.register(socket, EVENT_WRITE, f.set_result(None)), yield f, selector.unregi(socket)</td>
</tr>
<tr>
<td style="text-align:center">Future</td>
<td style="text-align:center">init(self)</td>
<td style="text-align:center">self.result = None, self._callbacks = []</td>
</tr>
<tr>
<td style="text-align:center">Future</td>
<td style="text-align:center">add_done_callback(self, fn)</td>
<td style="text-align:center">self._callbacks.append(fn)</td>
</tr>
<tr>
<td style="text-align:center">Future</td>
<td style="text-align:center">set_result(self, result)</td>
<td style="text-align:center">self.result = result, for fn in _callbacks: fn(self)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">from</th>
<th style="text-align:left">name</th>
<th style="text-align:center">do</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Fetcher_instance</td>
<td style="text-align:left">Fetcher.init(self, path)</td>
<td style="text-align:center">fetcher = Fetcher(&quot;/353/&quot;)</td>
</tr>
<tr>
<td style="text-align:center">Task_instance</td>
<td style="text-align:left">Task(fetcher.fetch())</td>
<td style="text-align:center">task.coro = fetcher.fetch(), f = Future()…</td>
</tr>
<tr>
<td style="text-align:center">Future_instance</td>
<td style="text-align:left">Future.init(self)</td>
<td style="text-align:center">self.result = None, self._callbacks = []</td>
</tr>
<tr>
<td style="text-align:center">task</td>
<td style="text-align:left">Task(fetcher.fetch())</td>
<td style="text-align:center">…self.step(f)</td>
</tr>
<tr>
<td style="text-align:center">task</td>
<td style="text-align:left">step(f)</td>
<td style="text-align:center">next_future = self.coro.send(future.result#None)…</td>
</tr>
<tr>
<td style="text-align:center">fetcher</td>
<td style="text-align:left">send(None)</td>
<td style="text-align:center">yield new Future()</td>
</tr>
<tr>
<td style="text-align:center">task</td>
<td style="text-align:left">step(f)</td>
<td style="text-align:center">…new_future.add_done_callback(self.step)</td>
</tr>
<tr>
<td style="text-align:center">selector_EVENT_WRITE_Callback</td>
<td style="text-align:left">future.set_result(None)</td>
<td style="text-align:center">task.step(None)</td>
</tr>
<tr>
<td style="text-align:center">task</td>
<td style="text-align:left">step(f)</td>
<td style="text-align:center">self.coro.send(None)…</td>
</tr>
<tr>
<td style="text-align:center">fetcher</td>
<td style="text-align:left">send(None)</td>
<td style="text-align:center">unregister(socket), print(“connected”), raise StopIteration</td>
</tr>
<tr>
<td style="text-align:center">task</td>
<td style="text-align:left">step(f)</td>
<td style="text-align:center">… except StopIteration: return</td>
</tr>
</tbody>
</table>
<p>이것으로 1회 Path에 대한 소켓 연결이 활성화 되어 WRITE가 가능해진 상태가 되었음을 공지 받는다.</p>
<p>우리의 코루틴 구현을 좀 더 치밀하게 만들기 위해서, 하나를 수정한다.<br>
우리는 future이 socket이벤트를 기다릴때, <code>Fetcher.fetch</code>에서 현재 yield를 사용해서, future인스턴스를 리턴한다.<br>
하지만 <code>yield from</code>을 사용해서, 서브코루틴을 가르키도록 할 것이다.<br>
이것은 더욱 깔끔한 것이 될 것이다. 그러면 <code>yield from</code>을 사용하는 코루틴은 더이상 어떤 타입에 대해서 기다리는지 걱정할 필요가 없게 된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> self</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br></pre></td></tr></table></figure>
<p>이제 next(f)는 코루틴 함수가 되었고,<br>
<code>yield f</code> 를 <code>yield from f</code>로 교체하도록 한다.</p>
<p>기능상 동일하다. 진행중인 Task는 future을 <code>send</code>를 통해서 받고, 그리고 <code>future</code>이 EVENT_WRITE되고 나면, <code>yield from</code>의 2번째가 작동할 것이다.<br>
그렇다면, <code>yield from</code>을 사용하는 이점은 무엇인가?<br>
<code>yield</code>로 바로 돌려 받는 것과 <code>yield from</code>을 통해 서브코루틴을 가르키도록 하는 것은 무엇이 더 나은가?</p>
<p>메서드는 <code>caller</code>의 영향 없이 자유롭게 구현을 변환 할 수 있다.<br>
두 경우 모두 다, caller은 오직 <code>yield from</code>메서드만을 통해서 결과를 기다릴 수 있게 된다.</p>
<p>우리는 어떻게 <code>asyncio</code>가 두 세상을 동시에 가지는지 그려냈다.:<br>
동시성 I/O가 멀티쓰레드보다 더 효과적이고, callback보다 더 정교하다.<br>
물론 실제 asyncio는 우리의 밑그림 보다 더욱 정교하다.<br>
실제 프레임웤은 <code>zero-copy I\O</code>, <code>fair scheduling</code>, <code>exception handling</code>을 요구한다.</p>
<p>asyncio유저에게 코루틴을 활용해 코딩하는 것은 당신이 여기서 본 것 보다 훨씬 간단하다.<br>
우리는 첫번째 원칙부터 코루틴을 구현해 낸것이다. 그렇게 때문에 callbacks, tasks, futures등을 본 것이다.<br>
그리고 Non-blocking소켓까지 보았고, select를 호출했다.</p>
<blockquote>
<p>그러나 <code>asyncio</code>를 사용하면 위의 것들은 전혀 등장하지 않을 것이다.<br>
우리가 위에서 그렸듯이 아주 부드럽게 URL을 fetch할 수 있다.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(self, url)</span>:</span></span><br><span class="line">    response = <span class="keyword">yield</span> <span class="keyword">from</span> self.session.get(url)</span><br><span class="line">    <span class="comment">#session이 yield를 거쳐서 최종적으로 return 하는 것. send(something)은 session.get의 yield로 전달 된다.</span></span><br><span class="line">    body = <span class="keyword">yield</span> <span class="keyword">from</span> response.read()</span><br><span class="line">    <span class="comment"># Response.read가 yield하는 것이 계속 되고 종료되면 return 하는 것을 chunk로 누적시켜 return할 것이다.</span></span><br><span class="line">    <span class="keyword">return</span> body</span><br><span class="line">    <span class="comment"># 최종적으로 EVENT_READ등을 통한 콜백들이 순차적으로 예약되고 진행되면서 알아서 작동하고, 마지막에 return 될 것이다.</span></span><br></pre></td></tr></table></figure>
<p>이제 우리의 원래 목적인 async web crwaler를 asyncio를 통해서 구현하는 것으로 돌아간다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/post/async_coroutine_4/" data-id="ckkdb52hi002d1pqkdv9kuq3o" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/async_coroutine_3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/post/async_coroutine_3/" class="article-date">
  <time datetime="2019-06-19T09:11:02.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/post/async_coroutine_3/">비동기 코루틴 번역-3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="어떻게_제너레이터가_동작하는가"><a class="markdownIt-Anchor" href="#어떻게_제너레이터가_동작하는가"></a> 어떻게_제너레이터가_동작하는가</h2>
<p>제너레이터 이전에 어떻게 파이썬 루틴들이 동작하는지 알아봐야할 것이다.<br>
기본적으로 파이썬 함수가 서브루틴을 부를때, 서브루틴이 종료될 때까지, 컨트롤을 얻기 때문에, 블로킹이 일어난다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    bar()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>파이썬의 인터프리터는 Cpython을 기반으로 작동한다.<br>
파이썬 함수를 실행하는 <strong>C function</strong>은 달콤하게도, **<code>PyEval_EvalFrameEx</code>**라고 불려진다.</p>
<p>**<code>PyEval_EvalFrameEx</code>**는 파이썬 스텍프레임 오브젝트를 수용해서, 프레임의 Context안에서, 파이썬의 바이트코드를 평가한다.<br>
여기에 foo에 대한 바이트코드가 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">0 LOAD_GLOBAL</td>
<td style="text-align:left">0 (bar)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">3 CALL_FUNCTION</td>
<td style="text-align:left">0 (0 positional, 0 keywordpair)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">6 POP_TOP</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">7 LOAD_CONST</td>
<td style="text-align:left">0 (None)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">10 RETURN_VALUE</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>dis - Disassembler for Python bytecode<br>
해당 모듈은 CPython bytecode를 disassembling 함으로써 분석한다.</p>
</li>
<li>
<p>CPython 실행 디테일: 바이트코드는 CPython의 실행부에 대한 명세이다.<br>
2 0 load_global 0(len)<br>
맨 앞에 있는 것은 라인넘버이다.</p>
</li>
</ul>
<p><strong>foo</strong> Function은 bar을 그의 스텍에 로드하고, 부르고 있다.<br>
그리고 <strong>foo</strong>의 return value(기본적으로 None)을 자신의 스텍에서 pop한다.<br>
<strong>None</strong>을 자신의 스텍에 로드하고, 마찬가지로 <strong>None</strong>을 리턴한다.</p>
<p><strong>Py_EvalFrameEx</strong>가 <strong>CALL_FUNCTION</strong> 바이트코드를 만났을때,<br>
그것으로 새로운 파이썬 스텍프레임을 생성하고 recurse 한다.</p>
<p>파이썬의 스텍프레임이 기본적으로 힙에 존재한다는 사실을 아는 것은 매우 중요하다!<br>
기본 스텍이 조차도 OS의 메모리의 스텍세그먼트가 아니라 OS_heap &gt; private heap에 명시적으로 stack-segment를 이루고 있다!</p>
<p>그렇다면 명시적인 스텍세그먼트에 프레임으로 저장한다고 하면, 임의로 컨트롤 하기가 매우 쉬워지는 것이다.<br>
파이썬 인터프리터는 평범한 C프로그램이다. 그래서 스텍프레임 또한 일반적인 스텍프레임이다.<br>
그러나 파이썬 실행되는 파이썬의 스텍프레임은 힙에 있다. 다른 놀라움 사이에서,<br>
그것은 파이썬 스텍프레임이 그것을 존재하게한 function call stackframe보다 오래 살 수 있다는 것을 의미한다.<br>
이것을 상호작용적 측면에서 보기 위해서, 현재의 프레임을 bar의 내부에서 저장해라</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">frame = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    bar()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> frame</span><br><span class="line">    frame = inspect.currentframe()</span><br><span class="line"></span><br><span class="line">foo() <span class="comment"># this frame was executing the code for 'bar'.</span></span><br><span class="line"></span><br><span class="line">frame.f_code.co_name</span><br><span class="line"><span class="comment"># 'bar'</span></span><br><span class="line"></span><br><span class="line">caller_frame = frame.f_back <span class="comment"># its back pointer refers to the frame for 'foo'.</span></span><br><span class="line"></span><br><span class="line">caller_frame.f_code.co_name</span><br><span class="line"><span class="comment">#'foo'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>foo()</code>를 실행하면 순차적으로 벌어지는 일</p>
<ol>
<li>PyEval_EvalFrameEx in foo func Executes</li>
<li>evaluate self.f_code</li>
<li>made CodeByteCode of foo</li>
<li>recursion occurs
<ol>
<li>PyEval_EvalFrameEx in bar func Executes…</li>
<li>eval self.f_code</li>
</ol>
</li>
</ol>
</li>
<li>
<p>PyObject 설명</p>
<ul>
<li>PyEval_FrameObject:
<ul>
<li>C구조의 객체, frameObject를 설명하기 위한 객체이다.<br>
이 타입의 필드들은 언제든 바뀔 수 있도록 설계되어 있다.</li>
</ul>
</li>
<li>PyEval_EvalFrame(PyFrameObject *f):<br>
new Reference, 실행부에 있는 프레임을 평가한다.<br>
후위에 대한 호환성을 유지하기 위해 PyEval_EvalFrameEx의 축소화된 인터페이스를 갖고 있다.</li>
<li>PyEval_EvalFrameEx(PyFrameObject *f,int throwflag):<br>
이것은 어떠한 가공도 덧붙여 지지 않은 파이썬 해석부(interpretation)의 메인 함수이다.<br>
이것은 말 그대로 2000lines만큼 길고, 대상 바이트코드와 실행-Calls를 필요한 만큼 해석하며<br>
코드오브젝트와 연관된 execution-프레임인 <strong>f</strong> 는 실행된다.</li>
</ul>
</li>
</ul>
<p>이제 놀라운 효과를 위해서 같은 building blocks(codeObj, stackObj)를 사용하는 무대는 파이썬 제너레이터를 위해 준비가 되었다.</p>
<p>이것이 제너레이터 함수이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_fn</span><span class="params">()</span>:</span></span><br><span class="line">    result = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">'result of yield: &#123;&#125;'</span>.format(result))</span><br><span class="line">    result2 = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    print(<span class="string">'result of 2nd yield: &#123;&#125;'</span>.format(result2))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line"></span><br><span class="line">generator_bit = <span class="number">1</span> &lt;&lt; <span class="number">5</span> <span class="comment"># 00100000</span></span><br><span class="line">bool(gen_fn.__code__.co_flags &amp; generator_bit)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>파이썬이 gen_fn을 바이트코드로 변환할 때, 그것은 <strong>yield</strong>문을 발견하고<br>
<strong>gen_fn</strong>이 일반적인 함수가 아닌 제너레이터 함수라는 것을 안다.<br>
해당 frameobject에 flag를 세워서 이 사실을 기억하도록 한다.<br>
초기화 이후 <code>next()</code>같은 것으로 첫번 째 콜을 할 때, 플래그를 인식해서, 힙의 어딘가에<br>
기존 서브루틴이 맺히는 곳이 아닌 다른 힙의 어느 공간에 생성.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gen = gen_fn()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">type(gen)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>&lt;class 'generator'&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>네가 제너레이터 함수를 호출할 때, 파이썬은 그때 그것의 제너레이터 플레그를 알아볼 수 있다.<br>
그리고 실제로 함수를 실행하는게 아니라 대신에, 제너레이터를 생성한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">gen.gi_code.co_name</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>'gen_fn'</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p><code>gen_fn</code>를 호출함으로써 생기는 모든 제너레이터 네임은 이 모두 이 코드를 가르킨다.<br>
하지만 이들 모두는, 각각 자신의 스텍프레임을 갖고 있다.<br>
이 스텍프레임은 파이썬의 스텍프레임에 쌓이는게 아니라, 독특하게도,<br>
파이썬의 힙에서 언젠간 사용될 것을 기다리며 저장된다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">object Attr</th>
<th style="text-align:center">value Object</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PyGenObject.gi_frame</td>
<td style="text-align:center">:PyFrameObject</td>
</tr>
<tr>
<td style="text-align:left">PyGenObject.gi_code</td>
<td style="text-align:center">:PyCodeObject</td>
</tr>
</tbody>
</table>
<p>PyGenObj madeOf,</p>
<table>
<thead>
<tr>
<th style="text-align:left">object</th>
<th style="text-align:left">attr</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PyFrameObject</td>
<td style="text-align:left">f_lasti: 마지막 인스트럭션 포인터(서브루틴과 구별)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">f_locals: 스텍-지역변수</td>
</tr>
<tr>
<td style="text-align:left">PyCodeObject</td>
<td style="text-align:left">gen_fn’s bytecode</td>
</tr>
</tbody>
</table>
<p>프레임에는 <strong>Last instruction</strong>이라는 포인터가 있고, 마지막에 실행된 지침을 보관하고 있다.<br>
최초 초기화 시에 last instruction poiter은 -1이다.<br>
이는 제너레이터가 시작되지 않았음을 의미한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gen.gi_frame.f_lasti</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>우리가 <strong>send</strong>를 호출 할떄, 제너레이터는 그의 첫번째 yield를 만나고 멈춘다.<br>
send에 대한 리턴 값은 1, 왜냐하면 그것이 gen이 yield호출에게 전달한 것이기 때문이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gen.send(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>이제 제너레이터의 인스트럭션 포인터는 시작에서부터 3 bytecodes 만큼 떨어졌다.<br>
56바이트로 컴파일된 바이트코드 실행부 중에서 그만큼 진행한 것이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gen.gi_frame.f_lasti</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br><span class="line">len(gen.gi_code.co_code)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">56</span></span><br></pre></td></tr></table></figure>
<p>제너레이터는 언제든 계속 될 수 있다. 왜냐하면 기존의 서브루틴들이 맺히는 부분에 존재하지 않기 때문이다.<br>
이것이 콜트리(Call hierarchy)에 있는 위치는 고정된게 아니다.<br>
그리고 이것은 FIFO 의 실행 순서를 따르지 않아도 된다.<br>
이건 자유롭고, 구름같이 떠다니는 정도의 자유이다.</p>
<p>우리는 제너레이터에게 'hello’라고 value를 send할 수 있다.<br>
그리고 그것은 yield표현에 대한 결과가 될 것이다.<br>
그리고 제너레이터는 2를 yield할 때까지 수행된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res = gen.send(<span class="string">"hello"</span>)</span><br><span class="line">res</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">gen.gi_frame.f_locals</span><br><span class="line"><span class="comment"># &#123;"result": "hello"&#125;</span></span><br></pre></td></tr></table></figure>
<p>지금은 <code>gen</code>이라는 네임에 묶인 하나의 제너레이터 스텍이지만,<br>
다른 것으로 또 할당을 하면, 그것의 고유의 스텍프레임과, 지역변수를 가지고 있을 것이다.</p>
<p>우리가 다시 <code>send</code>를 호출하면, 제너레이터 코루틴은 그것의 두번째 <code>yield</code>를 루틴 컨텍스트로 돌려줄 것이고<br>
그리고 그것을 <code>StopIteration</code> 예외를 발생시켜서, 그것이 종료되었음을 알린다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gen.send(<span class="string">"goodbye"</span>)</span><br><span class="line"><span class="comment"># generator마지막에 리턴하는 것이 'done' 문자열.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Traceback (most recent call last) :</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">StopIteration: done</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/post/async_coroutine_3/" data-id="ckkdb52hk002g1pqk0r4c94qc" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/virtual_memory_with_malloc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/post/virtual_memory_with_malloc/" class="article-date">
  <time datetime="2019-06-19T09:05:23.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/post/virtual_memory_with_malloc/">파이썬의 가상 메모리</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>
<h3 id="heap을-구현한및-연결점인-c의-malloc이-느리기-때문에-heap이-느리다"><a class="markdownIt-Anchor" href="#heap을-구현한및-연결점인-c의-malloc이-느리기-때문에-heap이-느리다"></a> Heap을 구현한(및 연결점인) C의 malloc()이 느리기 때문에, HEAP이 느리다</h3>
</li>
</ul>
<p>Heap 의 자료구조는 헤더를 통해 다음 bytesArray를 연결하는 double Link list</p>
<ol>
<li>처음에는 단순하게 스텍처럼 쌓이다가 일부 메모리가 해제되어,</li>
<li>새로운 크기의 메모리를 할당하려고 할때,</li>
<li>데이터가 사라진 남아있는 헤더들이 유지하고 있는 사이즈와 맞는 요소를 찾아 linked List를 순회하며 찾는다.</li>
</ol>
<p>이로 인해 생기는 현상을,<br>
<strong>Memory Fragmentation(메모리 단편화)</strong> 라고 한다.</p>
<p>Heap에 배치된 총 메모리에 비해 남은 메모리가 있어도,<br>
맞는 크기가 없으면, Scaleup 하는 것 외에는 방법이 없다.</p>
<p>파이썬등 인터프리터언어들의 엔진은 라인별로 실행하는 특성상 대부분 동적할당 혹은 부분적으로에 의해 일이 잦은데,<br>
프로세스를 실행하는 때에, Heap의 정크메모리(많은 양의)를 할당 받아, 그 커다란 메모리를 엔진이 직접 관리하면서,</p>
<ul>
<li>CPU-Memory-HeapSegement
<ol>
<li>python requires Junk Heap Memeory space.</li>
<li>python call it <strong>Private Heap</strong>.</li>
</ol>
<ul>
<li>python.exe’s private heap
<ul>
<li>Data Segment</li>
<li>Code Segment</li>
<li>Stack Segment</li>
<li>Heap Segment</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>역할을 나눠 직접 모니터링 하면서 관리한다. 그래서 c의 malloc()을 이어받아, 기능적으로 힙을 관리하는 자체 메서드를 생성했다.</p>
<hr>
<h2 id="virtual-memory"><a class="markdownIt-Anchor" href="#virtual-memory"></a> virtual memory</h2>
<ol>
<li>OS: when Process starts?</li>
<li>give mapped page-Table to Process</li>
</ol>
<blockquote>
<p>sytex of pageElem ({page#num:[] , frame#num:[], valid bit:[]})</p>
</blockquote>
<ol start="3">
<li>4gb정도의 크기를 가상 메모리로 할당하고, 실제로 프로레스를 시작하는데 필요한 만큼은 바로 Page Fault를 일으킨 후 실제 메모리와 매칭된다.</li>
<li>pageFault(validbit is 0) -&gt; map to real ram addr -&gt; valid bit up to 1</li>
</ol>
<p>preparing: 첫 주소도 알려주고 4기가 라고 알려주지만, 실제 바로 필요한 메모리 만큼은 실제로 연결 해준다.</p>
<p>pc가 다음 명령을 검토 -&gt; 페이지 테이블 첫 주소로 이동 -&gt; 매핑된 프레임주소 -&gt; 실제 메모리에 저장 -&gt; vaild bit = 1(실제 할당됨)<br>
매핑되는 프레임주소(MMU 하드웨어로서 페이지를 프레임으로 변환해줌)</p>
<p>관건은 코드세그먼트에서 알고있는 메모리주소로 이동하면 그 메모리 주소는 페이지 테이블에 실제 메모리 주소가 매핑되어 있다는 것.<br>
Logical메모리인 페이지 테이블에 Validbit가 -이면 실제 매핑된 메모리주소에 없다는 것임.</p>
<p>최초 프로그램 실행(가짜메모리인 테이블만 있다) -&gt; valid bit 가 0이다.(읽은 적이 없으니까 최초시작이니까) -&gt; 하드디스크 -&gt; 실제주소로 가져오고 저장 -&gt; 페이지테이블로 돌아온다 -&gt; Valid bit =1 .-&gt; 프로그램 카운터가 해당 실제 지침을 가지고 돌아… -&gt; 지침레지스터에 전달</p>
<p>프로그램에서 이전에 실행했던 컴포넌트는 이미 메모리에 있어서 최초 프로그램내의 컴포넌트를 실행할 때보다 빠르게 반응하는 것에 대한 실재.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/post/virtual_memory_with_malloc/" data-id="ckkdb52i000311pqkwnvepwgm" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/module/inspect" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/module/inspect/" class="article-date">
  <time datetime="2019-06-19T07:37:06.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/module/inspect/">Inspect 모듈 파헤치기</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="index"><a class="markdownIt-Anchor" href="#index"></a> Index</h2>
<blockquote>
<ol>
<li><a href="#%EA%B3%B5%EC%8B%9D%EB%AC%B8%EC%84%9C%EC%A0%95%EC%9D%98">공식문서 정의</a>
<ol>
<li>[메서드 리스트][i1-1]</li>
</ol>
</li>
<li><a href="#class_Type%EC%97%90_%EB%8C%80%ED%95%9C_inspect%EC%9D%98_%EB%B0%B1%EC%97%85_%EC%86%8D%EC%84%B1_%EB%B0%8F_%EB%A9%94%EC%84%9C%EB%93%9C">Type class별 inpect지원 속성, 메서드</a>
<ol>
<li><a href="#traceback_module">Traceback module</a></li>
<li><a href="#frame_module">Frame module</a>
<ol>
<li><a href="#frame_object%ED%9A%8D%EB%93%9D%ED%95%98%EA%B8%B0">Frame object획득하기</a></li>
</ol>
</li>
<li><a href="#code_module">Code module</a>
<ol>
<li><a href="#dis%EB%AA%A8%EB%93%88%EC%9D%84_%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC_%EA%B0%9D%EC%B2%B4_%EB%B6%84%EC%84%9D">dis모듈로 코드 해석</a></li>
</ol>
</li>
<li><a href="#function_module">Function module</a></li>
<li><a href="#generator_module">Generator module</a></li>
<li><a href="#coroutine_module">Coroutine module</a></li>
</ol>
</li>
<li><a href="#%EC%9C%A0%EC%9A%A9%ED%95%9C_%ED%99%9C%EC%9A%A9">유용한 활용</a>
<ol>
<li><a href="#%EC%A7%80%EC%9B%90_%ED%83%80%EC%9E%85%EC%9D%98_%EC%86%8C%EC%8A%A4_%EB%B0%9B%EC%95%84%EC%98%A4%EA%B8%B0">지원 타입의 source가져오기</a></li>
</ol>
</li>
<li><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li>
</ol>
</blockquote>
<h2 id="공식문서_정의"><a class="markdownIt-Anchor" href="#공식문서_정의"></a> 공식문서_정의</h2>
<p>인스펙트 모듈은 유효한 모듈, 클래스, 메서드, 함수, 트레이스백, 프레임 객체, 코드객체에 대해 정보를 가질 수 있는 유용한 함수들을 제공한다.</p>
<p>4가지 종류의 주요 서비스</p>
<ul>
<li>타입체킹</li>
<li>소스코드 획득</li>
<li>클래스와 함수 측정</li>
<li>인터프리터 스텍 확인</li>
</ul>
<h2 id="class_type에_대한_inspect_백업"><a class="markdownIt-Anchor" href="#class_type에_대한_inspect_백업"></a> class_Type에_대한_Inspect_백업</h2>
<h3 id="traceback_module"><a class="markdownIt-Anchor" href="#traceback_module"></a> Traceback_module</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Attribute</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">traceback</td>
<td style="text-align:left">tb_frame</td>
<td style="text-align:left">해당 레벨의 프레임객체</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">tb_lasti</td>
<td style="text-align:left">바이트코드에서 마지막 시도된 지침의 인덱스</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">tb_lineno</td>
<td style="text-align:left">소스코드상 현재 라인 넘버</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">tb_next</td>
<td style="text-align:left">다음 내부의 트레이스백 객체</td>
</tr>
</tbody>
</table>
<h3 id="frame_module"><a class="markdownIt-Anchor" href="#frame_module"></a> Frame_module</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Attribute</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">frame</td>
<td style="text-align:left">f_back</td>
<td style="text-align:left">다음 외부 프레임 객체(이 프레임의 호출자)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">f_builtins</td>
<td style="text-align:left">해당 프레임에서 보여진 builtin 네임스페이스</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">f_code</td>
<td style="text-align:left">이 프레임에서 실행된 코드객체</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">f_globals</td>
<td style="text-align:left">이 프레임에서 보여진 Global 네임스페이스</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">f_lasti</td>
<td style="text-align:left">바이트코드에서 마지막으로 시도된 지침의 인덱스</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">f_lineno</td>
<td style="text-align:left">소스코드상 현재 라인 넘버</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">f_locals</td>
<td style="text-align:left">현재 프레임에서 보여진 Local 네임스페이스</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">f_trace</td>
<td style="text-align:left">이 프레임의 함수를 추적, 없으면 <code>None</code></td>
</tr>
</tbody>
</table>
<h4 id="frame_object획득하기"><a class="markdownIt-Anchor" href="#frame_object획득하기"></a> Frame_object획득하기</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_stackframe_without_leak</span><span class="params">()</span>:</span></span><br><span class="line">    frame_start = inspect.currentframe()</span><br><span class="line">    do_somethong = <span class="keyword">lambda</span> : <span class="keyword">pass</span></span><br><span class="line">    do_something()</span><br><span class="line">    frame_end = inspect.currentframe()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(frame_start.f_locals)</span><br><span class="line">        print(frame_end.f_locals)</span><br><span class="line">        print(frame_start <span class="keyword">is</span> frame_end) <span class="comment"># True</span></span><br><span class="line">        <span class="comment"># do something with the frame</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">del</span> frame_start, frame_end</span><br></pre></td></tr></table></figure>
<h3 id="code_module"><a class="markdownIt-Anchor" href="#code_module"></a> Code_module</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Attribute</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">code</td>
<td style="text-align:left">co_argcount</td>
<td style="text-align:left"><code>*args</code>의 수량</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_code</td>
<td style="text-align:left">날것으로 컴파일된 바이트코드</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_cellvars</td>
<td style="text-align:left">튜플로 된 셀 객체의 이름들</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_consts</td>
<td style="text-align:left">바이트코드에서 사용된 상수로 구성된 튜플</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_filename</td>
<td style="text-align:left">해당 코드 객체가 생성된 파일명</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_firstlineno</td>
<td style="text-align:left">소스코드에서 첫번쨰 라인의 수</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_flags</td>
<td style="text-align:left">생략(봐도 모르겠다.)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_inotab</td>
<td style="text-align:left">생략(불필요)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_freevars</td>
<td style="text-align:left">free Variables의 이름들로 구성된 튜플</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_kwonlyargcount</td>
<td style="text-align:left">키워드기반 매개변수의 수</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_name</td>
<td style="text-align:left">해당 코드객체가 정의한 것의 이름</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_names</td>
<td style="text-align:left">지역변수의 이름들로 구성된 튜플</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_nlocals</td>
<td style="text-align:left">지역 변수의 이름들의 숫자</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_stacksize</td>
<td style="text-align:left">가상머신 스텍 공간이 요구됨</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">co_varnames</td>
<td style="text-align:left">매개변수와 지역변수의 이름들로 구성된 튜플</td>
</tr>
</tbody>
</table>
<h4 id="dis모듈을_사용하여_객체_분석"><a class="markdownIt-Anchor" href="#dis모듈을_사용하여_객체_분석"></a> dis모듈을_사용하여_객체_분석</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_func</span><span class="params">(a,b=<span class="number">3</span>,msg=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; sample_func(2,msg="expected!")</span></span><br><span class="line"><span class="string">    (6, "expected! 6")</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> (a*b, <span class="string">f"<span class="subst">&#123;msg&#125;</span> <span class="subst">&#123;a*b&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">pprint.pprint((dis.code_info(sample)))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">(</span></span><br><span class="line"><span class="string">    'Name: sample\n'</span></span><br><span class="line"><span class="string">    'Filename: &lt;ipython-input...&gt;\n'</span></span><br><span class="line"><span class="string">    'Argument count: 3\n'</span></span><br><span class="line"><span class="string">    'nKw-only arguments: 0\n'</span></span><br><span class="line"><span class="string">    'Number of locals: 3\n'</span></span><br><span class="line"><span class="string">    'Stack size: 5\n'</span></span><br><span class="line"><span class="string">    'Flags: OPTIMIZED, NEWLOCALS, NOFREE\n'</span></span><br><span class="line"><span class="string">    'Contants: \n'</span></span><br><span class="line"><span class="string">    '   0: \'\\n    &gt;&gt;&gt; sample_func(2,msg="expected!")\\n    (6, "expected! '</span></span><br><span class="line"><span class="string">    6")\\n    \'\n'</span></span><br><span class="line"><span class="string">       1: ' '\n"</span></span><br><span class="line"><span class="string">    Variable names:\n'</span></span><br><span class="line"><span class="string">       0: a\n'</span></span><br><span class="line"><span class="string">       1: b\n'</span></span><br><span class="line"><span class="string">    '   2: msg')</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="function_module"><a class="markdownIt-Anchor" href="#function_module"></a> Function_module</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Attribute</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">function</td>
<td style="text-align:left"><strong>doc</strong></td>
<td style="text-align:left">문서화 문자</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><strong>func</strong></td>
<td style="text-align:left">매서드의 실행부가 포함된 함수객체</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><strong>self</strong></td>
<td style="text-align:left">instance to which method is bound or <code>None</code></td>
</tr>
</tbody>
</table>
<h3 id="generator_module"><a class="markdownIt-Anchor" href="#generator_module"></a> Generator_module</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Attribute</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">generator</td>
<td style="text-align:left">gi_frame</td>
<td style="text-align:left">frame</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">gi_running</td>
<td style="text-align:left">제너레이터가 실행 중 인가?</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">gi_code</td>
<td style="text-align:left">code</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">gi_yieldfrom</td>
<td style="text-align:left"><code>yield from</code>에서부터 생산되는 객체, or <code>None</code></td>
</tr>
</tbody>
</table>
<h3 id="coroutine_module"><a class="markdownIt-Anchor" href="#coroutine_module"></a> Coroutine_module</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Attribute</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">coroutine</td>
<td style="text-align:left">cr_await</td>
<td style="text-align:left">대기중인 객체, or <code>None</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">cr_frame</td>
<td style="text-align:left">frame</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">cr_running</td>
<td style="text-align:left">코루틴이 진행 중인가?</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">cr_code</td>
<td style="text-align:left">code</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">cr_origin</td>
<td style="text-align:left">코루틴이 생성된 곳, or <code>None</code></td>
</tr>
</tbody>
</table>
<p><a href="#index">index</a></p>
<h2 id="유용한_활용"><a class="markdownIt-Anchor" href="#유용한_활용"></a> 유용한_활용</h2>
<h3 id="지원_타입의_소스받아오기"><a class="markdownIt-Anchor" href="#지원_타입의_소스받아오기"></a> 지원_타입의_소스받아오기</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'sample!'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCode</span><span class="params">(any_obj)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; inspect.getsource(sample)</span></span><br><span class="line"><span class="string">    "def sample():\n    return 'sample!'\n"</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> inspect.getsource(any_obj)</span><br></pre></td></tr></table></figure>
<h3 id="python_code_tracing"><a class="markdownIt-Anchor" href="#python_code_tracing"></a> python_code_tracing</h3>
<p>inspect자원을 래핑하여 활용하는 기법을 보자</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traceit</span><span class="params">(frame, event, arg)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">"line"</span>:</span><br><span class="line">        lineno = frame.f_lineno</span><br><span class="line">        print(<span class="string">"line"</span>, lineno)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> traceit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"In main"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(i, i*<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"Done."</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">sys.settrace(traceit)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<ul>
<li>sys.settrace()에 설정한 함수에 frame, event, arg를 넣고 해당 함수객체를 반환한다.</li>
<li></li>
</ul>
<h2 id="예시_크롤링_동작_코드"><a class="markdownIt-Anchor" href="#예시_크롤링_동작_코드"></a> 예시_크롤링_동작_코드</h2>
<h2 id="마치며"><a class="markdownIt-Anchor" href="#마치며"></a> 마치며</h2>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/module/inspect/" data-id="ckkdb52h7001y1pqko4tqspuv" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-module/">python module</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 이전</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">다음 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/custom-module/">custom module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fabric/">fabric</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/functional-programming/">functional programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-deploy/">hexo-deploy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pipenv/">pipenv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgresql/">postgresql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-module/">python module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-post/">python post</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/testing/">testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travel-note/">travel_note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tutorial/">tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그 클라우드</h3>
    <div class="widget tagcloud">
      <a href="/tags/c/" style="font-size: 11.43px;">c</a> <a href="/tags/custom-module/" style="font-size: 12.86px;">custom module</a> <a href="/tags/django/" style="font-size: 14.29px;">django</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/fabric/" style="font-size: 10px;">fabric</a> <a href="/tags/functional-programming/" style="font-size: 11.43px;">functional programming</a> <a href="/tags/hexo-deploy/" style="font-size: 10px;">hexo-deploy</a> <a href="/tags/http/" style="font-size: 11.43px;">http</a> <a href="/tags/linux/" style="font-size: 15.71px;">linux</a> <a href="/tags/network/" style="font-size: 11.43px;">network</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/pipenv/" style="font-size: 10px;">pipenv</a> <a href="/tags/postgresql/" style="font-size: 10px;">postgresql</a> <a href="/tags/project/" style="font-size: 10px;">project</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/python-module/" style="font-size: 17.14px;">python module</a> <a href="/tags/python-post/" style="font-size: 18.57px;">python post</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/testing/" style="font-size: 10px;">testing</a> <a href="/tags/travel-note/" style="font-size: 10px;">travel_note</a> <a href="/tags/tutorial/" style="font-size: 10px;">tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">아카이브</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">1월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">9월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">8월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">7월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">6월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">5월 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">최근 포스트</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/26/fastcamp/my_post/">test_post</a>
          </li>
        
          <li>
            <a href="/2019/09/17/http/2_http_sementics/">http_1.0_sementics</a>
          </li>
        
          <li>
            <a href="/2019/09/09/project/travel_note/">travel_note 서비스 고찰</a>
          </li>
        
          <li>
            <a href="/2019/09/06/http/1_http_1.0_basic_four_feature/">http/1.0의 신택스: 기본이 되는 네가지 요소</a>
          </li>
        
          <li>
            <a href="/2019/09/05/python/post/async_coroutine_5/">비동기 코루틴 번역-5-End</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 junehan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>