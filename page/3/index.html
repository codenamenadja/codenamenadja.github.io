<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Junehan&#39;s workbook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="with python and javascript, could be some descriptions or workflow writtens for project">
<meta name="keywords" content="python django">
<meta property="og:type" content="website">
<meta property="og:title" content="Junehan&#39;s workbook">
<meta property="og:url" content="https://codenamenadja.github.io/page/3/index.html">
<meta property="og:site_name" content="Junehan&#39;s workbook">
<meta property="og:description" content="with python and javascript, could be some descriptions or workflow writtens for project">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Junehan&#39;s workbook">
<meta name="twitter:description" content="with python and javascript, could be some descriptions or workflow writtens for project">
  
    <link rel="alternate" href="/atom.xml" title="Junehan&#39;s workbook" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junehan&#39;s workbook</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">work flow and descriptions</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="검색"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://codenamenadja.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-python/module/wraps" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/module/wraps/" class="article-date">
  <time datetime="2019-06-19T10:35:43.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/module/wraps/">functools의 wraps 사용하기</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>INDEX</strong></p>
<p><a href="#1_%EA%B3%B5%EC%8B%9D%EB%AC%B8%EC%84%9C_%EC%A0%95%EC%9D%98">1. 공식문서 정의</a></p>
<h2 id="1_공식문서_정의"><a class="markdownIt-Anchor" href="#1_공식문서_정의"></a> 1_공식문서_정의</h2>
<h3 id="functoolswrapswrapped-assignedwrapper_assignments-updatedwrapper_updates"><a class="markdownIt-Anchor" href="#functoolswrapswrapped-assignedwrapper_assignments-updatedwrapper_updates"></a> <code>functools.wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)</code></h3>
<ul>
<li>
<p>이것은 <code>update_wrapper()</code>를 함수 데코레이터로서 호출하는 편리한 함수이다.</p>
</li>
<li>
<p>wrapper함수를 정의할 때, 이것은 아래와 동일하다.</p>
</li>
<li>
<p><code>partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)</code></p>
</li>
<li>
<p>예를 들어,</p>
   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Calling decorated func'</span>)</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@my_decorator</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""DocString"""</span></span><br><span class="line">        print(<span class="string">"Called example function"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example()</span><br><span class="line">Calling decorated func</span><br><span class="line">Called example function</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.__doc__</span><br><span class="line"><span class="string">'DocString'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.__name__</span><br><span class="line"><span class="string">'example'</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/module/wraps/" data-id="ckkdb52hb00231pqka3n32zym" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-module/">python module</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-functional_programming/python/functional_programming_howto" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/functional_programming/python/functional_programming_howto/" class="article-date">
  <time datetime="2019-06-19T09:57:26.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/functional_programming/python/functional_programming_howto/">functional programming howto 번역</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="intoduction"><a class="markdownIt-Anchor" href="#intoduction"></a> Intoduction</h2>
<ul>
<li>대부분의 연어는 절차적이다
<ul>
<li>프로그램은 인스트럭션의 리스트이다. 그 지침들은 컴퓨터에게 프로그램의 인풋으로 부터 무얼 해야할 지에 대해서 알려준다.</li>
<li>C, pascal, Unix셸 마저 절차적인 언어이다.</li>
</ul>
</li>
<li>선언형 언어에서는,
<ul>
<li>너는 풀려져야 할 문제에 대한, 특질을 기술한다. 그리고 언어의 실행 및 구현은 컴퓨터적으로 어떻게 효율성을 수행해야 할지 알려준다.</li>
</ul>
</li>
<li>객체지향프로그램은 객체의 콜렉션을 다룬다리
<ul>
<li>객체는 내부적인 상태를 가지고 있고, 그것을 쿼리하거나, 내부적인 상태를 수정하는 메서드를 지니고 있다.</li>
<li>Smalltalk와 java는 객체지향 언어이다.</li>
<li>C++과 파이썬은 객체지향을 지원하는 언어이다. 그러나 객체지향을 강요하진 않는다.</li>
</ul>
</li>
<li>함수형 프로그램은 문제를 functions의 조합으로 분해한다.
<ul>
<li>함수들은 인풋만을 받고, 아웃풋을 내놓는다.</li>
<li>내부적인 상태가 인풋에 대응하는 아웃풋에 영향을 주지 않는다.</li>
<li>잘알려진 함수형 언어는 MLfamily와(ML,OCaml, 그리고 다양한 것들) Haskell이 있다.</li>
</ul>
</li>
</ul>
<p>(중략)<br>
함수형 프로그래밍은 객체지향의 반대 쪽으로 고려될 수 있다. 객체들은 내부적인 상태를 캡슐하고 있고, 그것은 메서드의 컬렉션을 통해서 내부적인 상태를 조정한다.<br>
그리고 프로그램이 상태를 변화시키기 위한 적절한 세트를 지니고 있다.<br>
함수형 프로그래밍은 상태의 변화를 최대한 피하려고 한다, 그리고 functions사이에서 데이터의 흐름을 다루려고 한다.<br>
파이썬에서는 이 두 가지 접근법을 조합해서, 객체를 표현하는 인스턴스를 리턴할 수 있다.</p>
<p>함수형 디자인은, 그 밑에서 일하기 에는, 이상한 강제로 보일 수 있다. 왜 객체는 사이드 이펙트를 피해야만 하는가?<br>
함수현 언어에는 이론적이고 실용적인 이점이 있다.</p>
<ol>
<li>형식으로 입증가능</li>
<li>모듈성</li>
<li>조합성</li>
<li>디버그와 테스팅의 편리함<br>
(중략)</li>
</ol>
<hr>
<h2 id="iterators"><a class="markdownIt-Anchor" href="#iterators"></a> iterators</h2>
<p>iterators는 파이썬의 함수형 스타일의 중요한 기초이다.</p>
<p>iterator은 데이터의 스트림을 대표하는 객체이다.<br>
이 객체는 한번에 하나의 데이터만 리턴한다.<br>
파이썬 이터레이터는 <code>__next__()</code>라는 메서드를 지원해야한다. 그것은 어떤 매개변수를 받지 않고, 스트림의 다음 요소만을 반환한다.<br>
만약 다음요소가 없다면, 그것은 <code>StopIteration</code>예외를 발생시킨다.<br>
iterator은 한정되야할 필요는 없다. 이터레이터가 무한한 스트림의 데이터를 생성하는 것은 합리적인 것이다.</p>
<p>빌트인 <code>iter()</code>함수는 그 aribitary한 객체를 받아서, 그 객체의 컨텐츠나 요소들을 반환하는  <strong>iterator</strong>을 반환하려고 한다.<br>
만약 객체가 <strong>iteration</strong>을 지원하지 않는다면, <code>TypeError</code>을 Raise한다.<br>
몇몇 파이썬 빌트인 데이터 타입은 iteration을 지원한다. 가장 흔한 것은 lists와 dictionary들이다.<br>
객체는 <strong>iterable</strong>하다고 불릴 수 있다, 만약 거기서 <strong>iterator</strong>을 얻을 수 있다면.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(L)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it  <span class="comment">#doctest: +ELLIPSIS</span></span><br><span class="line">&lt;...iterator object at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it.__next__()  <span class="comment"># same as next(it)</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>파이썬은 <strong>iterable objects</strong>를 다양한 컨텍스트에서 예상한다. 가장 중요한 개체는 <code>for</code>진술이다.<br>
<code>for X in Y</code> 진술에서, <strong>Y</strong>는 이터레이터거나, <code>iter()</code>가 <strong>iterator</strong>을 생성할 수 있는 것이다.</p>
<p>아래 두 진술은 동일하다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> iter(obj):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>이터레이터는 <u>list, tuple등으로 물질화 될 수 있다.</u> <code>list() tuple()</code>  constructor함수를 사용함 으로써.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iterator = iter(L)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = tuple(iterator)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Sequence unpacking</strong>은 이터레이터를 지원한다.<br>
만약 이터레이터가 N개의 엘레먼트를 반환할 것을 네가 알고 있으면, N-tuple로 Unpack할 수 있다.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iterator = iter(L)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>for X in somelist</code>는 물질화된 것이고<br>
<code>for X in iterator</code>은 그렇지 않은 것이다.</p>
<ul>
<li>갯수가 정말 작다면, 혹은 단계적으로 찾아가서 특정조건까지 Search하는 경우가 아니라면 materialed한 Iterator을 사용하는 것이 더 바람직 할 수 있으나,</li>
<li><code>max() min()</code></li>
<li><code>if X in iterator</code></li>
<li>등의 경우에 무엇이 효과적인지 잘 알고 있을 것이다.</li>
</ul>
</blockquote>
<blockquote>
<p>파이썬의 리스트는 지역성이 제한적으로 성립되는 value의 모임이 아닌, reference들의 모임이기 때문에.<br>
offset만큼 정확히 이동하지도 않고, 다소 애매할 수 있는 존재이다.</p>
<p>만약 list의 N 번쨰 요소가 이미 메모리에서 잡아 놓았던 값이라면, 그 N번쨰 방에는 생성된 값이 지역성과 무관하게 기존에 잡혀있는 메모리에 대한 레퍼런스를 특징함으로 파이썬은 메모리를 절약한다.</p>
</blockquote>
<blockquote>
<p>그렇다고 봤을때, 리스트의 시퀸스가 지역성을 보장하지 않는다면, 하나씩 레퍼런스 값을 생성하는, Iterator이 우세하다.</p>
</blockquote>
<p>max(), min()같은 빌트인 함수들은 하나의 이터레이터 매개변수를 받아서 하나의 결과를 돌려줄 수 있다.<br>
“in”, “not in” 연산자 또한 이터레이터를 지원한다.: stream안에서 X를 찾는다면, True아니면 False이다.</p>
<p>너는 명백한 문제로 달려들 것이이다, 만약 이터레이터가 무한하다면, 절때 스트림에서 최대값이나 최소값을 찾을 수 없고, 스트림안에 존자하는지 아닌지에 대한 결과도 무한히 지속되어 끝나지 않을 것이기 때문이다.</p>
<hr>
<h2 id="이터레이터를-지원하는-데이터-타입"><a class="markdownIt-Anchor" href="#이터레이터를-지원하는-데이터-타입"></a> 이터레이터를 지원하는 데이터 타입</h2>
<p>우리는 이미 어떻게 리스트와 튜플이 이터레이터를 지원하는 지 보았다. 사실 어떤 파이썬 시퀸스 타입은 자동으로 이터레이터의 셍성을 도울 것이다.</p>
<p><code>iter()</code>를 딕셔너리에 대해서 호출하는 것은, Keys에 대해서 루프 하게 된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">m = &#123;<span class="string">'Jan'</span>: <span class="number">1</span>, <span class="string">'Feb'</span>: <span class="number">2</span>, <span class="string">'Mar'</span>: <span class="number">3</span>, <span class="string">'Apr'</span>: <span class="number">4</span>, <span class="string">'May'</span>: <span class="number">5</span>, <span class="string">'Jun'</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="string">'Jul'</span>: <span class="number">7</span>, <span class="string">'Aug'</span>: <span class="number">8</span>, <span class="string">'Sep'</span>: <span class="number">9</span>, <span class="string">'Oct'</span>: <span class="number">10</span>, <span class="string">'Nov'</span>: <span class="number">11</span>, <span class="string">'Dec'</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> m:</span><br><span class="line">  print(key, m[key])</span><br><span class="line">Jan <span class="number">1</span></span><br><span class="line">Feb <span class="number">2</span></span><br><span class="line">Mar <span class="number">3</span></span><br><span class="line">Apr <span class="number">4</span></span><br><span class="line">May <span class="number">5</span></span><br><span class="line">Jun <span class="number">6</span></span><br><span class="line">Jul <span class="number">7</span></span><br><span class="line">Aug <span class="number">8</span></span><br><span class="line">Sep <span class="number">9</span></span><br><span class="line">Oct <span class="number">10</span></span><br><span class="line">Nov <span class="number">11</span></span><br><span class="line">Dec <span class="number">12</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>파이썬 3.7 딕셔너리 이터레이션의 순서는 주입된 순서대로 보장된다.</p>
</blockquote>
<p><code>iter()</code>을 사용하면 자동으로 키를 기반으로 이터레이션 루프가 적용된다. 그러나 딕셔너리 그 자체에 이미 다른 이터레이터를 반환하는 메서드가 있다.</p>
<p><code>items()</code> : (key, val)Pair로 원본 객체에 대한 view객체로 만들어준다.<br>
<code>values(),keys()</code> : 위와 동일하게 원본에 대한 레퍼런스를 유지한다.(dynamic-view)</p>
<p>(Key, Value)- 튜플로 구성된 시퀸스를 dict()로 wrap해주면, 마찬가지로 원본의 형태로 객체로 형태를 돌려서 주지만, 원본과의 레퍼런스는 끊어진다.</p>
<blockquote>
<p>파일에서는, <code>readline()</code> 그리고 set는 그 자체로 iterable하다.</p>
</blockquote>
<hr>
<h2 id="generator-expressions-and-list-comprehensions"><a class="markdownIt-Anchor" href="#generator-expressions-and-list-comprehensions"></a> Generator expressions and list comprehensions</h2>
<p>Two common operations on iterator’s output-&gt;</p>
<ol>
<li>Performing some operation for every elem</li>
<li>seslction a subset of elems that meet some condition</li>
</ol>
<p>List comprehension N generator expressions는 그러한 실행의 구체적인 언급이다.</p>
<blockquote>
<p>그것들은 하스켈에서부터 가져온 것이다.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">line_list = [<span class="string">'   line 1 \n'</span>, <span class="string">'line 2    \n'</span>,]</span><br><span class="line"><span class="comment">#gen expression -- return iterator</span></span><br><span class="line">stirpped_iter = (line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> line_list)</span><br><span class="line"><span class="comment">#list comprehsions -- returns list</span></span><br><span class="line">stripped_list = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> line_list]</span><br></pre></td></tr></table></figure>
<p>List comprehension을 통해 너는 파이썬의 리스트를 받는다.<br>
그것은 물질화 된 것이다.</p>
<p>nested-Generator expression은 반면에,<br>
물질화된 것을 돌려주는 것이 아니라,<br>
필요한 때에 하나씩 value를 compute해준다.</p>
<p>그것은 list comprehension이 계속적으로 스트림을 이어가야 하는 작업, 무한히 이어지는 시퀸스에 대해서 적합하지 않다는 것이다.</p>
<p>Generator-exp는 &quot;()&quot;에 감싸여서, 사용되는데 아래와 같다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">( expression <span class="keyword">for</span> expr <span class="keyword">in</span> sequence1</span><br><span class="line">             <span class="keyword">if</span> condition1</span><br><span class="line">             <span class="keyword">for</span> expr2 <span class="keyword">in</span> sequence2</span><br><span class="line">             <span class="keyword">if</span> condition2</span><br><span class="line">             <span class="keyword">for</span> expr3 <span class="keyword">in</span> sequence3 ...</span><br><span class="line">             <span class="keyword">if</span> condition3</span><br><span class="line">             <span class="keyword">for</span> exprN <span class="keyword">in</span> sequenceN</span><br><span class="line">             <span class="keyword">if</span> conditionN )</span><br><span class="line">seq1 = <span class="string">'abc'</span></span><br><span class="line">seq2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> seq1 <span class="keyword">for</span> y <span class="keyword">in</span> seq2]  <span class="comment">#doctest: +NORMALIZE_WHITESPACE</span></span><br><span class="line"><span class="comment"># [('a', 1), ('a', 2), ('a', 3),</span></span><br><span class="line"><span class="comment"># ('b', 1), ('b', 2), ('b', 3),</span></span><br><span class="line"><span class="comment"># ('c', 1), ('c', 2), ('c', 3)]</span></span><br></pre></td></tr></table></figure>
<p>if는 해당 시퀸스 레벨에서 적용되는 것이고, 가장 오른쪽을 최초로 왼쪽으로 점차 wrap해 나간다.</p>
<p>(중략 - 아는 내용 너무 많음)</p>
<h2 id="passing-values-into-a-generators"><a class="markdownIt-Anchor" href="#passing-values-into-a-generators"></a> Passing values into a generators</h2>
<p>파이썬 2.4포함 이전 버전에서는, 제너레이터는 오직 아웃풋만을 생산할 수 있었다.<br>
제너레이터 내부로 값을 보내는 것은 불가능 했다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gens</span><span class="params">()</span></span></span><br><span class="line">  f_val = (yield 1)</span><br><span class="line">  s_val = (<span class="keyword">yield</span> f_val)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line"></span><br><span class="line">outergens = gens</span><br><span class="line">f_yield = outergens.send(<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># expect f_yield == 1 is True</span></span><br><span class="line"></span><br><span class="line">s_yield = outergens.send(<span class="number">999</span>)</span><br><span class="line">  <span class="comment"># send999 =&gt; execution on outergens works</span></span><br><span class="line">    <span class="comment"># 1. f_val delegates 999</span></span><br><span class="line">    <span class="comment"># 2. yield f_val =&gt; loadFast f_val(:999)</span></span><br></pre></td></tr></table></figure>
<p>나는 yield표현 주변에 항상 괄호를 사용하는 것을 추천한다.</p>
<blockquote>
<p>실제 바이트코드 단위에서 val에 대한 할당 이전에 execution을 main컨텍스트로 전환하기 때문에, 그 이전에 yield 1 이라는 컨텍스트를 돌려주기 전에 전달된 값은 무엇이든 무시된다.</p>
<p>그래서 관례상 conventional Rule로서, 처음에 None만을  send 할 수 있도록 강제되어 있다.</p>
</blockquote>
<blockquote>
<p>2번쨰 send를 할때 전달된 값이 제너레이터 내부로 컨텍스트 전환과 함께 할당이 이루어 지면서, yield에서 전달값에 대한 로컬 네임스페이스를 리턴하라는 명령을 만나면, 로드하고, 리턴한다.</p>
</blockquote>
<blockquote>
<p>yield문이 추가로 있어도, return문을 만나면  stopIteration을 Raise한다.</p>
</blockquote>
<ul>
<li>
<p>pep 342는 정확한 룰을 설명한다. yield-expression은 항상 parenthesized해야한다.</p>
</li>
<li>
<p>반면 이런표현에서 주의해야한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = <span class="keyword">yield</span> i <span class="comment"># 라고 사용해도 되지만,</span></span><br><span class="line"><span class="comment"># 아래와 같은 경우는 꼭 괄호를 사용해라</span></span><br><span class="line">val2 = ((<span class="keyword">yield</span> i) + <span class="number">12</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<dl>
<dt>when it occurs at top-level expression on the right-hand side of an assignment.</dt>
<dd>최상위 표현에서, 오른편에 다른 연산이 있을 경우 무조건 괄호를 사용하라.</dd>
</dl>
</li>
</ul>
<p>값들은 제너레이터에 <code>send(value)</code>를 통해서 전달된다.<br>
이 메서드는 제너레이터의 <code>__code__</code>의 컨텍스트로 진입하고, <code>yield</code>표현은 특정 값을 리턴한다.</p>
<p>만약 일반적인 <code>__next__()</code>가 외부에서 불려진다면,<br>
제너레이터 내부에서 yield는 아무것도 반환하지 않는다.</p>
<p>여기에 1씩 증가시키고, 내부적인 카운터를 변화시키는 것을 허락하는 단순한 함수가 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(max)</span>:</span></span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; max:</span><br><span class="line">    val = (<span class="keyword">yield</span> i) <span class="comment"># suspend line</span></span><br><span class="line">    <span class="comment"># if value provided, change counter</span></span><br><span class="line">    <span class="comment"># 만약 send를 통해서 val이 외부에서 주입되었다면, 그 값으로 i를 바꾸고 진행한다. </span></span><br><span class="line">    <span class="keyword">if</span> val <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      i = val</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">it = counter(<span class="number">10</span>) <span class="comment"># max를 10으로 잡아놓은 제너레이터</span></span><br><span class="line"></span><br><span class="line">i1 = next(it) <span class="comment"># return it.send(None)과 동일</span></span><br><span class="line"><span class="comment"># i1 is 0</span></span><br><span class="line">i2 = it.send(<span class="literal">None</span>) <span class="comment"># &lt;- is same with i2 = next(it)</span></span><br><span class="line"><span class="comment"># i2 is 1</span></span><br><span class="line">i3 = it.send(<span class="number">8</span>) <span class="comment"># suspend line에 8을 리턴받고, val은 8이 된다.</span></span><br><span class="line"><span class="comment"># 내부적으로 다음 yield문을 찾아 진행한다.</span></span><br><span class="line"><span class="comment"># i3 == 8</span></span><br><span class="line">i4 = next(it)</span><br><span class="line"><span class="comment"># i4 == 9</span></span><br><span class="line">i5 = next(it)</span><br><span class="line"><span class="comment"># 10으로 바뀌고 POPTOP을 하지 않고,</span></span><br><span class="line"><span class="comment"># return None문을 만나 Stopiteration을 Raise</span></span><br></pre></td></tr></table></figure>
<p>send가 기본으로 일어나는 작용이니, next를 통해서 계속 하기 보다는,<br>
<code>send(None)</code>이 본래 모습이라는 것을 정확히 캐치하고 사용하길 바란다.</p>
<p><code>send()</code>에 따라서, 제너레이터에는 2가지 메서드가 더 있다:</p>
<ol>
<li>
<p><code>throw(type, value = None, traceback =None)</code></p>
<ul>
<li>제너레이터 내부의 컨텍스트에서 Exception을 raise한다;<br>
멈춰진 yield의 시점을 통해서 예외처리가 된다.</li>
</ul>
</li>
<li>
<p><code>close()</code></p>
<ul>
<li>제너레이터가 이터레이션을 삭제시키기 위해서, GeneratorExit라는 exception을 발생시킨다.</li>
<li>이 exception을 받을때에, 제너레이터의 코드는 <code>GeneratorExit</code> 또는 <code>StopIteration</code>을 내부적으로 처리해야 한다.</li>
<li>예외를 처리하는 어긋난 것(어떠한 에러를 Raise)을 행한다면, <code>RuntimeError.close()</code>를 촉발시킨다.</li>
<li>그것은 파이썬 garbage collector에게서 불려지는 것이며, 제너레이터가 소멸되는 것이다.</li>
</ul>
<blockquote>
<p>만약 GeneratorExit가 일어날때, 코드를 정리하고 싶다면,</p>
</blockquote>
   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = mygen1.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(type(e))</span><br><span class="line">        <span class="keyword">if</span> isinstance(e, StopIteration):</span><br><span class="line">            print(<span class="string">"iterStop"</span>)</span><br><span class="line">        <span class="keyword">if</span> isinstance(e, GeneratorExit):</span><br><span class="line">            print(<span class="string">"Gen Exit"</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(res)</span><br><span class="line">        print(<span class="string">"done"</span>)</span><br><span class="line">        mygen1.close()</span><br><span class="line">        <span class="comment"># res를 제너레이터부터 받으면 출력하고 바로 close()</span></span><br><span class="line">        <span class="comment"># close()로 내부적으로 GeneratorExit가 일어나고,</span></span><br><span class="line">        <span class="comment"># Stopiteration으로 연결된다.</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>이러한 변화의 누적은, 제너레이터를 단방향 정보 생산자에서, 정보의 소비자인 동시에 생산자로 만들었다.</p>
<p>제너레이터는 또한 <strong>coroutine</strong>이 된다.<br>
<strong>subroutine</strong>은 컨텍스트의 주도권을 갖은 후 최상위에서 시작해서, return 지점에서 끝나지만,</p>
<p><strong>coroutine</strong>은, 시작되고, 종료되고, 재진입이 매우 다양한 위치에서 진행된 수 있다.(<code>yield</code>선언문을 통해서)</p>
<h2 id="built-in-functions"><a class="markdownIt-Anchor" href="#built-in-functions"></a> Built-in functions</h2>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/functional_programming/python/functional_programming_howto/" data-id="ckkdb52gp001e1pqkow39nt5m" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/functional-programming/">functional programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/module/bytearray" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/module/bytearray/" class="article-date">
  <time datetime="2019-06-19T09:55:32.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/module/bytearray/">파이썬 bytearray 모듈 클래스 정리</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="syntax"><a class="markdownIt-Anchor" href="#syntax"></a> Syntax</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytearray([source[, encoding[,errors]]])</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>source</p>
<p>optional, 만약 소스가:</p>
<ul>
<li>문자라면, 인코딩이 필수적</li>
<li>숫자라면, array가 해당 사이즈를 갖고 빈 바이트들로 초기화</li>
<li>버퍼인터페이스를 따르는 객체라면, 읽기전용 버퍼객체가 bytes array를 초기화하는데 사용될 것이다.</li>
</ul>
</li>
<li>
<p>encoding</p>
<p>선택적이다, 문자일 경우에만 필수적. 일반적인 값으로 “ascii”, “utf-8”, “windows-1250”, &quot;windows-1252&quot;등을 받는다.</p>
</li>
<li>
<p>errors</p>
<p>선택적이다, 가능한 값들은,:</p>
<ul>
<li>‘strict’ : 인코딩 에러가 날 경우 에러를 raise</li>
<li>‘replace’ : 흉하게 생긴 데이터를 적절한 마크로 변환 시킨다., ‘?’, 'uffd’같은경우</li>
<li>‘ignore’ : 흉하게 생긴 데이터를 무시하고, 알림없이 진행한다.</li>
<li>‘xmlcharrefreplace’ : 적절한 XML문자 레퍼런스로 대체한다.(인코딩전용)</li>
<li>‘backslashreplace’ : \를 이스케이프 시퀸스로 사용한다.(인코딩전용)</li>
</ul>
</li>
</ul>
<h2 id="remarks"><a class="markdownIt-Anchor" href="#remarks"></a> Remarks</h2>
<pre><code>바이트배열 타입은 변환할 수 있는 숫자의 시퀸스, 0&lt;=x&lt;256을 가진다.
낮은 레벨의 바이너리 데이터를 다루는 데 사용될 수 있다. 예를 들면,
이미지 내부, 네트워크에서 직접 전달 받을때.
</code></pre>
<h2 id="example1"><a class="markdownIt-Anchor" href="#example1"></a> Example1</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bytearray()</span><br><span class="line"><span class="comment"># bytearray(b'')</span></span><br><span class="line">bytearray(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># bytearray(b'\x00\x00\x00\x00')</span></span><br><span class="line">bytearray([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># bytearray(b'\x00\x01\x02')</span></span><br><span class="line">bytearray(buffer(<span class="string">'hello'</span>))</span><br><span class="line"><span class="comment"># bytearray(b'hello')</span></span><br></pre></td></tr></table></figure>
<h2 id="example2"><a class="markdownIt-Anchor" href="#example2"></a> Example2</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bytearray(<span class="string">'hello'</span>, <span class="string">'ascii'</span>)</span><br><span class="line"><span class="comment"># bytearray(b'hello')</span></span><br><span class="line"></span><br><span class="line">bytearray(<span class="string">u'źdźbło'</span>, <span class="string">'ascii'</span>, <span class="string">'strict'</span>)   <span class="comment">#’blade of grass’ in polish</span></span><br><span class="line"><span class="comment"># UnicodeEncodeError: 'ascii' codec can't encode character u'\u017a' in position 0: ordinal not in range(128)</span></span><br><span class="line"></span><br><span class="line">bytearray(<span class="string">u'źdźbło'</span>, <span class="string">'ascii'</span>, <span class="string">'ignore'</span>)</span><br><span class="line"><span class="comment"># bytearray(b'dbo')</span></span><br><span class="line"></span><br><span class="line">bytearray(<span class="string">u'źdźbło'</span>, <span class="string">'ascii'</span>, <span class="string">'replace'</span>)</span><br><span class="line"><span class="comment"># bytearray(b'?d?b?o')</span></span><br><span class="line"></span><br><span class="line">bytearray(<span class="string">u'źdźbło'</span>, <span class="string">'ascii'</span>, <span class="string">'xmlcharrefreplace'</span>)</span><br><span class="line"><span class="comment"># bytearray(b'&amp;#378;d&amp;#378;b&amp;#322;o')</span></span><br><span class="line"></span><br><span class="line">bytearray(<span class="string">u'źdźbło'</span>, <span class="string">'ascii'</span>, <span class="string">'backslashreplace'</span>)</span><br><span class="line"><span class="comment"># bytearray(b'\\u017ad\\u017ab\\u0142o')</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/module/bytearray/" data-id="ckkdb52h5001v1pqkjmub25yw" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-module/">python module</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/SocketProgramming_HOWTO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/post/SocketProgramming_HOWTO/" class="article-date">
  <time datetime="2019-06-19T09:48:54.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/post/SocketProgramming_HOWTO/">SocketProgramming_HOW 번역</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="author-gordon-mcmillan"><a class="markdownIt-Anchor" href="#author-gordon-mcmillan"></a> Author: Gordon McMillan</h2>
<p>출처 : <a href="https://docs.python.org/3.7/howto/sockets.html#socket-howto" target="_blank" rel="noopener">https://docs.python.org/3.7/howto/sockets.html#socket-howto</a></p>
<hr>
<h2 id="1-sockets"><a class="markdownIt-Anchor" href="#1-sockets"></a> 1. Sockets</h2>
<p>INET(i.e IPv4)소켓에 대해서만 이야기하겠다. 하지만 그들이 99%의 실사용 소켓이다. 그리고 STREAM TCP소켓에 대해서만 이야기 할 것이다.</p>
<p>니가 만약 무얼하고 있는지 알고 있다면, 그 무엇보다 스트림 소켓에서 더욱 좋은 퍼포먼스를 가지게 될 것이다.</p>
<p>소켓이 무엇인지에 대한 미스터리를 정리하려 할 것이다. 블로킹 소켓과 NON-blocking소켓에 대해서도 조금 힌트를 준다. 그렇지만, 일단 blocking소켓에 대해서 이야기하는 것으로 시작하겠다. 너는 그들이 어떻게 넌블러킹 이전에 해왔는지 알 필요가 있다.</p>
<p>이들을 이해하는데 생기는 문제는, socket이라는게 미묘하게 다른 다수의 것을 뜻할 수 있다는 것이다.<br>
그러니 첫째로, client socket, server socket사이에 구분을 해보자.(서버 소켓이 더 switch board operator같다.)<br>
클라이언트 어플리케이션 예를 들어 너의 브라우저는, 클라이언트 소켓만을 사용한다. 웹서버는 서버소켓과 클아이언트 소켓을 동시에 사용한다.</p>
<hr>
<h2 id="2-history"><a class="markdownIt-Anchor" href="#2-history"></a> 2. History</h2>
<p>IPC(Inter Process Communication)의 다양한 form에서, 소켓은 가장 유명하다. 어떤 플랫폼에서도, 그들은 더욱 빠르고, cross-platform커뮤니케이션이다. 소켓은 유일하게 지금 게임이 되는 존재다.</p>
<hr>
<h2 id="3-creating-a-socket"><a class="markdownIt-Anchor" href="#3-creating-a-socket"></a> 3. Creating a Socket</h2>
<p>네가 링크를 클릭했을떄, 너의 브라우저는 이러한 것들을 한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create an INet, STREAMing socket</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># now connect to web server on port 80</span></span><br><span class="line">s.connect((<span class="string">"www.python.org"</span>,<span class="number">80</span>))</span><br></pre></td></tr></table></figure>
<p>connect가 끝났을 때, 소켓 s는 페이지에 대한 리퀘스트를 보내기 위해서 사용될 수 있다.<br>
동일한 소켓이 읽고 응답할 것이다. 그리고 소멸된다. 클라이언트소켓은 기본적으로 한번의 교환을 위해서 사용된다.</p>
<p>웹서버에서는 조금더 복잡하다. 첫쨰로 웹서버는 'server socket’을 생성한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create INET, STREAMing socket</span></span><br><span class="line">serversocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># bind the socket to public host, and a well-known port</span></span><br><span class="line">serversocet.bind((socekt.gethostname(),<span class="number">80</span>))</span><br><span class="line">serversocket.listen(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>몇 가지 알아야 할 사실: 우리는 socket.gethostname()을 사용하여 소켓이 외부 publicIP에 보일 수 있도록 했다.<br>
local안에서 설정했다면, 동일 기계안에서만 보이게 될것이다.</p>
<p>두번째 알아야할 사실: well-known port는 public상의 효율성을 위한 약속이다. 네가 만약, 놀고싶으면 4자리 이상의 포트를 사용해라.</p>
<p>마지막: listen의 argument는 소켓라이브러리로 하여금, 우리가 queue를 5개 connect리퀘스트를 올리길 원한다는 것이다.(5 is normal max). 이후 외부 connect는 거절된다. 다른 코드가 적절히 구성되었다면, 그것은 충분할 것이다.</p>
<p>이제 우리가 서버소켓이 80번 포트에 있으니, 우리는 웹서버의 메인루프에 접근할 수 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># accept connection from outside</span></span><br><span class="line">    (clientsocket, address) = server.socket.accept()</span><br><span class="line">    <span class="comment"># noe do something with clientsocket</span></span><br><span class="line">    <span class="comment"># in this case, we'll pretent this is threded server</span></span><br><span class="line">    ct = client_thread(clientsocket)</span><br><span class="line">    ct.run()</span><br></pre></td></tr></table></figure>
<p>사실 3가지 일반적인 방법이, 이것의 루프를 가능하게 하는 방법으로 있다.</p>
<ol>
<li>쓰레드를 붙여서, 클라이언트 소켓을 제어하는 것.</li>
<li>앱을 재구성해서, nonblocking socket을 사용하게 하는것.</li>
<li>select를 활용하여 서버 소켓과 어떤 활성화된 클라이언트 소켓 사이를 다양화 시킨다.</li>
</ol>
<p>알아야 하는 중요한 것은 이것이다. 이것에 서버소켓이 하는 모든 것이다.<br>
이것은 어떤 데이터를 받지도 않고 데이터를 보내지도 않는다. 이것은 그저 클라이언트 소켓을 생성한다.<br>
각 클라이언트 소켓은 어떤 클라이언트의 소켓이 host와 그의 bound된 port에 connect()함으로써 생성된다. 해당 클라이언트 소켓을 빠르게 우리가 생성한다면, 우리는 더 많은 연결을 기다리도록 돌아갈 수 있다.(listen(5))<br>
2명의 클라이언트는 자유롭게 소통할 수 있다.</p>
<blockquote>
<p>그들은 dynamically allocated port를 사용한다. 어떤 대화가 끝났을때 재사용 되는 포트.</p>
</blockquote>
<hr>
<h2 id="4-ipcinterprocesscommunication"><a class="markdownIt-Anchor" href="#4-ipcinterprocesscommunication"></a> 4. IPC(interProcessCommunication)</h2>
<p>네가 만약 2개의 프로세스 사이에 빠른 IPC를 원한다면, pipes나 shared memory를 생각해 봐야한다.<br>
네가 만약 AF_INET소켓을 사용하기로 결정했다면, 서버소켓을 localhost에 bind해라.<br>
대부분의 플랫폼에서, 이것은 네트워크의 몇개의 레이어로 하여금 shortcut을 사용하도록 해서, 더 빠르고 덜 요란하게 성립하게 해준다.</p>
<blockquote>
<p>See also: 멀티프로세싱은 crosee-platform IPC를 higher-level API로 통합시킨다.</p>
</blockquote>
<hr>
<h2 id="5-using-socket"><a class="markdownIt-Anchor" href="#5-using-socket"></a> 5. Using Socket</h2>
<p>첫번째로 기억해야 할 것은 웹 브라우저의 클라이언트소켓과 웹 서버의 클라이언트소켓은 개별적인 괴물들이다.<br>
그 말은, 이것은 peer to peer 대화 라는 것이다. 다른식으로 얘기하자면, 데자이너로서 너는 대화를 위한 에티켓으로 무엇을 할지를 정해야 할 것이다.<br>
보통 소켓을 연결시키는 것은, 대화를 시작하는 것이다. 리퀘스트를 보냄으로써, 혹은 조직된 행동에 동의하기로 서명함으로써.</p>
<blockquote>
<p>조직된 행동이란 소켓의 룰이 아니다.</p>
</blockquote>
<p>이제 소통을 위한 2개의 동사 세트가 있다. 너는 send, recv를 쓸 수 있다. 아니면 너는 , 너의 클라이언트 소켓을 파일같은 괴수로 만들어서 읽고 쓸 수 있다. 두번째 방법은, 자바가 그의 소켓을 대표하는 방법이다. 넌 너에게 소켓에 대해서 flush를 사용할 필요가 있다는 것을 경고하기만 하겠다. 그것은 bufferd 파일이다. 그리고 쉬운 착각이 뭔가 <strong>write</strong>하기 위해서, 그리고 나서 응답에 대해서 <strong>reply</strong>한다는 것이다. flush가 없다면, 계속 응답에 대해서 기다려야 한다는 것이다. 왜냐하면 리퀘스트는 아직 너의 출력 버퍼에 적혀진 채로 있을 수 있다.</p>
<p>이제 우리는 가장 주요한 소켓의 가장 큰 걸림돌에 도착했다.</p>
<ul>
<li>네트워크 버퍼에 대한 <figure class="highlight plain"><figcaption><span>와 ```recv``` 명령이다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">그들은 네가 건네준 모든 바이트를 다루지 않는다. 왜냐하면, 그들의 주된 목적은 네트워크 버퍼를 다루는 것이다. 일반적으로, 그들은 관련된 네티워크 버퍼가 차거나(send), 비었을 때(recv), return한다.</span><br><span class="line">그리고 나서, 그들은 너에게 얼마나 많은 버퍼를 다뤘는지 알려준다.</span><br><span class="line">너의 메세지가 완전히 다뤄지기전까지 그들을 다시 부르는 것은 너의 소관이다.</span><br><span class="line"></span><br><span class="line">recv가 0bytes를 반환한다면, 그것은 다른 사이드의 연결이 닫혔거나, 반만 닫았다는 얘기이다. 그러면 너는 해당 연결에 대해서 더 이상의 데이터를 받을 수 없다.</span><br><span class="line">너는 상대방이 반만 닫았기 때문에, 데이터를 잘 보낼 수 있을 수도 있다.</span><br><span class="line"></span><br><span class="line">```HTTP``` 같은 프로토콜은 소켓을 하나의 전송에 대해서만 사용한다. 클라이언트가 요철을 보내면, 응답을 읽는다. 그리고 나면 소켓은 정지된다. 이것은 클라이언트가 응답의 끝을 0바이트를 받는 것을 통해서 알 수 있다는 것이다.</span><br><span class="line"></span><br><span class="line">그러나 소켓을 추가적인 전송을 위해서 너의 소켓을 재사용 하기로 계획하고 있다면, 너는 소켓에는 EOT(END OF Transfer)가 없다는 것을 알아야 한다.</span><br><span class="line"></span><br><span class="line">다시 강조한다. 소켓의 send, recv가 0 바이트를 다룬 루에 반환한다면, 연결은 이미 끊어졌다. 만약 연결이 끊어지지 않았다면? 너는 평생 recv 기다려야 할 수도 있다.</span><br><span class="line">왜냐하면 소켓이 더 이상 읽어야 할게 없다고 알려주지 않을 것이기 때문이다.</span><br><span class="line">네가 그것에 대해서 조금 더 생각한다면, 소켓에 대한 기초구현적인 진실을 깨닫게 될 것이다.</span><br><span class="line">- 메세지는 고정된 길이(yuck)거나, 범위가 제한(shrug) 되어야 한다. 또는, 그들이 얼마나 긴지(훨씬 낫다), 혹은 연결 종료를 소통하면서 말이다. 선택은 너의 몫이다. 하지만 어떤 것은 다른 것보다 낫다.</span><br><span class="line"></span><br><span class="line">네가 연결을 종료하고 싶지 않다고 생각했을때. 가장 쉬운 방법은 고정된 길이의 메세지이다.</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">class MySocket:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">클래스만을 설명한다 - 깔끔함을 위한 코드이지 효율성이 아니다.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, sock=None):</span><br><span class="line">        if sock is None:</span><br><span class="line">            self.sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">        else:</span><br><span class="line">            self.sock = sock</span><br><span class="line"></span><br><span class="line">    def connect(self, host, port):</span><br><span class="line">        self.sock.connect((host, port))</span><br><span class="line"></span><br><span class="line">    def mysend(self, msg):</span><br><span class="line">        totalsent = 0</span><br><span class="line">        while totalsent &lt; MSGLEN:</span><br><span class="line">            sent = self.sock.send(msg[totalsent:])</span><br><span class="line">            if sent == 0:</span><br><span class="line">                raise RuntimeError(&quot;socket connection broken&quot;)</span><br><span class="line">            totalsent = totalsent +sent</span><br><span class="line"></span><br><span class="line">    def myreceive(self):</span><br><span class="line">    chunks = []</span><br><span class="line">    bytes_recd = 0</span><br><span class="line">    while bytes_recd &lt; MSGLEN:</span><br><span class="line">        chunk = self.sock.recv(min(MSGLEN - bytes_recd, 2048))</span><br><span class="line">        if chunk == b&apos;&apos;:</span><br><span class="line">            raise RuntimeError(&quot;socket connection broken&quot;)</span><br><span class="line">        chunks.append(chunk)</span><br><span class="line">        bytes_recd = bytes_recd + len(chunk)</span><br><span class="line">    retutn b&apos;&apos;.join(chunks)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>여기서 코드를 전달하는 것은 어떤 메세지 포멧에서도 거의 다 유용하다. 파이썬에서, 네가 문자열을 보내면, 너는 len()을 통해서, 그것의 길이를 정할 수 있다. 첫번째 단어를 가져옴 으로써, 너는 길이를 알아볼 수 있다. 너는 연속된 청크사이즈를 얻게 될 것이다.(4096 ~ 8192가 네트워크 버퍼사이즈로 적당하다.)그리고 네가 구획 문자로 무엇을 받았는지, 확인하면서 말이다.</p>
<p>한가지 네가 주의할 점은: 너의 일반적인 프로토콜이 다수의 메세지가 메세지를 뒤로 위치하도록 보내진다면(어떤 응답 없이),<br>
그리고 네가 recv를 전달해서 청크사이즈의 꾸러미를 수용한다면,<br>
너는 추가로 오는 메세지의 읽는 것을 시작하는 것을 종료해버릴지 모른다.<br>
너는 그것을 다른 곳에 놓고, 그게 필요해질 때까지 저장할 수 있어야 한다.</p>
<p>메세지를 그것의 길이를 앞에 두도록 하는 것은 더욱 복잡해진다. 너느 모든 5개의 문자를 한번의 recv로 받지 못할 수도 있다.<br>
제대로 활용하기 위해서, 너는 그것에서 멀어질 것이다.</p>
<p>하지만, 커다란 네티워크 전송해서, 너의 코드는 매우 빠르게 부서질 것이다.<br>
네가 두 개의 recv loop를 사용하지 않는 다면,</p>
<ol>
<li>첫번째는 길이를 정하고.</li>
<li>두번째는 데이터를 받아오기 위해서.</li>
</ol>
<p>불행하게도, 이것은 또한 네가 send할때, 항상 메세지를 한번에 보내서 너의 버퍼에서 삭제하는 것은 아니라는 것에서 밝혀진다. 이걸 읽고나서도, 너는 결국 이것에 물릴 것이다!</p>
<p>공간에서 있어서, 문자열을 만드는 것은, 이러한 증진은 읽는 이들을 위한 훈련으로 남아 있다.</p>
<h2 id="6-binary-data"><a class="markdownIt-Anchor" href="#6-binary-data"></a> 6. Binary Data</h2>
<p>소켓을 통해서 바이너리 데이터를 보내는 것은, 딱 맞는 일이다. 문제는, 모든 기계가 같은 포멧의 바이너리 데이터를 받는건 아니라는 것이다. 에를 들어 Motorola 칩은, 16비트를 사용해 1을 표현하고, 두개의 16진수 바이트로 00 01으로 한다. 인텔에서는, 바이트가 거꾸로 된다.1은 01 00과 같다. 소켓 라이브러리는, 16비트 32비트 정수를 전환하는 것으로 ntohl, htonl, ntohs, htoms를 호출한다. n은 네트워크를 뜻하고 h는 호스트를 뜻한다.s는 short, l은 long을 뜻한다. 네트워크의 주문자가 호스트인 경우, 그것은 아무것도 안한다. 하지만 기계가 바이트가 거꾸로 됐다면, 이것은 바이트를 적절하게 바꾼다.</p>
<p>32비트 체제인 요즘엔, 아스키가 바이너리 데이터를 표현하는게, 그냥 바이너리를 표현하는 것보다 통 작다. 왜냐하면, 놀랍게도, 모든 길이가 0이나 1을 가지고 있기 때문이다. &quot;0&quot;이라는 문자는 2바이트를 잡고, 바이너리는 4바이트를 잡는다. 하지만 그것은 고정된 길이의 메세지와는 맞지 않는다.</p>
<h2 id="7-disconnecting"><a class="markdownIt-Anchor" href="#7-disconnecting"></a> 7. Disconnecting</h2>
<p>딱 잘라 말해서, 너는 소켓을 close하기 전에 shutdown해버릴 것이다.<br>
shutdown은 소켓에서 경고다.<br>
네가 어떤 argument를 전달했으냐에 따라서, 더 이상 보내진 않겠지만, 듣기는 하겠습니다. 또는 난 듣지 않고 있어요. 라고 말할 수 도 있다.<br>
대부분 소켓 라이브러리는, 이러한 shutdown()을 close와 같이 취급하여 에티켓을 무시해버린다.<br>
그래서 대부분의 경우에, 별도의 shutdown은 필요하지 않다.</p>
<p>shutdown을 효과적으로 사용하는 방법은 HTTP같은 교환법이다.<br>
클라이언트가 리퀘스트를 보내면 이후 shutdown(1)을 수행한다. 이것은 서버에게 클라이언트가 전송을 중지한다. 그러나 아직 받을 수 있다.<br>
라고 말해준다. 서버는 EOF를 0바이트를 받아들임으로써 감지할 수 있다.<br>
이것은 리퀘스트가 끝났다고 감지하는 것이다.<br>
서버가 응답을 보낸다. 만약 send가 성공적으로 완수되면, 클아이언트는 아직 듣고 있었던 것이다.</p>
<p>파이썬은 멀치감치 자동 shutdown을 수행한다.<br>
그리고 소켓이 garbage collected됐을때 그것을 자신에게 공식화한다.<br>
이것은 필요할 경우에 자동으로 close처리 할 것이다.<br>
하지만, 이것에 의존하는 것은 매우 나쁜 습관이다.<br>
만약 너의 소켓이close하지 않고 사라졌다면, 소켓은 다른 끝에서 계속 살아 있을 수 있다.<br>
네가 그저 느린 것이라고 판단하고 말이다.<br>
그러니 제발 일이 끝나면 close를 명시해라. 내부적인 장치가 항상 중요하다.</p>
<h2 id="8-when-sockets-die"><a class="markdownIt-Anchor" href="#8-when-sockets-die"></a> 8. When Sockets Die</h2>
<p>아마도 blocking소켓을 사용하는 것에서 가장 나쁜것은, 다른 쪽이 close없이 조용해져 버렸을때 일어나는 일이다.<br>
너의 소켓은 아마 걸려 있을것이다. TCP는 연결지향적인 프로토콜이라, 그래서 오래 기다린다. 연결을 소멸시키기 전까지 오래 기다린다.<br>
만약 네가 쓰레드를 사용한다면, 모든 쓰레드는 필수적으로 죽어버릴 것이다.<br>
네가 거기에 대해서 할 수 있는 것이 거의 없다.</p>
<p>쓰레드를 죽이려고 하지마라:</p>
<ul>
<li>이유 중 하나는, 쓰레드는 프로세스보다 훨씬 효율적인 이유는, 그들이 자동으로 자원을 재활용 함으로써, 오버헤드를 피하고 있기 때문이다.</li>
<li>다르게 말해서, 네가 쓰레드를 죽이려고 하면, 너의 모든 프로세스는 망치게 될 가능성이 높다.</li>
</ul>
<h2 id="9-non-blocking-sockets"><a class="markdownIt-Anchor" href="#9-non-blocking-sockets"></a> 9. Non-blocking Sockets</h2>
<p>네가 진행을 이해하고 있다면, 소켓을 사용하는 데 필요한 기계적인 것들을 거의 다 알고 있는 것이다. 너는 아직 동일한 call을 사용할 것이다, 전과 다를바 없이.<br>
이것은 그런 것이다. 네가 제대로 하면, 너의 앱은 거의 할 것을 다 한것이다.</p>
<p>파이썬에서는 <figure class="highlight plain"><figcaption><span>사용하여 non-blocking하게 한다. C에서 이것은 더욱 복잡하다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 한가지 말하자면, 너는 BSD의 0_NONBLOCK과 거의 구별할 수 없는 POSIX스타일의 0_NDELAY중에 고르게 될것이다.(TCP_NODELAY)와는 완전히 다르다. 그러나 동일한 개념이다.</span><br><span class="line"></span><br><span class="line">&gt; 소켓을 만든 후, 그리고 사용하기 전에 너는 그것을 한다.</span><br><span class="line"></span><br><span class="line">주요 기계적인 차이는 send, recv, connect 그리고 accept는 아무것도 하지않고 return할 수 있다는 것이다. 너는 물론 몇가지 선택권이 있다.</span><br><span class="line">너는 return 코드와 error코드를 체크해서, 일반적으로 너를 미치게 할 수 있다.</span><br><span class="line">믿지 못해겠다면, 한번 쯤 해보는 것도 좋은 생각이다.</span><br><span class="line">너의 앱이 커지면, 버그가 넘치고, CPU를 빨아먹는다.</span><br><span class="line">그러니 그냥 생각 없이 이것을 따라라.</span><br><span class="line"></span><br><span class="line">- USE ```select</span><br></pre></td></tr></table></figure></p>
<p>C에서는, select는 매우 복잡하다. Python에서는 그냥 케익 한조각일 뿐이다. 그러나 C에 매우 가깝기 때문에, python에서 Select를 이해하면, C에서 조금 순탄해 질 수 있다:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read_to_read, ready_to_write, in_error = \</span><br><span class="line">    select.select(</span><br><span class="line">        potential_readers</span><br><span class="line">        ,potential_writers</span><br><span class="line">        ,potential_errs</span><br><span class="line">        timeout      </span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>너는 select에 3가지 리스트를 전달한다.</p>
<ol>
<li>니가 읽으려고 시도하고 싶은 모든 소켓</li>
<li>니가 쓰려고 시도하고 싶은 모든 소켓</li>
<li>마지막(보통 비어있다) 네가 원하는 것에 에러를 체크해줄 것들.</li>
</ol>
<p>너는 소켓이 하나의 리스트 이상에 전달 될 수 있다는 것을 알아야 한다.<br>
select에 대한 호출은 blocking이다.<br>
그러나 timeout을 줄 수 있다.<br>
이것은 일반적으로  민감한 사안이다.</p>
<blockquote>
<p>적절히 긴 timeout을 주어라, (예를 들면 1분), 네가 만약 다른 선택을 할 마땅한 이유가 없다면.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/post/SocketProgramming_HOWTO/" data-id="ckkdb52hd00261pqkb78cqqt0" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/module/socket" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/module/socket/" class="article-date">
  <time datetime="2019-06-19T09:47:15.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/module/socket/">파이썬 Socket 모듈 정리</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>
<p>socket.socket(family,type,proto,fileno)</p>
<ul>
<li>주어진 주소를 사용하는 소켓을 생성한다.</li>
<li>family는 AF_INET, AF_NET6, AF_UNIX, AF_PACKET, AF_RDS(socket.AF_NET)</li>
<li>type은 SOCK_STREAM, SOCK_DGRAM, SOCK_RAW</li>
<li>protocol number는 보통 0이다, addrFamily가 AF_CAN이거나 하면 다른 값을 가져야 한다.</li>
<li>fileno descriptor가 특정되었다면, 파일 디스크립터에 의해서 , 패밀리 타입, 프로토콜번호가 자동으로 잡힌다.</li>
</ul>
</li>
<li>
<p>serverSocket.listen([backlog]:Optional int)</p>
<ul>
<li>서버가 연결을 수락하도록 허용한다.</li>
<li>백로그가 특정되어있다면, 새로운 연결을 거절하기전에 시스템이 허락한 받아들여지지 않은 연결 수를 특정하는 것이다.</li>
</ul>
</li>
<li>
<p>serverSocket.accept()</p>
<ul>
<li>연결을 받아들인다. 소켓은 주소에 달라붙어있어야하고, 포트 연결에 대해서 수용하고(listen) 있어야 한다.</li>
<li>return value는 pair로 (conn, address)이다.</li>
<li>conn은 새로운 소켓객체다, 데이터를 보내고 받는데 사용될 수 있다.</li>
<li>address는 해당 소켓이 반대쪽 연결의 끝에 어디에 달라붙어 있는지를 얘기한다.</li>
<li>3.5버전 이후 변경점: 시스템콜이 방해를 받아 signal handler이, exception을 raise하지 않는다면, 이 메서드는 시스템 콜에게 InterruptedError를 raise하지 않고, accept를 재시도 한다.</li>
</ul>
</li>
<li>
<p>socket.close()</p>
<ul>
<li>소켓이 닫혔다는 것을 표시한다. FD같은 잠재된 시스템 자원 또한 모든 IO 버퍼에 대한 FD를 markfile()로 확인해서 모든 파일 객체가 닫혔다면, 닫혀버린다.</li>
</ul>
</li>
<li>
<p>socket.markfile(mode=‘r’, buffering=None, *,encoding=None, errors=None, newline=None)</p>
<ul>
<li>소켓과 연결지어진 파일 객체를 반환한다.</li>
</ul>
</li>
<li>
<p>file object : 공식문서 용어해설</p>
<ul>
<li>파일에 기원을 두는 API를 내부 실제 리소스에게 드러내는 객체.</li>
<li>read(), write() 등이 그러한 API이다.</li>
<li>이것이 어떻게 생성됐는지에 따라서, file object는 실제 디스크의 파일이나, 다른 타입의 저장소 혹은 communication device에 접근 할 것인지를 고려할 수 있다.</li>
<li>해당 underlying resourced의 목록
<ol>
<li>statdard input/ouput</li>
<li>in-memory buffers</li>
<li>sockets</li>
<li>pipes, etc…</li>
</ol>
</li>
<li>File Objects는 file-like object 혹은 streams라고 불리기도 한다.</li>
<li>그들은 주로 세가지 카테고리의 파일 객체(정석의 생성법은 open메서드를 통해)
<ul>
<li>binary files, buffered binary files, textfiles</li>
</ul>
</li>
</ul>
</li>
<li>
<p>socket.recv(bufsize[, flags])</p>
<ul>
<li>소켓에서 데이터를 받아온다. 리턴값은 바이트객체.</li>
<li>한번에 받을 수 있는 데이터 양의 총량은 bufsize에 의해 특정된다.</li>
</ul>
<blockquote>
<p>네트워크와 하드웨어를 생각했을때. 최적의 버프사이즈는 2의 제곱수로 잡는 것이 좋다.</p>
</blockquote>
</li>
<li>
<p>socket.connect(address)</p>
<ul>
<li>해당 주소의 remote socket에 접속한다.</li>
<li>주소의 포멧은 address family에 의해 결정된다.</li>
<li>만약 signal에 의해 connection이 interrupted되면, 메서드는 연결이 끝날때 까지 기다리거나,</li>
<li>raise socket.timeout on timeout 한다. 만약에 signal handler가 exception을 raise하지 않고, 소켓이 블로킹 소켓이거나 timeout을 가졌다면</li>
<li>논블로킹 소켓에 대해서, 메서드는 InterruptedError exception을 raise한다. 만약 connection 이 signal에 의해 방해 받았을 때.</li>
</ul>
</li>
<li>
<p>socket.fileno()</p>
<ul>
<li>소켓의 파일 descriptor을 반환한다. -1을 반환한 다면 실패. select.select()와 유용하게 쓰인다.</li>
</ul>
</li>
<li>
<p>select.select(rlist,wlist,xlist[,timeout])</p>
<ul>
<li>이것은 UNIX select()시스템 콜을 향한 딱 맞는 인터페이스이다.</li>
<li>3가지 매개변수는 waitable object의 연속을 전달한다.:
<ul>
<li>모두 파일 디스크립터를 통해 fileno() 등을 통해 전달받은 숫자가 된다.</li>
<li>
<ol>
<li>rlist: wait until ready for reading</li>
</ol>
</li>
<li>
<ol start="2">
<li>wlist: wait ready for writting</li>
</ol>
</li>
<li>
<ol start="3">
<li>xlist: wait for an “exceptional condition(by system)”</li>
</ol>
</li>
</ul>
</li>
<li>빈 시퀸스는 허락된다.</li>
<li>timeout 매개변수가 생략되었을때, 함수는 하나라도 FD가 준비되었을 때까지 block된다.</li>
<li>리턴하는 것은 준비된 3가지 리스트 객체를 리턴한다.</li>
<li>시퀸스에 받아들일 수 있는 타입들은,파이썬 fileobjects(sys.stdin, open(), os.popen()), 혹은 소켓 객체가 있다.</li>
<li>3.5버전의 변화: 함수는 이제 신호에 의해서 interrupted될 때, timeout과 함께 재시도 된다. InterruptedError일 때만 그렇고 다른 에러를 Interrupted 핸들러가 발생시키면 재시도 되지 않는다.</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/module/socket/" data-id="ckkdb52h8001z1pqk6evw23xq" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-module/">python module</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/python_interpreter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/post/python_interpreter/" class="article-date">
  <time datetime="2019-06-19T09:44:43.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/post/python_interpreter/">파이썬 인터프리터에 대한 이해</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-intoduction"><a class="markdownIt-Anchor" href="#1-intoduction"></a> 1. intoduction</h2>
<ol>
<li>execution of python as split into three main phases</li>
</ol>
<p>Initialization:</p>
<ul>
<li>다양한 데이터 구조의 셋업, 파이썬 프로세스에 의해 필요하다.<br>
파이썬 인터프리터 셸과 상호적이지 않을 때 의미가 있다고 생각된다.</li>
</ul>
<p>Compiling:</p>
<ul>
<li>소스코드를 파싱한다.</li>
<li>syntex트리로 만들기 위해</li>
<li>abstract syntex tree(AST)를 생성하기 위해</li>
<li>심볼테이블을 생성하고, 코드 객체를 생성한다.</li>
</ul>
<p>Interpreting:</p>
<ul>
<li>생성된 코드객체의 실행을 의미한다.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">initialize</th>
<th style="text-align:left">compile</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1.main</td>
<td style="text-align:left">4.parse tree generate</td>
</tr>
<tr>
<td style="text-align:left">2.Py_Main</td>
<td style="text-align:left">5.AST generate</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">6.bytecode generate</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">7.bytecode optimization</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">8.code object generate</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">end: codeobect execution</td>
</tr>
</tbody>
</table>
<blockquote>
<p>./Programs/python.c : handles initialization</p>
</blockquote>
<blockquote>
<p>main function call <strong>Py_main</strong> located in ./Modules/main.c</p>
</blockquote>
<blockquote>
<p>main.c handles interpreter initialization process</p>
</blockquote>
<blockquote>
<p>초기화의 과정으로서, Py_Initialize from pylifecycle.c가 호출된다.</p>
<ul>
<li>이것이 인터프리터의 자료구조와 쓰레드상태의 자료구조를 초기화 한다.(매우 중요한 자료구조)</li>
</ul>
</blockquote>
<ul>
<li>인터프리터 상태 자료구조</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">is</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">is</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> *<span class="title">tstate_head</span>;</span></span><br><span class="line"></span><br><span class="line">    PyObject *modules;</span><br><span class="line">    PyObject *modules_by_index;</span><br><span class="line">    PyObject *sysdict;</span><br><span class="line">    PyObject *builtins;</span><br><span class="line">    PyObject *importlib</span><br><span class="line"></span><br><span class="line">    PyObject *codec_search_path;</span><br><span class="line">    PyObject *codec_search_cache;</span><br><span class="line">    PyObject *codec_error_registry;</span><br><span class="line">    <span class="keyword">int</span> codecs_initialized;</span><br><span class="line">    <span class="keyword">int</span> fscodec_initialized;</span><br><span class="line"></span><br><span class="line">    PyObject *builtins_copy;</span><br><span class="line">&#125; PyInterpreterState;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/post/python_interpreter/" data-id="ckkdb52ht002s1pqk6xqsru1c" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/post/bytecode_in_python" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/python/post/bytecode_in_python/" class="article-date">
  <time datetime="2019-06-19T09:42:39.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/python/post/bytecode_in_python/">파이썬 바이트코드에 대한 이해</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>어떤 언어는 직접 CPUInstruction으로 컴파일하고,<br>
어떤 언어는 실행 중에 즉시 소스코드를 해석한다.</p>
<p>어떤 언어는 중간단계의 세트의 instruction으로 컴파일한다.(실제 CPU를 향한게 아님)<br>
그리고 가상머신(인터프리터)을 실행해서,<br>
실행 중에 그것들을 CPU instruction으로 변환해서 건네준다.<br>
그게 ByteCode이다.</p>
</blockquote>
<blockquote>
<p>자바도 바이트코드로 변환한다, C#도 그렇다. 파이썬도 그렇다.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fibonacci.py</span></span><br><span class="line"><span class="comment">#fibonacci.pyc -python2</span></span><br><span class="line"><span class="comment">#pycache - python3</span></span><br><span class="line">fib.__code__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;code object fib at <span class="number">0x10fb76930</span>, file <span class="string">'&lt;stdin&gt;'</span> line <span class="number">1</span>&gt;</span><br><span class="line"></span><br><span class="line">fib.__code__.co_consts</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="literal">None</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">fib.__code__.co_varnames</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">'n'</span>, <span class="string">'current'</span>, <span class="string">'next'</span>) :local-varname</span><br><span class="line"></span><br><span class="line">fib.__code__.co_names</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>() non-localnames</span><br><span class="line"></span><br><span class="line">fib.__code__.co_code</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'|\x00d\x01k....'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.opname[<span class="number">124</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'LOAD_FAST'</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="cpython"><a class="markdownIt-Anchor" href="#cpython"></a> Cpython</h2>
<blockquote>
<p>CPython은 스텍기반 가상머신이다.<br>
각 함수는 호출되면, 콜 스텍위로 새로운 엔트리로 콜 프레임(=스텍프레임)을 집어 넣는다.<br>
함수가 리턴되면, 이것의 프레임은 스텍에서 popped off된다.</p>
<ul>
<li>C기반이라, 규칙처럼 적용되서 탈락을 면할 수 없지만,<br>
Coroutine은 독립된 스텍프레임으로 힙안에 존재하기 때문에,<br>
함수 실행 이후에(제너레이터 초기화)도  남아있을 수 있다.</li>
<li>Cpython은 함수가 실행될 때, 두개의 스텍을 사용한다:<br>
evaluation-stack or data-stack, (이것은 지역변수와 인스트럭션)<br>
And block-stack(얼마나 많은 블록이 활성화되어있는지 추적한다.<br>
loops, try/except, with,…)</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib(8)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">ByteCode</th>
<th style="text-align:left">VAL</th>
<th style="text-align:right">Evauation Stack</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0 LOAD_GLOBAL</td>
<td style="text-align:left">0 (fib)</td>
<td style="text-align:right">2- 8</td>
</tr>
<tr>
<td style="text-align:left">2 LOAD_CONST</td>
<td style="text-align:left">1 (8)</td>
<td style="text-align:right">0- function fib</td>
</tr>
<tr>
<td style="text-align:left">4 CALL_FUNCTION</td>
<td style="text-align:left">1</td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>자세한 것은 <a href="https://docs.python.org/3/library/dis.html" target="_blank" rel="noopener">공식문서 dis 모듈</a>에 바이트코드에 대한 모든게 들어있다. 꼭 기회를 만들어 보시길.</p>
</blockquote>
<blockquote>
<p>아래는 실제로 c로 돌아가는 코드이다.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (opcode)&#123;</span><br><span class="line">    TARGET(NOP)</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line"></span><br><span class="line">    TARGET(LOAD_FAST) &#123;</span><br><span class="line">        PyObject *value - GETLOCAL(oparg);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            format_exe_check_arg(</span><br><span class="line">                PyExc_UnboundLocalError,</span><br><span class="line">                UNBOUNDLOCAL_ERROR_MSG,</span><br><span class="line">                PyTuple_GetItem(co-&gt;co_varnames, oparg)</span><br><span class="line">                );</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(value);</span><br><span class="line">        PUSH(value);</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Many, many more bytecode instructions below...*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="what-can-we-learn-from-bytecode"><a class="markdownIt-Anchor" href="#what-can-we-learn-from-bytecode"></a> What can we learn from bytecode?</h2>
<ol>
<li>
<p>Practical한 효과를 그렇게 보기는 힘들 것이다.</p>
</li>
<li>
<p>하지만 stack-oriented virtual machine을 확인하는 것은 다르다.</p>
<ul>
<li>넓은 이해를 가질 수 있고, 다양한 스타일의 프로그래밍을 구사하는데 도움이 된다.</li>
<li>instruction과 stack에 대해서 우리가 할수 있는 것은,<br>
정말, 정말 극소수지만, 그것은 우리가 찾던 것이다.</li>
</ul>
</li>
<li>
<p>하지만 실용적인 목적도 있다.</p>
<ul>
<li>c를 기반으로 하는 가상머신을 거의 다 이해할 수 있다.</li>
<li>파이썬도 그냥 그 중 하나이다.</li>
<li>공부에 대한 통찰력을 길러준다.</li>
<li>실제 가상머신이 바이트코드를 실행하는 것에 대해서 이해하면 퍼포먼스에 접근할 수 있다.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h2>
<blockquote>
<br>
<ul>
<li>Python은 항상 C보다 느리다는 것을 주목하라.</li>
<li>그러나! 일반적인 가이드라인을 원하지 않는가? 여기 기술한다.</li>
</ul>
<h2 id="1-local-names-are-faster-than-global-ones"><a class="markdownIt-Anchor" href="#1-local-names-are-faster-than-global-ones"></a> 1. Local names are Faster than Global ones</h2>
<ul>
<li>LOAD_CONST &gt; LOAD_FAST &gt; LOAD_NAME or LOAD_GLOBAL
<ul>
<li>왜냐하면 글로벌 네임을 찾아보는 것은 조금 더 복잡하다.</li>
<li>실제 인스트럭션이 생각보다 길 것이다. (muitple namespaces 사이에서 찾아야 한다.)</li>
</ul>
</li>
</ul>
<h2 id="2-loops-and-blocks-are-expensive"><a class="markdownIt-Anchor" href="#2-loops-and-blocks-are-expensive"></a> 2. Loops and blocks Are expensive</h2>
<ul>
<li>Lookout for SETUP_LOOP, SETUP_WITH and SETUP_EXCEPTION</li>
</ul>
<h2 id="3-attribute-acceses-dictionary-lookups-and-list-indexing-are-expensive"><a class="markdownIt-Anchor" href="#3-attribute-acceses-dictionary-lookups-and-list-indexing-are-expensive"></a> 3. <em>Attribute acceses</em>, <em>dictionary lookups</em> and <em>list Indexing</em> are expensive</h2>
<ul>
<li>Look out for LOAD_ATTR and BINARY_SUBSCR</li>
</ul>
</blockquote>
<h2 id="addtional-recommends-to-look-for"><a class="markdownIt-Anchor" href="#addtional-recommends-to-look-for"></a> addtional recommends to look for…</h2>
<h3 id="1-obi-ike-nwosu-inside-the-python-virtual-machine"><a class="markdownIt-Anchor" href="#1-obi-ike-nwosu-inside-the-python-virtual-machine"></a> 1. Obi ike-Nwosu, “inside the Python Virtual Machine”:</h3>
<ul>
<li><a href="https://leanpub.com/insidethepythonvirtualmachine/" target="_blank" rel="noopener">https://leanpub.com/insidethepythonvirtualmachine/</a></li>
</ul>
<h3 id="2-alison-kaptur-a-python-interpreter-written-in-python"><a class="markdownIt-Anchor" href="#2-alison-kaptur-a-python-interpreter-written-in-python"></a> 2. Alison Kaptur, “A Python Interpreter Written in Python”:</h3>
<ul>
<li><a href="http://www.aosabook.org/en/500L/a-python-interpreter-written-in-python.html" target="_blank" rel="noopener">http://www.aosabook.org/en/500L/a-python-interpreter-written-in-python.html</a></li>
</ul>
<h3 id="3-the-cpython-bytecode-interpreter"><a class="markdownIt-Anchor" href="#3-the-cpython-bytecode-interpreter"></a> 3. The CPython bytecode interpreter:</h3>
<ul>
<li><a href="https://github.com/python/cpython/blob/master/Python/ceval.c" target="_blank" rel="noopener">https://github.com/python/cpython/blob/master/Python/ceval.c</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/python/post/bytecode_in_python/" data-id="ckkdb52hn002j1pqkoxf0nlrs" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-post/">python post</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-functional_programming/python/python_functional_programming" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/functional_programming/python/python_functional_programming/" class="article-date">
  <time datetime="2019-06-19T09:39:22.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/functional_programming/python/python_functional_programming/">파이썬의 함수형 프로그래밍에 대한 서론 번역</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>출처 : <a href="https://www.dataquest.io/blog/introduction-functional-programming-python" target="_blank" rel="noopener">https://www.dataquest.io/blog/introduction-functional-programming-python</a></p>
<h2 id="서문"><a class="markdownIt-Anchor" href="#서문"></a> 서문</h2>
<p>대부분의 우리는 파이썬을 객체지향언어라고 알고있다. 클래스와 객체가 비록 사용하기 쉽지만, 파이썬을 작성하는 데엔 다른 방법이 있다.<br>
자바등의 언어는 객체지향에서 벗어나기 힘들게 만드는 경향이 있지만, 파이썬은 그렇지 않다.<br>
파이썬이 코드를 작성하는데에 다른 접근법을 가능하게 한다는 걸 가지고서, 따라오는 논리적인 질문은, 코드를 적는 다른 방법은 무엇일까? 비록 거기에 많은 답들이 있더라도, 가장 흔하고 대체적인 스타일의 코드 작성법은 함수형 프로그래밍이라고 불린다. 함수형 프로그래밍은 메인 로직이 되어가고 있다.</p>
<p>이 포스트에서 우리는<br>
-객체지향과 비교해 함수형의 기본을 설명한다<br>
-당신이 왜 함수형을 적용하기 힘든지 밝혀낸다<br>
-어떻게 파이썬이 그 둘 사이에서 전환하는지 알려준다</p>
<h2 id="1객체지향-언어와-비교하여"><a class="markdownIt-Anchor" href="#1객체지향-언어와-비교하여"></a> 1.객체지향 언어와 비교하여,</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineCounter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        self.file = open(filename, <span class="string">'r'</span>)</span><br><span class="line">        self.lines = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">            self.lines = [line <span class="keyword">for</span> line <span class="keyword">in</span> self.file]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> len(self.lines)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>클래스를 사용하는 것은 위의 사례로 대표된다.<br>
최고의 객체지향은 아니지만, 이것은 객체지향 디자인에 대한 통찰을 보급한다. 클래스 안에서, 거기엔 친숙한 메서드와 속성이라는 개념이 있다. 속성세트와 객체의 상태를 추론하는 속성, 그리고 메서드가 그 상태를 조작한다.</p>
</li>
<li>
<p>그 두 컨셉의 작업에서, 객체의 상태는 시기에따라 계속 변해야한다. 상태를 변화시키는 것은 증거가 된다, lines 속성 속에서, read()메서드를 부른 이후.<br>
예로서 이것은 우리가 어떻게 이 클래스를 사용할 건지이다.</p>
</li>
</ul>
<hr>
<h2 id="scenenario"><a class="markdownIt-Anchor" href="#scenenario"></a> Scenenario</h2>
<ul>
<li>example_file.txt contains 100 lines.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lc = LineCounter(<span class="string">'example_file.txt'</span>)</span><br><span class="line">print(lc.lines)</span><br><span class="line">&gt;&gt; []</span><br><span class="line">print(lc.count())</span><br><span class="line">&gt;&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>The lc object must read the file to set the lines property.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lc.read()</span><br></pre></td></tr></table></figure>
<ul>
<li>The <code>lc.lines</code> property has been changed.</li>
<li>This is called changing the state of the lc</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(lc.lines)</span><br><span class="line">&gt;&gt; [[<span class="string">'Hello world!'</span>, ...]]</span><br><span class="line">print(lc.count())</span><br><span class="line">&gt;&gt; <span class="number">100</span></span><br></pre></td></tr></table></figure>
<ul>
<li>계속 변하는 객체의 상태는 둘다 축복이며 저주이다.</li>
<li>왜 상태의 변화가 부정적인지 알기 위해서, 우리는 대체제를 소개해야 한다. 대체제는 line counter를 독립적인 함수의 연속으로 설계하는 것이다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> [line <span class="keyword">for</span> line <span class="keyword">in</span> f]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(lines)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(lines)</span><br><span class="line"></span><br><span class="line">example_lines = read(<span class="string">'example_log.txt'</span>)</span><br><span class="line">lines_count = count(example_lines)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2순수함수로-작업하기"><a class="markdownIt-Anchor" href="#2순수함수로-작업하기"></a> 2.순수함수로 작업하기</h1>
<p>이전의 예제에서 우리는 라인들을 함수만을 이용해서 리스트의 길이를 셀 수 있었다.<br>
우리가 오직 함수만을 사용할 때, 우리는 함수형 접근을 프로그래밍에 하고 있다,<br>
그 접근은, 놀랍지 않게도, 함수형 프로그래밍이라 불린다.</p>
<p>함수형프로그래밍 뒤에 있는 개념은 함수가 상태없이 존재 하기를 요구한다.<br>
그리고 오직 그들에게 주어진 매개변수으로 출력을 하기를 원한다.<br>
그 기준에 맞는 함수는 순수함수라 불린다. 이것은 함수형 과 아닌 것 사이를 나누기 위한 것이다.</p>
<hr>
<p>Create a global variable <code>A</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">impure_sum</span><span class="params">(b)</span>:</span></span><br><span class="line">    <span class="comment"># Adds two numbers, but uses the</span></span><br><span class="line">    <span class="comment"># global `A` variable.</span></span><br><span class="line">    <span class="keyword">return</span> b + A</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pure_sum</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="comment"># Adds two numbers, using</span></span><br><span class="line">    <span class="comment"># ONLY the local function inputs.</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">print(impure_sum(<span class="number">6</span>))</span><br><span class="line">&gt;&gt; <span class="number">11</span></span><br><span class="line"></span><br><span class="line">print(pure_sum(<span class="number">4</span>, <span class="number">6</span>))</span><br><span class="line">&gt;&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>이 순수함수의 이점이 외부효과가 있는 함수 명확한 것은, Reduction의 외부효과들이다.</li>
<li>외부효과들은 함수 밖에 있는 것에 대해서 함수의 실행이 변화를 주었을 때 일어난다.</li>
<li>예를 들어 그것들은 우리가 객체의 상태를 바꾸려고 했을 때 일어난다. 어떤 I/O 명령을 실행했을 때, 혹은 print()를 호출했을때,</li>
</ul>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_and_print</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># Side effect of opening a</span></span><br><span class="line">        <span class="comment"># file outside of function.</span></span><br><span class="line">        data = [line <span class="keyword">for</span> line <span class="keyword">in</span> f]</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        <span class="comment"># Call out to the operating system</span></span><br><span class="line">        <span class="comment"># "println" method (side effect).</span></span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>함수 내부에서 함수 밖에 메모리를 호출하고 조종한다.</p>
</li>
<li>
<p>프로그래머들은 그들의 코드가 쉽게 테스트되고 디버깅되고 따르기 쉽게 만들기 위해서 외부효과를 줄인다. 그리고 코드의 외부효과가 커질수록, 프로그램을 진행하고 실행의 순서를 이해하기 어려워진다.</p>
</li>
<li>
<p>비록 모든 외부효과를 없애려고 시도하는 것은 편리하더라도,<br>
그들은 프로그래밍을 쉽게 만든다. 우리가 만약 모든 외부효과를 없애려고 했다면,<br>
그럼 너는 파일도 읽을 수 없고, print를 호출할 수도 없고<br>
모든 변수를 함수 내에서만 초기화 해야한다.</p>
</li>
<li>
<p>함수형 프로그래밍의 지지자들은 이 트레이드 오프를 이해하고 있다.<br>
그리고 개발의 결과의 퍼포먼스를 해치지 않는 선에서 가능한 많은 외부효과를 제거하려고 노력한다.</p>
</li>
</ul>
<hr>
<h2 id="3람다함수"><a class="markdownIt-Anchor" href="#3람다함수"></a> 3.람다함수</h2>
<ul>
<li>def 형식 이외에 함수 선언에서 우리는 lambda표현을 할 수 있다.</li>
<li>람다 형식은 def선언형식을 가깝게 따라가지만, 이것은 1-1 매핑이 아니다.<br>
이것은 2개의 정수를 더하는 함수의 예이다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using `def` (old way).</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">old_add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="comment"># Using `lambda` (new way).</span></span><br><span class="line">new_add = <span class="keyword">lambda</span> a, b: a + old_add(<span class="number">10</span>, <span class="number">5</span>) == new_add(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>람다 표현식은 콤마를 사용하여, 매개변수의 연속성을 분리한다.<br>
그리고, 정확히 인터프리터가 그 문장의 콜론에 닿는 때에,<br>
이것은 따로 return에 대한 진술없이 표현식을 리턴한다.<br>
결국, 변수에 람다함수를 할당하는 것은, 파이썬함수처럼 작동하는 것이고,<br>
변수를 함수처럼 사용할 수 있다.new_add()</p>
</li>
<li>
<p>우리가 비록 람다 차체에 변수이름을 할당하지 않았더라도, 이것은 익명의 함수가 된다.<br>
이 익명함수는 매우 도움이 된다. 특히 다른 함수의 매개변수가 되는 때에.</p>
</li>
<li>
<p>예를들어, sorted()함수는 옵션의 Key매개변수를 받는다.<br>
그 매개변수는 어떻게 아이템들이 리스트에서 정렬되야 하는지를 나타낸다.</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unsorted = [(<span class="string">'b'</span>, <span class="number">6</span>), (<span class="string">'a'</span>, <span class="number">10</span>), (<span class="string">'d'</span>, <span class="number">0</span>), (<span class="string">'c'</span>, <span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sort on the second tuple value (the integer).</span></span><br><span class="line">print(sorted(unsorted, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]))</span><br><span class="line">&gt;&gt; [(<span class="string">'d'</span>, <span class="number">0</span>), (<span class="string">'c'</span>, <span class="number">4</span>), (<span class="string">'b'</span>, <span class="number">6</span>), (<span class="string">'a'</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4map함수"><a class="markdownIt-Anchor" href="#4map함수"></a> 4.Map함수</h2>
<p>파이썬에서 매개변수로 함수를 전달하는게 다른언어와 구별되는 일은 아니지만, 이것은 최근 프로그래밍 언어들에서 사용되는 개발이다. 이러한 타입의 행동을 따르는 함수들을 first-class fucntions라고 부른다. 어떤 first-class Func를 포한하는 언어는 함수형 스타일로 작성될 수 있다.</p>
<p>first-class Func와 함께 세트로 함수형 패러다임에서 주요 사용되는 것이 있다. 이 함수들은 iterable 객체를 받는다. 마치 sorted()처럼, 요소에 개별적으로 함수를 적용시킨다. 다음 일부 섹션에서, 우리는 그들을 개별적으로 시험해볼 것이다.<br>
그러나 그들은 일반적인 포멧인<br>
function_name(function_to_apply, iterable_of_elements).<br>
를 따른다.</p>
<ul>
<li>우리가 실험해볼 함수는 map()함수이다. map()함수는 iterable객체를 받아서, 새로운 iterable객체를 생성한다. 특별한 map객체이다. 새로운 객체는 모든 요소에 적용되는 일급함수를 가지고 있다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pseudocode for map.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span><span class="params">(func, seq)</span>:</span></span><br><span class="line">    <span class="comment"># Return `Map` object with</span></span><br><span class="line">    <span class="comment"># the function applied to every</span></span><br><span class="line">    <span class="comment"># element.</span></span><br><span class="line">    <span class="keyword">return</span> Map(</span><br><span class="line">        func(x)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> seq</span><br><span class="line">    )</span><br><span class="line"><span class="comment"># 이것은 우리 어떻게 맵을 사용하여 개별 리스트 요소에 10또는 20을 다하는 방식이다.</span></span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Note: We convert the returned map object to</span></span><br><span class="line"><span class="comment"># a list data structure.</span></span><br><span class="line">add_10 = list(map(<span class="keyword">lambda</span> x: x + <span class="number">10</span>, values))</span><br><span class="line">add_20 = list(map(<span class="keyword">lambda</span> x: x + <span class="number">20</span>, values))</span><br><span class="line"></span><br><span class="line">print(add_10)</span><br><span class="line">&gt;&gt; [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line"></span><br><span class="line">print(add_20)</span><br><span class="line">&gt;&gt; [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>
<p>map()을 리턴하는 것에서 리스트객체를 리턴하는 것으로 바뀌었다는 점을 주목하라.<br>
돌려받은 map객체룰 사용하는 것은 네가 list처럼 나오는 것을 기대한다면 좀 불편한 것이다. 첫째로, 그것을 출력하는 것은 모든요소를 보여주지 않으며, 둘째로 너는 한번만을 순회하는 것이 가능하다.</p>
<p>왜냐면, 그 기록이 map객체의 인스턴스에 기록되기 때문이다.</p>
<hr>
<h2 id="4filter함수"><a class="markdownIt-Anchor" href="#4filter함수"></a> 4.Filter함수</h2>
<p>map과 유사하니 일단 통과</p>
<hr>
<h2 id="5reduce함수"><a class="markdownIt-Anchor" href="#5reduce함수"></a> 5.Reduce함수</h2>
<p>우리가 볼 마지막 함수인 reduce()는 functools패키지 내부에 있다. 그 함수는 이터러블 객체를 받아, 이터러블객체를 하나의 value로 줄인다. Reduce는 filter(), map()과는 다르다. 왜냐하면 이것은 해당 함수가 2개의 인자를 받기 때문이다.<br>
이것은 우리가 어떻게 reduce()를 사용하여 모든 리스트이 요소를 합하는 예이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">summed = reduce(<span class="keyword">lambda</span> a, b: a + b, values)</span><br><span class="line">print(summed)</span><br><span class="line">&gt;&gt; <span class="number">10</span></span><br><span class="line">실행도</span><br><span class="line">new = <span class="number">1</span>+<span class="number">2</span></span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line">new = new+<span class="number">3</span></span><br><span class="line">(<span class="number">6</span>)</span><br><span class="line">new = new+<span class="number">4</span></span><br><span class="line">(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 기억해야할 흥미로운점은 람다표현을 사용하면, 두번째 value에 대해선 실행하지 않아도 된다는 점이다.</span></span><br><span class="line"><span class="comment"># 예를 들어 어떤 함수가 이터러블 객체의 첫 요소만 항상 반환한다고 보자</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By convention, we add `_` as a placeholder for an input</span></span><br><span class="line"><span class="comment"># we do not use.</span></span><br><span class="line">first_value = reduce(<span class="keyword">lambda</span> a, _: a, values)</span><br><span class="line">print(first_value)</span><br><span class="line">&gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6list-comprehensions로-재작성"><a class="markdownIt-Anchor" href="#6list-comprehensions로-재작성"></a> 6.List comprehensions로 재작성</h2>
<p>우리가 결국 리스트로 변환했기 때문에, 우리는 map(),filter()함수를 리스트-C로 재작성해야한다. 우리가 파이썬고유 표현형식을 통해 리스트를 만드는 것으로 이점을 얻을 수 있기 때문에, 이것이 더 그들을 쓰기에 파이써닉한 방법이다. 이것인 이전의 예제를 리스트-C로 변환할 수 있는 방법이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Map.</span></span><br><span class="line">add_10 = [x + <span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> values]</span><br><span class="line">print(add_10)</span><br><span class="line">&gt;&gt; [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Filter.</span></span><br><span class="line">even = [x <span class="keyword">for</span> x <span class="keyword">in</span> values <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(even)</span><br><span class="line">&gt;&gt; [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>예제를 보면, 우리는 람다함수를 더할 필요도 없다! 네가 만약 map()filter()를 너의 코드에 적용하려 한다면, 이것을 가장 추천한다. 먼저 고려해라. 그러나 다음 섹션에서, 우리는 map(),filter()를 사용하여 예시를 보여줄 것이다.</p>
<hr>
<h2 id="7function-partials-작성하기"><a class="markdownIt-Anchor" href="#7function-partials-작성하기"></a> 7.function Partials, 작성하기</h2>
<p>떄로 우리는 함수의 행동은 그대로 사용하고 싶으면서, 들어오는 매개변수의 수를 줄이고 싶다. 목적은 하나의 인풋을 저장하여, 저장된 매개변수를 default로 하는 새로운 함수를 만든다. 예를 들어 우리가 2를 더해주는 함수를 작성한다고 가정하자.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_two</span><span class="params">(b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> + b</span><br><span class="line"></span><br><span class="line">print(add_two(<span class="number">4</span>))</span><br><span class="line">&gt;&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>add_two함수는 일반적 함수인 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(a,b)=a+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 와 유사하다, 오직 다른건 하나의 매개변수를 기본으로 하고 있다는 것이다.<br>
(a=2)<br>
우리는 partial모듈을 사용하여, argument기본이 설정할 수 있다.<br>
(람다는 초기화 당시에 라서 람다가 평가되는 시점에 유효한 Reference을 읽어내지만,<br>
이것은 평가시점이 아니라 설정한 당시 value를 유지한다. 마치 클로저변수처럼.</p>
<p>partial 모듈은 함수를 받아 매개변수를 freezes(value로서)로 고정시킨다, 첫번째 매개변수로부터 시작해서, 디폴트 매개변수 value로서 완성된 새로운 함수를 리턴한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">add_two = partial(add, <span class="number">2</span>)</span><br><span class="line">add_ten = partial(add, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(add_two(<span class="number">4</span>))</span><br><span class="line">&gt;&gt; <span class="number">6</span></span><br><span class="line">print(add_ten(<span class="number">4</span>))</span><br><span class="line">&gt;&gt; <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#partials는 어떤 함수도 받을 수 있다. 표준 라이브러리들도 포함해서.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A partial that grabs IP addresses using</span></span><br><span class="line"><span class="comment"># the `map` function from the standard library.</span></span><br><span class="line"></span><br><span class="line">extract_ips = partial(</span><br><span class="line">    map,</span><br><span class="line">    <span class="keyword">lambda</span> x: x.split(<span class="string">' '</span>)[<span class="number">0</span>]</span><br><span class="line">)</span><br><span class="line">lines = read(<span class="string">'example_log.txt'</span>)</span><br><span class="line">ip_addresses = list(extract_ip(lines))</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/functional_programming/python/python_functional_programming/" data-id="ckkdb52gr001f1pqk0tzo3pvg" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/functional-programming/">functional programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-computing/network/tcp_all_in_one" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/computing/network/tcp_all_in_one/" class="article-date">
  <time datetime="2019-06-19T09:34:26.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/computing/network/tcp_all_in_one/">TCP분석과 이해</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>TCP의 중요한 성질</p>
<ol>
<li>Connected Oriented: 연결지향</li>
<li>Bidirectional Byte stream: 양방향성 바이트스트림(octet-stream)</li>
<li>In-order delivery: 순차적인 전송</li>
<li>Reliability through ACK: ACK를 통한 안정성</li>
<li>Flow Control: 수신자의 receive window에 맞는 바이트 수 안쪽으로 데이터를 전송</li>
<li><strong>Congestion control</strong> : 일방적으로 일대 다 통신을 강요받는 서버가 네트워크 정체를 방지하기 위해 congest해on window를 사용. 데이터양을 제한. TCP vegas등 알고리즘이 있다. Flow Control과 달리 송신자가 단독으로 구현.</li>
</ol>
<hr>
<h2 id="1-데이터-전송"><a class="markdownIt-Anchor" href="#1-데이터-전송"></a> 1. 데이터 전송</h2>
<p>스텍에는 여러 레이어가 있다.<br>
그렇지만 크게, user영역, device영역으로 나눌 수 있다. 유저 영역과 커널영역의 작업은 CPU가 수행한다.</p>
<ul>
<li>유저영역+커널영역 = HOST</li>
<li>Device영역 = NIC</li>
</ul>
<blockquote>
<p>NIC로 인해 IO바운드한 소켓버퍼를 설계할 수 있고 싱글쓰레드의 비동기 처리는 이 장치에 기인한다.</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">Boundary</th>
<th style="text-align:left">layer</th>
<th style="text-align:left">description</th>
<th style="text-align:right">packet</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">User</td>
<td style="text-align:left">App(process)</td>
<td style="text-align:left">write(fd,buf,len)</td>
<td style="text-align:right">data</td>
</tr>
<tr>
<td style="text-align:left">Kernel</td>
<td style="text-align:left">File</td>
<td style="text-align:left">파일descritor을 갱신</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">Kernel</td>
<td style="text-align:left">Sockets</td>
<td style="text-align:left">버퍼객체를 소켓버퍼로 copy</td>
<td style="text-align:right">sendsocketbuffer:[BYTE_DATA] (송수신용 버퍼에 맞게 저장된 바이트데이터)</td>
</tr>
<tr>
<td style="text-align:left">Kernel</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">TCP상태와 checksum에 따라 TCP 계층을 구성</td>
<td style="text-align:right">[TCP,B_data]:buffer</td>
</tr>
<tr>
<td style="text-align:left">Kernel</td>
<td style="text-align:left">IP</td>
<td style="text-align:left">IP헤더추가, IP라우팅추가, 체크섬진행</td>
<td style="text-align:right">[IP,TCP,B_data]</td>
</tr>
<tr>
<td style="text-align:left">Kernel</td>
<td style="text-align:left">Ethernet</td>
<td style="text-align:left">ethernet 헤더를 붙이고, ARP실행(주소변환)</td>
<td style="text-align:right">[Eth,IP,TCP,B_data]</td>
</tr>
<tr>
<td style="text-align:left">Kernel</td>
<td style="text-align:left">Driver</td>
<td style="text-align:left">NIC에게 소켓을 보내라고 전달하는OS의 마지막 레벨</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">Device</td>
<td style="text-align:left">NIC</td>
<td style="text-align:left">호스트메모리에서 패킷을 받아 fetch한다. <strong><em>Interrupt the host when send is done</em></strong></td>
<td style="text-align:right">[IFG,Pre,Eth,IP,TCP,payload]</td>
</tr>
</tbody>
</table>
<blockquote>
<p>CheckSum: 중복검사의 한 형태로, 오류정정을 통해, 전자통신이나 기억장치 속에서<br>
송신된 자료의 무결성을 보호하는 단순한 방법이다.</p>
</blockquote>
<blockquote>
<p>Linux나 UNIX를 비롯한 POSIX계열 운영체제는 소켓을 FD로 애플리케이션에 그 고유성을 노출한다.</p>
</blockquote>
<blockquote>
<p>파일레이어가 단순한 검사후에, 커널소켓에 연결된 소켓구조체(프로그램레벨 소켓객체)를 사용하여, 소켓함수를 제공한다.</p>
</blockquote>
<blockquote>
<p>커널 소켓은 두개의 버퍼를 가지고 있다. (send Socket Buffer, receice socket buffer) write시스템 콜을 호출하면 유저영역의 데이터가 커널 메모리로 복사된다. 이 다음으로 TCP를 호출한다.</p>
</blockquote>
<blockquote>
<p>소켓과 연결된 TCP Control Block(TCB)가 있다. TCB를 다룬다.</p>
</blockquote>
<hr>
<p>TCB에 있는 데이터,</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCB: [</span><br><span class="line">connection state(LISTEN, ESTABLISHED, TIME_WAIT등),  </span><br><span class="line">receive <span class="built_in">window</span>,  </span><br><span class="line">congestion <span class="built_in">window</span>,  </span><br><span class="line">sequence넘버,  </span><br><span class="line">재전송 타이머 등  </span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<hr>
<ol>
<li>
<p>TCP상태가, 전송을 허용하면, TCPsegment. 즉, 패킷을 생성한다.</p>
</li>
<li>
<p>이후 IP레이어를 거쳐 다음 HOP등에 대한 라우팅이나 헤더추가가 끝나면, NIC로 결국 내려가게 되는데,</p>
</li>
<li>
<p>NIC는 패킷전송 요청을 OS레벨 드라이버에게서 받고, 메인 메모리에 있는 패킷을 <strong>자신의 메모리로 복사하고</strong> 네트워크 선으로 전송한다.</p>
</li>
<li>
<p>놀라운 일이다. NIC는 독립적인 메모리를 가진 디바이스이다.</p>
</li>
</ol>
<hr>
<h2 id="2-nic"><a class="markdownIt-Anchor" href="#2-nic"></a> 2. NIC</h2>
<blockquote>
<p>매우 중요하다, 비동기 싱글쓰레드가 가능한건 순전히 이 부분의 힘이다.</p>
</blockquote>
<ul>
<li>NIC가 패킷을 전송할 때 NIC는 호스트CPU에 interrupt를 발생시킨다. 모든 인터럽트에는 인터럽트 번호가 있으며,</li>
<li>운영체제는 이 번호를 이용하여 이 인터럽트를 처리할 수 있는 적합한 드라이버를 찾는다.</li>
<li>드라이버는 인터럽트 핸들러를 드라이버가 가동되었을 때 <strong>운영체제에</strong> 등록해둔다.</li>
<li>운영체제가 핸들러를 호출하고, 핸들러는 전송된 패킷을 운영체제에 반환한다.</li>
</ul>
<hr>
<h2 id="3-패킷-수신"><a class="markdownIt-Anchor" href="#3-패킷-수신"></a> 3. 패킷 수신</h2>
<ul>
<li>
<p>NIC</p>
<ol>
<li>드라이버가 미리 할당해 놓은 메모리버퍼가 없으면 NIC가 패킷을 버릴 수 있다!</li>
<li>패킷을 호스트 메모리로 전송한 후, NIC가 호스트 운영체제에 인터럽트를 보낸다.</li>
</ol>
</li>
<li>
<p>드라이버</p>
<ol>
<li>드라이버가 상위 레이어로 패킷을 전달하려면 운영체제가 이해할 수 있도록 운영체제 구조체를 포장해야한다.</li>
</ol>
<ul>
<li>LINUX:sk_buff</li>
<li>BSC:mbuf</li>
<li>MS:NET_BUFFER_LIST</li>
</ul>
</li>
<li>
<p>Ethernet</p>
<ol>
<li>상위프로토콜인 네트워크 프로토콜을 찾는다. 이때 Ethernet헤더의 ethertype을 검사한다.</li>
<li>IPv4의 ethertype은 0x0800이다. 헤더를 제거하고, IP레이어로 패킷을 전달한다.</li>
</ol>
</li>
<li>
<p>IP레이어</p>
<ol>
<li>IP헤더 체크섬을 확인한다. : 논리적으로 여기서 IP 라우팅을 해서 패킷을 로컬장비가 처리해야하는지 아니면 다른장비로 전달해야 하는지 판단한다.</li>
<li>IP헤더의 proto값을 보고 찾는다. TCP proto값은 6이다. 헤더를 제거하고, TCP레이어로 패킷을 전달한다.</li>
</ol>
</li>
<li>
<p>TCP</p>
<ol>
<li>TCP체크섬을 확인하는데, 요즘 네트워크 스텍에는 checksum offload기술이 적용되어 있기 떄문에, 커널이 아니라 드라이버 NIC가 이 과정을 처리해준다.</li>
<li>TCPcontrol block을 찾는다. 이때 패킷의 &lt;소스 IP, 소스 port, 타킷 IP, 타깃 port&gt;를 식별자로 사용한다.</li>
<li>연결을 찾으면, 페이로드를 receive socket buffer에 추가한다.</li>
<li>TCP상태에 따라 새로운 TCP패킷(ACK등)을 전송할 수 있다.</li>
</ol>
</li>
</ul>
<blockquote>
<p>TCP가 Receivesocketbuffer로 잔달할때, 이 크기가 결국 receive window이다. 최신 네트워크 스텍은 윈도우 크기를 자동 조절하는 기능을 가지고 있다.</p>
</blockquote>
<ol>
<li>마지막으로 애플리케이션이 read시스템 콜을 사용하면 버퍼에 있는 메모리를 유저공간의 메모리로 복사하고, 복사한 메모리는 제거한다.</li>
<li>제거된 공간덕에 버퍼에 공간이 늘었기 때문에 윈도우 크기를 증가시킨다.</li>
</ol>
<p>소켓레이어에 sendbuffer[snd.UNA:아직 ACK를 받지 못한 데이터시퀸스 시작 넘버, snd.NXT:다음에 보낼 시퀸스 시작 넘버]</p>
<ul>
<li>상대방의 ACK와 합의된 window크기에 따라 맞춰서 보내준다.</li>
</ul>
<p>소켓레이어에 receivebuffer:[nxt:다음번에 받을 상대방의 시퀸스 넘버]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/computing/network/tcp_all_in_one/" data-id="ckkdb52gn001c1pqkcz5n8c1a" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-computing/network/3_step_in_tcp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/computing/network/3_step_in_tcp/" class="article-date">
  <time datetime="2019-06-19T09:32:33.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/computing/network/3_step_in_tcp/">TCP의 3단계 절차</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="tcp의-3단계"><a class="markdownIt-Anchor" href="#tcp의-3단계"></a> TCP의 3단계</h1>
<h2 id="1-연결설정"><a class="markdownIt-Anchor" href="#1-연결설정"></a> 1. 연결설정</h2>
<blockquote>
<p>최초 요청을 주는 쪽에서, connect함수 호출과 동시에, three-way handshake가 실행된다!</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">requester</th>
<th style="text-align:right">responser</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SYN(SEQ:1000,ACK:-)</td>
<td style="text-align:right">…listening</td>
</tr>
<tr>
<td style="text-align:left">waiting…</td>
<td style="text-align:right">SYN+ACK(SEQ:2000,ACK:1001)</td>
</tr>
<tr>
<td style="text-align:left">ACK(SEQ:1001,ACK:2001)</td>
<td style="text-align:right">…waiting</td>
</tr>
<tr>
<td style="text-align:left">ACK only:lasthandshake</td>
<td style="text-align:right">receive ACK, ready to send</td>
</tr>
<tr>
<td style="text-align:left">SYN:synchronization</td>
<td style="text-align:right">ACK: acknowledge</td>
</tr>
<tr>
<td style="text-align:left">now we are connected in TCP.</td>
<td style="text-align:right"><em><strong>three way hand Shake</strong></em></td>
</tr>
</tbody>
</table>
<blockquote>
<p>본격적으로 원하는 페이로드를 요청하고 받기 이전에 이 과정이 완료되야 connected했다고 한다.</p>
</blockquote>
<blockquote>
<p>두번째 단계에서는 데이터 송수신이 시작된다.</p>
</blockquote>
<hr>
<h2 id="2-데이터-송수신"><a class="markdownIt-Anchor" href="#2-데이터-송수신"></a> 2. 데이터 송수신</h2>
<ul>
<li>데이터 전송 단계에서 <strong>flow control</strong>은 첫 번째 단계보다 훨씬 복잡하다.<br>
예시는 responser가 requester에게 많은 양의 데이터를 전송하는 상황이다.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">RES</th>
<th style="text-align:right">REQ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">packet(SEQ:1301, 100bytes)</td>
<td style="text-align:right">listening(registered requester)</td>
</tr>
<tr>
<td style="text-align:left">waitForACK</td>
<td style="text-align:right">ACK:1401</td>
</tr>
<tr>
<td style="text-align:left">SEQ:1401, 100bytes</td>
<td style="text-align:right">…waiting</td>
</tr>
<tr>
<td style="text-align:left">waitForACK…</td>
<td style="text-align:right">(didnt receive!) …waiting</td>
</tr>
<tr>
<td style="text-align:left">timeout(wait enough!)</td>
<td style="text-align:right">…waiting</td>
</tr>
<tr>
<td style="text-align:left">SEQ:1401, 100bytes</td>
<td style="text-align:right">…waiting</td>
</tr>
<tr>
<td style="text-align:left">waitForACK…</td>
<td style="text-align:right">ACK:1501</td>
</tr>
</tbody>
</table>
<blockquote>
<ol>
<li>100바이트를 전송하면서 <em>SEQ:1301</em> 을 전송한다. 1301으로부터 offset 100.</li>
<li>ACK패킷이 잘 도착했다면, RES는 1301부터 100떨어진 <em>SEQ1401</em>에서 100byte를 전송한다.</li>
<li>timeout이 발생, 이전 패킷을 다시 보낸다.</li>
<li>마지막까지 잘 도착했다면, ACK:1501로 마지막 바이트가 끝난 지점을 보낸다.</li>
</ol>
<ul>
<li>ACK를 수신한 바이트 수만큼 증가시켜서 돌려보내줘야, 유실없이 잘 받았다는 싸인이다.<br>
IP(internet Protocol)은 기본적으로 패킷의 유실이 발생할 수 있는 불안정적인 연결을 깔고 가고,<br>
TCP는 그만큼 정확한 체크를 통해 서로 안전한 연결성을 보장한다.</li>
</ul>
</blockquote>
<hr>
<h2 id="3-연결-종료"><a class="markdownIt-Anchor" href="#3-연결-종료"></a> 3. 연결 종료</h2>
<h3 id="four-way-handshaking"><a class="markdownIt-Anchor" href="#four-way-handshaking"></a> four-way handshaking</h3>
<ul>
<li>연결을 종료하는 과정은 소켓프로그래머에게 가장 중요한 단계에 해당된다.</li>
<li>이번에는 연결을 계속 유지되는 것이 기본 TCP소켓 스트림이기 때문에,<br>
Client가 server에게 연결종료 하겠다고 알리는 과정이라고 가정한다.</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th style="text-align:left">Client</th>
<th style="text-align:right">Server</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FIN(SEQ:5000,ACK:-)</td>
<td style="text-align:right">…waitForClientEvent</td>
</tr>
<tr>
<td style="text-align:left">waitForACK…</td>
<td style="text-align:right">ACK(SEQ:7500,ACK:5001)</td>
</tr>
<tr>
<td style="text-align:left">waitForFIN…</td>
<td style="text-align:right">FIN(SEQ:7501,ACK:5001)</td>
</tr>
<tr>
<td style="text-align:left">ACK(SEQ:5001,ACK:7502)</td>
<td style="text-align:right">…waitForACK</td>
</tr>
</tbody>
</table>
<hr>
<blockquote>
<p>이것은 상호간에 종료 통보와 확인을 교환하는 것이다. 서로 메모리를 아끼는 수단.<br>
일반적으로 종료 사인을 보내는 사람이 상대방을 향한 소켓을 종료하겠다는 FIN으로 시작하면,<br>
상대방이 그 FIN에 대해 ACK를 먼저 보내고,<br>
이후 상대방도 자신도 상대방에게 FIN패킷을 보낸다.<br>
마지막으로 연결종료를 시도한 사람이 상대방의 FIN에 대한 ACK패킷을 보내면<br>
통신은 종료되고 서로의 고유한 디스크립터가 붙은 I/O는 캐쉬에서 사라진다.</p>
</blockquote>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://codenamenadja.github.io/2019/06/19/computing/network/3_step_in_tcp/" data-id="ckkdb52gm001b1pqkq7yyi0xe" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 이전</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">다음 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/custom-module/">custom module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fabric/">fabric</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/functional-programming/">functional programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-deploy/">hexo-deploy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pipenv/">pipenv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgresql/">postgresql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-module/">python module</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-post/">python post</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/testing/">testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travel-note/">travel_note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tutorial/">tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그 클라우드</h3>
    <div class="widget tagcloud">
      <a href="/tags/c/" style="font-size: 11.43px;">c</a> <a href="/tags/custom-module/" style="font-size: 12.86px;">custom module</a> <a href="/tags/django/" style="font-size: 14.29px;">django</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/fabric/" style="font-size: 10px;">fabric</a> <a href="/tags/functional-programming/" style="font-size: 11.43px;">functional programming</a> <a href="/tags/hexo-deploy/" style="font-size: 10px;">hexo-deploy</a> <a href="/tags/http/" style="font-size: 11.43px;">http</a> <a href="/tags/linux/" style="font-size: 15.71px;">linux</a> <a href="/tags/network/" style="font-size: 11.43px;">network</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/pipenv/" style="font-size: 10px;">pipenv</a> <a href="/tags/postgresql/" style="font-size: 10px;">postgresql</a> <a href="/tags/project/" style="font-size: 10px;">project</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/python-module/" style="font-size: 17.14px;">python module</a> <a href="/tags/python-post/" style="font-size: 18.57px;">python post</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/testing/" style="font-size: 10px;">testing</a> <a href="/tags/travel-note/" style="font-size: 10px;">travel_note</a> <a href="/tags/tutorial/" style="font-size: 10px;">tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">아카이브</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">1월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">9월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">8월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">7월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">6월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">5월 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">최근 포스트</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/26/fastcamp/my_post/">test_post</a>
          </li>
        
          <li>
            <a href="/2019/09/17/http/2_http_sementics/">http_1.0_sementics</a>
          </li>
        
          <li>
            <a href="/2019/09/09/project/travel_note/">travel_note 서비스 고찰</a>
          </li>
        
          <li>
            <a href="/2019/09/06/http/1_http_1.0_basic_four_feature/">http/1.0의 신택스: 기본이 되는 네가지 요소</a>
          </li>
        
          <li>
            <a href="/2019/09/05/python/post/async_coroutine_5/">비동기 코루틴 번역-5-End</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 junehan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>